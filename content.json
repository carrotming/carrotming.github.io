[{"title":"vuex学习之旅","date":"2017-08-06T11:52:00.000Z","path":"2017/08/06/vuex学习之旅/","text":"这一篇主要介绍vuex vuex介绍1vuex是一个状态管理器,可以很方便管理我们的数据以及各种状态 mutatins修改状态1234567891011121314151617181920212223242526272829303132333435363738Vuex提供了commit方法来修改状态$store为定义js文件的名称&lt;button @click=\"$store.commit('add')\"&gt;+&lt;/button&gt;&lt;button @click=\"$store.commit('reduce')\"&gt;-&lt;/button&gt;store.js文件：const mutations=&#123; add(state)&#123; state.count++; &#125;, reduce(state)&#123; state.count--; &#125;&#125;我们可以在Mutations里再加上一个参数，并在commit的时候传递就就可以了const mutations=&#123; add(state,n)&#123; state.count+=n; &#125;, reduce(state)&#123; state.count--; &#125;&#125;修改commit的方法&lt;p&gt; &lt;button @click=\"$store.commit('add',10)\"&gt;+&lt;/button&gt; &lt;button @click=\"$store.commit('reduce')\"&gt;-&lt;/button&gt;&lt;/p&gt;简化commit方法在模板count.vue里用import 引入我们的mapMutations：import &#123; mapState,mapMutations &#125; from 'vuex';在模板的&lt;script&gt;标签里添加methods属性，并加入mapMutations数组里面为方法名称 methods:mapMutations([ 'add','reduce']), state方位状态对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647通过这样定义const state=&#123; count:1&#125;这样暴露出去export default new Vuex.Store(&#123; state &#125;)使用&lt;h3&gt;&#123;&#123;$store.state.count&#125;&#125;&lt;/h3&gt;定义方法改变这些值$store.commit('add')\" 前面固定写法,括号里面为方法名字&lt;button @click=\"$store.commit('add')\"&gt;+&lt;/button&gt;&lt;button @click=\"$store.commit('reduce')\"&gt;-&lt;/button&gt;在mutations对象里面定义方法const mutations=&#123; add(state)&#123; state.count++; &#125;, reduce(state)&#123; state.count--; &#125;&#125;状态对象赋值给内部对象，也就是把stroe.js中的值，赋值给我们模板里data中的值。我们有三种赋值方式①通过computed的计算属性直接赋值,直接使用count来获取值computed:&#123; count()&#123; return this.$store.state.count; &#125;&#125;②通过mapState的对象来赋值,首先要用import引入mapState记住加上&#123;&#125;import &#123;mapState&#125; from 'vuex';在computed计算属性里写如下代码computed:mapState(&#123; count:state=&gt;state.count &#125;)③通过mapState的数组来赋值,一般常用这一种computed:mapState([\"count\"]) module模块组1234567891011121314151617181920声明模块组其中里面的为之前定义的,就是之前需要暴露出去的const moduleA=&#123; state,mutations,getters,actions&#125;这样方式暴露export default new Vuex.Store(&#123; modules:&#123;a:moduleA&#125;&#125;)在模板中使用 a为对应的名称&lt;h3&gt;&#123;&#123;$store.state.a.count&#125;&#125;&lt;/h3&gt;如果想用简单的方法引入，还是要在我们的计算属性中rutrun我们的状态。不能使用mapState了 ...mapState([\"count\"]),computed:&#123; count()&#123; return this.$store.state.a.count; &#125;&#125;, getters计算过滤操作1234567891011121314151617181920212223242526把他看作在获取数据之前进行的一种再编辑,相当于对数据的一个过滤和加工首先要在store.js里用const声明我们的getters属性。const getters = &#123; count:function(state)&#123; return state.count +=100; &#125;&#125;需要在Vuex.Store()里引入export default new Vuex.Store(&#123; state,mutations,getters&#125;)在computed进行配置computed:&#123; ...mapState([\"count\"]), count()&#123; return this.$store.getters.count; &#125;&#125;,用mapGetters简化模板写法import &#123; mapState,mapMutations,mapGetters &#125; from 'vuex';在computed属性中加入mapGetters...mapGetters([\"count\"]) actions异步修改状态12345678910111213141516171819202122232425262728293031323334actions和Mutations功能基本一样，不同点是，actions是异步的改变state状态，而Mutations是同步改变状态actions是可以调用Mutations里的方法的在actions里调用add和reduce两个方法。const actions =&#123; //第一种使用commit调用方法 addAction(context)&#123; context.commit('add',10) &#125;, //第二种使用commit调用方法 reduceAction(&#123;commit&#125;)&#123; commit('reduce') &#125;&#125;context：上下文对象，这里你可以理解称store本身。&#123;commit&#125;：直接把commit对象传递过来，可以让方法体逻辑和代码更清晰明了。再定义两个按钮&lt;p&gt; &lt;button @click=\"addAction\"&gt;+&lt;/button&gt; &lt;button @click=\"reduceAction\"&gt;-&lt;/button&gt;&lt;/p&gt;先用扩展运算符把mapMutations和mapActions加入。methods:&#123; ...mapMutations([ 'add','reduce' ]), ...mapActions(['addAction','reduceAction'])&#125;,记得import mapActionsimport &#123; mapState,mapMutations ,mapGetters,mapActions&#125; from 'vuex';","tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"//carrot.me/tags/vue2-0/"}]},{"title":"vue路由学习之旅","date":"2017-08-06T11:52:00.000Z","path":"2017/08/06/vue-router学习之旅/","text":"这一篇主要介绍vue-router vue的全家桶,路由,vue-cli构建项目,vuex状态管理器. vue-router介绍12主要作用是通过改变url的路劲传入不同的页面,大大方便了页面的复用性,这是在vue-cli的基础上进行的vue-router 解读routerIndex.JS12345678910111213141516通过以下方式进行路由的配置import Vue from 'vue' //引入Vueimport Router from 'vue-router' //引入vue-routerimport Hello from '@/components/Hello' //引入根目录下的Hello.vue组件Vue.use(Router) //Vue全局使用Routerexport default new Router(&#123; routes: [ //配置路由，这里是个数组 &#123; //每一个链接都是一个对象 path: '/', //链接路径 name: 'Hello', //路由名称， component: Hello //对应的组件模板 &#125; ]&#125;) 创建路由的模板123456789101112131415161718192021222324252627282930313233343536vue-cli的模板文件以.vue作为后缀,这样配置模板编写文件内容，文件要包括三个部分&lt;template&gt;&lt;script&gt;和&lt;style&gt;。文件很简单，只是打印一句话。Hi.vue&lt;template&gt; &lt;div class=\"hello\"&gt; &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'hi', data () &#123; return &#123; msg: 'Hi, I am JSPang' &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;然后在index.js引入组件import Hi from '@/components/Hi'增加路由配置：在router/index.js文件的routes[]数组中，新增加一个对象，代码如下。&#123; path:'/hi', name:'Hi', component:Hi&#125;要想使用路由页面通过&lt;router-view&gt;&lt;/router-view&gt;实现 router-link制作导航1234567制作链接需要&lt;router-link&gt;标签语法 &lt;router-link to=\"/\"&gt;[显示字段]&lt;/router-link&gt; to地址 是我们的导航路径，要填写的是你在router/index.js文件里配置的path值，如果要导航到默认首页，只需要写成 to=”/” ， [显示字段] ：就是我们要显示给用户的导航名称，比如首页 新闻页。 子路由应用123456789101112131415161718192021222324252627282930在app.vue中新加2个导航 &lt;router-link to=\"/hi/hi1\"&gt;Hi页面1&lt;/router-link&gt; &lt;router-link to=\"/hi/hi2\"&gt;Hi页面2&lt;/router-link&gt; 从路径可以看出 hi1和hi2为hi的子路由在hi.vue 父模板中加入&lt;router-view&gt;&lt;/router-view&gt;来展示路由的模板新建hi1.vue和hi2.vue 模板,和hi.vue内容一样,只是去掉&lt;router-view&gt;&lt;/router-view&gt;和改变现实的内容在router文件下的index.js 更改配置,在hi配置写上 &#123; path:'/hi', name:'Hi', component:Hi, //子路由 children:[ &#123; path: '/', component: Hi &#125;, &#123; path: 'hi1', component: Hi1 &#125;, &#123; path: 'hi2', component: Hi2 &#125;, ] &#125;注意path的写法,这样就实现了子路由的显示,包括显示自己 url传递参数1234567891011121314151617:冒号的形式传递参数在index.js目录这样配置&#123; path:'/params/:newsId/:newsTitle', component:Params&#125;在对应模板通过这种方式获取url参数的值&#123;&#123; $route.params.newsId&#125;&#125;&#123;&#123; $route.params.newsTitle&#125;&#125;给导航的to添加对应的url地址&lt;router-link to=\"/params/198/jspang website is very good\"&gt;params&lt;/router-link&gt;还可以对指定的数据正则匹配path:'/params/:newsId(\\\\d+)/:newsTitle', 路由传参1234567891011121314151617181920212223242526第一种方式,通过name属性来进行传递 routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125; ]在模板中通过用$route.name的形势接收假如设置了子路由,name属性会失效第二种方式通过&lt;router-link&gt; 标签中的to传参用法:&lt;router-link :to=\"&#123;name:xxx,params:&#123;key:value&#125;&#125;\"&gt;valueString&lt;/router-link&gt;这里的to前边是带冒号的两个参数的解释name：就是我们在路由配置文件中起的name值。params：就是我们要传的参数，它也是对象形势，在对象里可以传递多个值在模板里使用&#123;&#123;$route.params.xxx&#125;&#125; 的方式获得 路由过渡动画123456789101112131415161718192021222324252627282930313233想让路由有过渡动画，需要在&lt;router-view&gt;标签的外部添加&lt;transition&gt;标签，标签还需要一个name属性。&lt;transition name=\"fade\"&gt; &lt;router-view &gt;&lt;/router-view&gt;&lt;/transition&gt;组件过渡过程中，会有四个CSS类名进行切换，这四个类名与transition的name属性有关，比如name=”fade”,会有如下四个CSS类名：fade-enter:进入过渡的开始状态，元素被插入时生效，只应用一帧后立刻删除。fade-enter-active:进入过渡的结束状态，元素被插入时就生效，在过渡过程完成后移除。fade-leave:离开过渡的开始状态，元素被删除时触发，只应用一帧后立刻删除。fade-leave-active:离开过渡的结束状态，元素被删除时生效，离开过渡完成后被删除ade-enter-active和fade-leave-active在整个进入或离开过程中都有效，所以CSS的transition属性在这两个类下进行设置。//透明度.fade-enter &#123; opacity:0;&#125;.fade-leave&#123; opacity:1;&#125;.fade-enter-active&#123; transition:opacity .5s;&#125;.fade-leave-active&#123; opacity:0; transition:opacity .5s;&#125;过渡模式mode：in-out:新元素先进入过渡，完成之后当前元素过渡离开。out-in:当前元素先进行过渡离开，离开完成后新元素过渡进入。 路由钩子函数123456789101112131415161718192021222324252627282930313233343536373839404142路由的钩子选项可以写在路由配置文件中，也可以写在我们的组件模板中在路由配置文件（/src/router/index.js）中写钩子函数。但是在路由文件中我们只能写一个beforeEnter&#123; path:'/params/:newsId(\\\\d+)/:newsTitle', component:Params, beforeEnter:(to,from,next)=&gt;&#123; console.log('我进入了params模板'); console.log(to); console.log(from); next();&#125;,to:路由将要跳转的路径信息，信息是包含在对像里边的。from:路径跳转前的路径信息，也是一个对象的形式。next:路由的控制参数，常用的有next(true)和next(false)。写了钩子函数如果不调用next()方法的话,路由不会跳转写在模板中的钩子函数写在模板中就可以有两个钩子函数可以使用：beforeRouteEnter：在路由进入前的钩子函数。beforeRouteLeave：在路由离开前的钩子函数。export default &#123; name: 'params', data () &#123; return &#123; msg: 'params page' &#125; &#125;, beforeRouteEnter:(to,from,next)=&gt;&#123; console.log(\"准备进入路由模板\"); next(); &#125;, beforeRouteLeave: (to, from, next) =&gt; &#123; console.log(\"准备离开路由模板\"); next(); &#125;&#125; 单页面多路由12345678910111213141516171819多路由区域就是指一个页面存在多个&lt;router-view&gt; 区域 &lt;router-view name=\"left\" style=\"float:left;width:50%;background-color:#ccc;height:300px;\"&gt;&lt;/router-view&gt; &lt;router-view name=\"right\" style=\"float:right;width:50%;background-color:#c0c;height:300px;\"&gt;&lt;/router-view&gt; 通过设置name 区分不同路由区域 配置文件index.js 注意如果一个页面有多个路由 components 是有s的 &#123; path: '/', components: &#123; default:Hello, left:Hi1, right:Hi2 &#125; &#125; 编程式导航1234567891011121314的编程式导航，顾名思义，就是在业务逻辑代码中实现导航。this.$router.go(-1) 和 this.$router.go(1)这两个编程式导航的意思是后退和前进this.$router.push(‘/xxx ‘)这个编程式导航都作用就是跳转，比如我们判断用户名和密码正确时,需要跳转到用户中心页面或者首页，都用到这个编程的方法来操作路由。&lt;button @click=\"goHome\"&gt;回到首页&lt;/button&gt; goHome()&#123; this.$router.push('/'); &#125; 重定向123456789101112131415在路由配置文件中（/src/router/index.js）把原来的component换成redirect参数就可以了&#123; path:'/goback', redirect:'/' &#125; redirect 为重定向的路径 重定向时传递参数 只需要在redirect后边的参数里复制重定向路径的path参数就可以了 &#123; path:'/goParams/:newsId(\\\\d+)/:newsTitle', redirect:'/params/:newsId(\\\\d+)/:newsTitle'&#125; alias用法1234567891011121314151617181920212223使用alias别名的形式，我们也可以实现类似重定向的效果。在路由配置文件里（/src/router/index.js）&#123; path: '/hi1', component: Hi1, alias:'/carrot' &#125;在导航to写上alias的名称,就可以一样显示component的模板了&lt;router-link to=\"/jspang\"&gt;jspang&lt;/router-link&gt;redirect和alias的区别redirect：仔细观察URL，redirect是直接改变了url的值，把url变成了真实的path路径。alias：URL路径没有别改变，这种情况更友好，让用户知道自己访问的路径，只是改变了&lt;router-view&gt;中的内容。要特别注意的是别名请不要用在path为’/’中，如下代码的别名是不起作用的。&#123; path: '/', component: Hello, alias:'/home'&#125; mode和404页面1234567891011121314151617181920mode的两个值histroy:当你使用 history 模式时，URL 就像正常的 url，也好看！hash:默认’hash’值，但是hash看起来就像无意义的字符排列，不太好看也不符合我们一般的网址浏览习惯。404页面的设置：用户会经常输错页面，当用户输错页面时，我们希望给他一个友好的提示，1.设置我们的路由配置文件（/src/router/index.js）path地方写上*&#123; path:'*', component:Error&#125;2.新建404页面：3.在用&lt;router-link&gt;写一个标签的路径代表404&lt;router-link to=\"/64564656\"&gt;我是404页面&lt;/router-link&gt;","tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"//carrot.me/tags/vue2-0/"}]},{"title":"vue-cli学习之旅","date":"2017-08-06T11:52:00.000Z","path":"2017/08/06/vue-cli学习之旅/","text":"这一篇主要介绍vue-cli vue的全家桶,路由,vue-cli构建项目,vuex状态管理器. vue-cli介绍1234567891011121314151617181920212223242526272829303132333435363738394041424344454647vue-cli脚手架工具就是为我们搭建了开发所需要的环境们可以用npm 命令安装vue-cli了，在命令行输入下面的命令：npm install vue-cli -gvue init命令来初始化项目vue init &lt;template-name&gt; &lt;project-name&gt;&lt;template-name&gt;：表示模板名称，vue-cli官方为我们提供了5种模板，webpack-一个全面的webpack+vue-loader的模板，功能包括热加载，linting,检测和CSS扩展。webpack-simple-一个简单webpack+vue-loader的模板，不包含其他功能，让你快速的搭建vue的开发环境。browserify-一个全面的Browserify+vueify 的模板，功能包括热加载，linting,单元检测。browserify-simple-一个简单Browserify+vueify的模板，不包含其他功能，让你快速的搭建vue的开发环境。simple-一个最简单的单页应用模板。用webpack&lt;project-name&gt;：标识项目名称，这个你可以根据自己的项目来起名字。输入命令后Project name :项目名称 ，如果不需要更改直接回车就可以了。注意：这里不能使用大写，所以我把名称改成了vueclitestProject description:项目描述，默认为A Vue.js project,直接回车，不用编写。Author：作者，如果你有配置git的作者，他会读取。Install vue-router? 是否安装vue的路由插件，我们这里需要安装，所以选择YUse ESLint to lint your code? 是否用ESLint来限制你的代码错误和风格。我们这里不需要输入n，如果你是大型团队开发，最好是进行配置。setup unit tests with Karma + Mocha? 是否需要安装单元测试工具Karma+Mocha，我们这里不需要，所以输入n。Setup e2e tests with Nightwatch?是否安装e2e来进行用户行为模拟测试，我们这里不需要，所以输入n。命令行出现上面的文字，说明我们已经初始化好了第一步。命令行提示我们现在可以作的三件事情。1、cd vuecliTest 进入我们的vue项目目录。2、npm install 安装我们的项目依赖包，也就是安装package.json里的包，如果你网速不好，你也可以使用cnpm来安装。3、npm run dev 开发模式下运行我们的程序。给我们自动构建了开发用的服务器环境和在浏览器中打开，并实时监视我们的代码更改，即时呈现给我们。4 npm run build 进行项目的打包,会生成一个dist目录,里面自动帮我帮资源打包 vue-cli模板介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051npm run build 命令何把写好的Vue网页放到服务器上，那我就在这里讲解一下，主要的命令就是要用到npm run build 命令。我们在命令行中输入npm run build命令后，vue-cli会自动进行项目发布打包。你在package.json文件的scripts字段中可以看出，你执行的npm run build命令就相对执行的 node build/build.js 。在执行完npm run build命令后，在你的项目根目录生成了dist文件夹，这个文件夹里边就是我们要传到服务器上的文件。dist文件夹下目录包括：index.html 主页文件:因为我们开发的是单页web应用，所以说一般只有一个html文件。static 静态资源文件夹：里边js、CSS和一些图片。main.js文件解读main.js是整个项目的入口文件,在src文件夹下：通过代码可以看出这里引进了App的组件和&lt;App/&gt;的模板，它是通过 import App from ‘./App’这句代码引入的。 我们找到App.vue文件import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false //生产环境提示，这里设置成了false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;)App.vue文件:app.vue文件我们可以分成三部分解读，&lt;template&gt;&lt;/template&gt;标签包裹的内容：这是模板的HTMLDom结构，里边引入了一张图片和&lt;router-view&gt;&lt;/router-view&gt;标签，&lt;router-view&gt;标签说明使用了路由机制。我们会在以后专门拿出一篇文章讲Vue-router。&lt;script&gt;&lt;/script&gt;标签包括的js内容：你可以在这里些一些页面的动态效果和Vue的逻辑代码。&lt;style&gt;&lt;/style&gt;标签包裹的css内容：这里就是你平时写的CSS样式，对页面样子进行装饰用的，需要特别说明的是你可以用&lt;style scoped&gt;&lt;/style&gt;来声明这些css样式只在本模板中起作用。router/index.js 路由文件们可以看到 import Hello from ‘@/components/Hello’这句话， 文件引入了/components/Hello.vue文件。这个文件里就配置了一个路由，就是当我们访问网站时给我们显示Hello.vue的内容。import Vue from 'vue'import Router from 'vue-router'import Hello from '@/components/Hello'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'Hello', component: Hello &#125; ]&#125;)Hello.vue文件解读：也是分为&lt;template&gt;&lt;script&gt;&lt;style&gt;三个部分，以后我们大部分的工作都是写这些.vue结尾的文件 vue-cli目录介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216.|-- build // 项目构建(webpack)相关代码| |-- build.js // 生产环境构建代码| |-- check-version.js // 检查node、npm等版本| |-- dev-client.js // 热重载相关| |-- dev-server.js // 构建本地服务器| |-- utils.js // 构建工具相关| |-- webpack.base.conf.js // webpack基础配置| |-- webpack.dev.conf.js // webpack开发环境配置| |-- webpack.prod.conf.js // webpack生产环境配置|-- config // 项目开发环境配置| |-- dev.env.js // 开发环境变量| |-- index.js // 项目一些配置变量| |-- prod.env.js // 生产环境变量| |-- test.env.js // 测试环境变量|-- src // 源码目录| |-- components // vue公共组件| |-- store // vuex的状态管理| |-- App.vue // 页面入口文件| |-- main.js // 程序入口文件，加载各种公共组件|-- static // 静态文件，比如一些图片，json数据等| |-- data // 群聊分析得到的数据用于数据可视化|-- .babelrc // ES6语法编译配置|-- .editorconfig // 定义代码格式|-- .gitignore // git上传需要忽略的文件格式|-- README.md // 项目说明|-- favicon.ico|-- index.html // 入口页面|-- package.json // 项目基本信息重要文件介绍package.jsonpackage.json文件是项目根目录下的一个文件，定义该项目开发所需要的各种模块以及一些项目配置信息（如项目名称、版本、描述、作者等）。package.json 里的scripts字段，这个字段定义了你可以用npm运行的命令。在开发环境下，在命令行工具中运行npm run dev 就相当于执行 node build/dev-server.js .也就是开启了一个node写的开发行建议服务器。由此可以看出script字段是用来指定npm相关命令的缩写。dependencies字段指项目运行时所依赖的模块；devDependencies字段指定了项目开发时所依赖的模块；webpack配置相关dev-server.js 介绍// 检查 Node 和 npm 版本require('./check-versions')()// 获取 config/index.js 的默认配置var config = require('../config')// 如果 Node 的环境无法判断当前是 dev / product 环境// 使用 config.dev.env.NODE_ENV 作为当前的环境if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)// 使用 NodeJS 自带的文件路径工具var path = require('path')// 使用 expressvar express = require('express')// 使用 webpackvar webpack = require('webpack')// 一个可以强制打开浏览器并跳转到指定 url 的插件var opn = require('opn')// 使用 proxyTablevar proxyMiddleware = require('http-proxy-middleware')// 使用 dev 环境的 webpack 配置var webpackConfig = require('./webpack.dev.conf')// default port where dev server listens for incoming traffic// 如果没有指定运行端口，使用 config.dev.port 作为运行端口var port = process.env.PORT || config.dev.port// Define HTTP proxies to your custom API backend// https://github.com/chimurai/http-proxy-middleware// 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置var proxyTable = config.dev.proxyTable// 使用 express 启动一个服务var app = express()// 启动 webpack 进行编译var compiler = webpack(webpackConfig)// 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中var devMiddleware = require('webpack-dev-middleware')(compiler, &#123; publicPath: webpackConfig.output.publicPath, stats: &#123; colors: true, chunks: false &#125;&#125;)// 启动 webpack-hot-middleware，也就是我们常说的 Hot-reloadvar hotMiddleware = require('webpack-hot-middleware')(compiler)// force page reload when html-webpack-plugin template changescompiler.plugin('compilation', function (compilation) &#123; compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) &#123; hotMiddleware.publish(&#123; action: 'reload' &#125;) cb() &#125;)&#125;)// proxy api requests// 将 proxyTable 中的请求配置挂在到启动的 express 服务上Object.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] if (typeof options === 'string') &#123; options = &#123; target: options &#125; &#125; app.use(proxyMiddleware(context, options))&#125;)// handle fallback for HTML5 history API// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址app.use(require('connect-history-api-fallback')())// serve webpack bundle output// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上app.use(devMiddleware)// enable hot-reload and state-preserving// compilation error display// 将 Hot-reload 挂在到 express 服务上app.use(hotMiddleware)// serve pure static assets// 拼接 static 文件夹的静态资源路径var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)// 为静态资源提供响应服务app.use(staticPath, express.static('./static'))// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err) return &#125; var uri = 'http://localhost:' + port console.log('Listening at ' + uri + '\\n') // when env is testing, don't need open it // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址 if (process.env.NODE_ENV !== 'testing') &#123; opn(uri) &#125;&#125;)webpack.base.confg.js webpack的基础配置文件......module.export = &#123; // 编译入口文件 entry: &#123;&#125;, // 编译输出路径 output: &#123;&#125;, // 一些解决方案配置 resolve: &#123;&#125;, resolveLoader: &#123;&#125;, module: &#123; // 各种不同类型文件加载器配置 loaders: &#123; ... ... // js文件用babel转码 &#123; test: /\\.js$/, loader: 'babel', include: projectRoot, // 哪些文件不需要转码 exclude: /node_modules/ &#125;, ... ... &#125; &#125;, // vue文件一些相关配置 vue: &#123;&#125;&#125;.babelrcBabel解释器的配置文件，存放在根目录下。Babel是一个转码器，项目里需要用它将ES6代码转为ES5代码。&#123; //设定转码规则 \"presets\": [ [\"env\", &#123; \"modules\": false &#125;], \"stage-2\" ], //转码用的插件 \"plugins\": [\"transform-runtime\"], \"comments\": false, //对BABEL_ENV或者NODE_ENV指定的不同的环境变量，进行不同的编译操作 \"env\": &#123; \"test\": &#123; \"presets\": [\"env\", \"stage-2\"], \"plugins\": [ \"istanbul\" ] &#125; &#125;&#125;.editorconfig该文件定义项目的编码规范，编译器的行为会与.editorconfig文件中定义的一致，并且其优先级比编译器自身的设置要高，这在多人合作开发项目时十分有用而且必要。root = true[*] // 对所有文件应用下面的规则charset = utf-8 // 编码规则用utf-8indent_style = space // 缩进用空格indent_size = 2 // 缩进数量为2个空格end_of_line = lf // 换行符格式insert_final_newline = true // 是否在文件的最后插入一个空行trim_trailing_whitespace = true // 是否删除行尾的空格","tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"//carrot.me/tags/vue2-0/"}]},{"title":"vue2.0学习之旅","date":"2017-07-16T09:33:00.000Z","path":"2017/07/16/vue2.0学习之旅/","text":"vue2.0,尤雨溪华人的杰作 介绍vue2.0是在vue1.0之上进行的升级,虽然剔除了某些功能,但是使得整一个框架大小变得更加轻盈 基础部分基本结构12345678910111213141516171819202122232425262728293031323334vue和angular的区别还是有,看看vue的基本结构 js代码 new Vue(&#123; // 创建的控制器 el:'#box1', // 创建的Vue对象作用范围是多大 el：后面跟上先择器。 data:&#123; //模型 msg:'hello world', name:'xmg' &#125; &#125;); new Vue(&#123; el:'.box2', data:&#123; msg:\"box2Data\" &#125; &#125;); new Vue(&#123; //这一种写法不建议，在2.0已经不允许直接选择body el:'body', data:&#123; msg:\"body msg\" &#125; &#125;)html结构&lt;div id=\"box1\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;div class=\"box2\"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;通过new Vue 创建一个vue的实例对象通过el属性 绑定元素通过data属性 来设置数据, 数据双向绑定12&lt;input type=\"text\" v-model=\"msg\"&gt;&lt;!--双向绑定时，属性必须得要初始化--&gt;和angular中的ng-model用法一样,实现原理不同,以后会介绍 内置指令12345678910v-text=\"msg\" 解析非html的数据v-html=\"content\" 解析html的结构v-show 是否显示v-if 是否隐藏v-for=\"(key,value) in stuList\"&gt; 循环遍历 2.0不支持自带$indexv-pre 不去解析里面内容&#123;&#123;*msg&#125;&#125; 仅仅绑定一次 2.0使用v-oncev-on:事件类型=\"事件方法\" 没参数可以不带();@click=\"show\" 绑定事件简写&#123;&#123;msg | uppercase |lowercase&#125;&#125; 过滤器,通过管道符 从2.0开始，删除了所有的内置过滤器 自定义过滤器1234567 /*通过全局对象Vue来自定义过滤器*/ Vue.filter('Currency',function (input,a,b) &#123; return \"$\"+input+a+b &#125;);使用 &#123;&#123;msg | Currency '#' '$'&#125;&#125; Currency('#','$') 这种方式就是2.0传参 自定义指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 /** * el: 指令所绑定的元素，可以用来直接操作DOM。 binding: 一个对象，包含指令的很多信息。 vnode: Vue编译生成的虚拟节点。 */Vue.direvtive('carromting',function(el,binding,vnode)&#123; el.style = 'color:' + binding.value;&#125;)使用&lt;!--绑定自定义指令--&gt;&lt;div v-carrotming=\"color\" v-text=\"msg\"&gt;&lt;/div&gt;color为data里的color data:&#123; msg:10, color:'blue' &#125;, /** * 自定义指令的生命周期 * * bind: 指令被绑定了 * * inserted: 指令绑定到节点上了 * * update: 组件更新 * * componentUpdated:组件更新完成了 * * unbind:解除绑定 调用$destroy 方法 */ Vue.directive('carrotming',&#123; bind:function()&#123;//被绑定 console.log('1 - bind'); &#125;, inserted:function()&#123;//绑定到节点 console.log('2 - inserted'); &#125;, update:function()&#123;//组件更新 console.log('3 - update'); &#125;, componentUpdated:function()&#123;//组件更新完成 console.log('4 - componentUpdated'); &#125;, unbind:function()&#123;//解绑 console.log('1 - bind'); &#125; &#125;); extend扩展实例构造器123456789101112131415161718192021//扩展实例构造器 /** * template:模板的地址或内容 * * data:这里的data需要是一个函数,在函数里面返回数据 * */var carrotExtend = Vue.extend(&#123; //模板 template: \"&lt;p&gt;&lt;a :href='carrotUrl'&gt;&#123;&#123;carrotName&#125;&#125;&lt;/a&gt;&lt;/p&gt;\", data()&#123; return &#123; carrotName:'萝卜名', carrotUrl:'http://carrotming.cn' &#125; &#125; &#125;); //挂载 $mount() 传入你想定义标签名称 new carrotExtend().$mount('carrot'); watch监控数据1234567891011121314151617/* 有些时候我们会用实例属性的形式来写watch监控。 也就是把我们watch卸载构造器的外部，这样的好处就是降低我们程序的耦合度，使程序变的灵活。 temperature 被监听的数据 * */ app.$watch('temperature',function(newVal,oldVal)&#123; if(newVal&gt;=26)&#123; this.suggestion=suggestion[0]; &#125;else if(newVal&lt;26 &amp;&amp; newVal &gt;=0) &#123; this.suggestion=suggestion[1]; &#125;else&#123; this.suggestion=suggestion[2]; &#125; &#125;); 也可以直接在new Vue上绑定watch方法 slot内置组件12345678910111213141516/* slot是标签的内容扩展，也就是说你用slot就可以在自定义组件时传递给组件内容，组件接收内容并输出。 slot的使用需要两步 在HTML的组件中用slot属性传递值。 在组件模板中用&lt;slot&gt;&lt;/slot&gt;标签接收值 * */&lt;div&gt; &lt;p&gt;博客地址：&lt;slot name=\"bolgUrl\"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;p&gt;网名：&lt;slot name=\"netName\"&gt;&lt;/slot&gt;&lt;/p&gt; &lt;p&gt;技术类型：&lt;slot name=\"skill\"&gt;&lt;/slot&gt;&lt;/p&gt;&lt;/div&gt;&lt;span slot=\"bolgUrl\"&gt;&#123;&#123;jsData.bolgUrl&#125;&#125;&lt;/span&gt;&lt;span slot=\"netName\"&gt;&#123;&#123;jsgData.netName&#125;&#125;&lt;/span&gt;&lt;span slot=\"skill\"&gt;&#123;&#123;jsData.skill&#125;&#125;&lt;/span&gt; propsData传递数据1234567891011121314151617181920212223 /* propsData 不是和属性有关，他用在全局扩展时进行传递数据,在全局扩展的挂载 过程中传入数据 我们用propsData三步解决传值： 1、在全局扩展里加入props进行接收。propsData:&#123;a:1&#125; 2、传递时用propsData进行传递。props:[‘a’] 3、用插值的形式写入模板。&#123;&#123; a &#125;&#125; * */var carrot = Vue.extend(&#123; template:`&lt;p&gt;&#123;&#123;msg&#125;&#125; --- &#123;&#123;a&#125;&#125;&lt;/p&gt;`, data()&#123; return&#123; msg:'我是萝卜名' &#125; &#125;, props:['a'] &#125;); new carrot(&#123;propsData:&#123;a:1&#125;&#125;).$mount('carrot'); Mixins混入1234567891011121314151617181920212223242526272829303132/* Mixins一般有两种用途： 1、在你已经写好了构造器后，需要增加方法或者临时的活动时使用的方法，这时用混入会减少源代码的污染。 2、很多地方都会用到的公用方法，用混入的方法可以减少代码量，实现代码重用。 Mixins基本用法, 当混入方法和构造器的方法重名时，混入的方法无法展现，也就是不起作用。 全局混入的执行顺序要前于混入和构造器里的方法。 * */ /*全局混合*/ Vue.mixin(&#123; updated:function()&#123; console.log('我是全局被混入的'); &#125; &#125;)var addLog = &#123; updated()&#123; console.log(\"数据放生变化,变化成\"+this.num+\".\"); &#125; &#125;;new Vue里面 /* 混入 * */ mixins:[addLog], /* 先执行混合的方法,在执行构造器 * */ updated()&#123; console.log(\"构造器里的updated方法。\") methods方法1234567891011121314151617181920212223242526/* ①methods中参数的传递 ②methods中$enent参数 包含了大部分鼠标事件的属性。 ③native 给组件绑定构造器里的原生事件。 在实际开发中经常需要把某个按钮封装成组件， 然后反复使用，如何让组件调用构造器里的方法，而不是组件里的方法。 就需要用到我们的native修饰器了。 ④作用域外部调用构造器里的方法 * */ * &lt;div id=\"app\"&gt; &lt;div&gt;&#123;&#123;a&#125;&#125;&lt;/div&gt; &lt;!--参数传递--&gt; &lt;button @click=\"add(2,$event)\"&gt;点击&lt;/button&gt; &lt;!--绑定native使用构造器的方法--&gt; &lt;p&gt;&lt;btn @click.native=\"add(3)\"&gt;&lt;/btn&gt;&lt;/p&gt;&lt;/div&gt; var btn = &#123; template:`&lt;button&gt;组件Add&lt;/button&gt;` &#125;; //组件化 components:&#123; \"btn\":btn &#125;&lt;!--作用域外调用--&gt;&lt;button onclick=\"app.add(4)\" &gt;外部调用构造器里的方法&lt;/button&gt; extends扩展选项12345678910111213141516171819202122232425262728293031/* 通过外部增加对象的形式，对构造器进行扩展。它和混入非常的类似 如果构造器没有的方法,会到扩展的methods去寻找,如果有就使用,反之,就使用构造器的方法 * */var method = &#123; created()&#123; console.log(\"我是被扩展出来的\"); &#125;, methods:&#123; add()&#123; console.log('我是被扩展出来的方法！'); &#125; &#125; &#125;;var app = new Vue(&#123; data:&#123; message:'萝卜名' &#125;, methods:&#123; add()&#123; console.log('我是原生方法'); &#125; &#125;, /* 扩展 * */ extends:method &#125;).$mount('#app'); delimiters选项1234567891011/* delimiters的作用是改变我们插值的符号。 Vue默认的插值是双大括号&#123;&#123;&#125;&#125;。但有时我们会有需求更改这个插值的形式。 * */ /* 默认插值语法&#123;&#123;&#125;&#125; 更改为$&#123;&#125; * */ delimiters:['$&#123;','&#125;'] &lt;div&gt;$&#123;msg&#125;&lt;/div&gt; component标签1234567 /* &lt;component&gt;&lt;/component&gt;标签是Vue框架自定义的标签， 它的用途就是可以动态绑定我们的组件，根据数据的不同更换不同的组件。 * */&lt;!--根据who的值不同，调用不同的组件--&gt; &lt;component v-bind:is=\"who\"&gt;&lt;/component&gt; component组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 /* 全局化组件 * */ Vue.component('carrot',&#123; template:`&lt;div style=\"color:red;\"&gt;我是全局萝卜名组件&lt;/div&gt;` &#125;);/* 外部组件 * */ var carrot = &#123; template:`&lt;div style=\"color:red;\"&gt;我是外部组件&lt;/div&gt;`, &#125;;/* 外部组件引用 * */ /*components:&#123; \"carrot\":carrot &#125;*/ /* 父子组件的嵌套 * */ var child = &#123; template:`&lt;div style=\"color:red;\"&gt;我是子组件&lt;/div&gt;`, &#125;; var parent = &#123; template: `&lt;div&gt;我是父组件嵌套&lt;child&gt;&lt;/child&gt;&lt;/div&gt;`, components:&#123; \"child\":child &#125; &#125;; /* 父组件 * */ components:&#123; \"parent\":parent &#125;/* 局部注册的组件只能在组件注册的作用域里进行使用，其他作用域使用无效。 下面的carrot即为组件名称,props选项就是设置和获取标签上的属性值的 * */ /*components:&#123; \"carrot\":&#123; template:`&lt;div style=\"color:red;\"&gt;我是局部&#123;&#123;here&#125;&#125;组件&lt;/div&gt;`, props:['here'] &#125; &#125;*/html结构&lt;!--对应props的属性值,把数据传递到模板中--&gt; &lt;!--&lt;carrot here=\"萝卜名here\"&gt;&lt;/carrot&gt;--&gt; &lt;!--构造器往组件传值--&gt; &lt;!--&lt;carrot v-bind:here=\"name\"&gt;&lt;/carrot&gt;--&gt; &lt;!--外部组件方式--&gt; &lt;!--&lt;carrot&gt;&lt;/carrot&gt;--&gt; &lt;!--父组件嵌套子组件--&gt; &lt;parent&gt;&lt;/parent&gt; computed计算选项12345678910111213141516171819202122 /* computed 的作用主要是对原数据进行改造输出。 改造输出：包括格式的编辑，大小写转换，顺序重排，添加符号……。 * */ computed:&#123; /*价格重新计算*/ newPrice()&#123; return this.price='￥' + this.price + '元'; &#125;, /*数组的排序*/ reverseNews()&#123; return this.newsList.reverse(); &#125; &#125;&lt;div&gt; &lt;!--写上computed的 函数名--&gt; &#123;&#123;newPrice&#125;&#125; &lt;/div&gt; &lt;!--写上computed的 函数名--&gt; &lt;li v-for=\" (item,index) in reverseNews\"&gt;&#123;&#123;item.date&#125;&#125;&lt;/li&gt; set设置数据123456 //vue.set 作用,改变外部的数据变化,并且可以自动更新var outData = &#123; arr:['aaa','bbb','ccc'] &#125;;//第一个参数为数据源,第二个为索引,第三个为修改成什么值 Vue.set(app.arr,1,'ddd'); 模板的制作1234567891011121314151617 //第一种模板的制作方式// template:`&lt;h1 style=\"color:red\"&gt;我是选项模板&lt;/h1&gt;` //第二种方式// template:'#demo2' //第三种方式 template:'#demo3'第二种&lt;!--通过template标签定义模板--&gt;&lt;template id=\"demo2\"&gt; &lt;h1 style=\"color:red\"&gt;我是第二种选项模板&lt;/h1&gt;&lt;/template&gt;&lt;!--第三种方式--&gt;&lt;script type=\"x-template\" id=\"demo3\"&gt; &lt;h2 style=\"color:red\"&gt;我是script标签模板&lt;/h2&gt;&lt;/script&gt; 实例方法123456789/* $mount方法 用$mount的方法把XXX挂载到DOM上,生产一个Vue的实例 $destroy() 卸载方法 用$destroy()进行卸载。 $forceUpdate() 更新方法 $nextTick() 数据修改方法 当Vue构造器里的data值被修改完成后会调用这个方法 * */ 实例事件1234567891011121314151617181920212223242526272829303132333435/* 实例事件就是在构造器外部写一个调用构造器内部的方法。这样写 的好处是可以通过这种写法在构造器外部调用构造器内部的数据。 * */ /* $on 在构造器外部添加事件。 第一个参数为调用事件的名称，第二个为执行的函数 * */ app.$on('reduce',function()&#123; console.log('执行了reduce()'); this.num--; &#125;);/* 外部调用构造器的事件 $emit * */ function reduce() &#123; app.$emit('reduce'); &#125; /* $once执行一次的事件 * */ app.$once('reduceOnce',function()&#123; console.log('只执行一次的方法'); this.num--; &#125;); /* $off关闭事件 * */ function off()&#123; app.$off('reduce'); &#125; 实例属性123456789101112131415161718* 实例就是在构造器外部操作构造器内部的属性选项或者方法，就叫做实例 实例的作用就是给原生的或者其他javascript框架一个融合的接口或者说是机会，让 Vue和其他框架一起使用。 实例可以调用自定义方法 * */ /* 挂载,渲染完成 * */ mounted()&#123; $('#app').html('我是jQuery!'); &#125; /* 实例调用构造器的方法 * */ app.add(); 生命周期1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* 生命周期官方图流程 new Vue的实例之后进入beforeCreate过程,之后会 Observe Data(观察数据),初始化事件 init Events 然后才到created过程,判断是否有el这个选项, 没有的话需要等函数$mount执行才进行下一步,有的话会判断 有没有模板选项, 编译模板进行渲染.然后来到挂载之前,beforeMount 创建元素并且插入元素,然后挂载上去,mounted,当有数据更新的时候,更新之前,beforeUpdate, 进行虚拟dom的重新渲染和修补,最后会更新,这是一个循环过程 当方法$destory()被执行时候,销毁之前,beforeDestroy,会拆卸监听者watchers,子组件,事件监听者,最后到最后一步 destroyed * */7和8是在路由中用到的,也是vue2.0的var app=new Vue(&#123; el:'#app', data:&#123; message:1 &#125;, methods:&#123; jia:function()&#123; this.message ++; &#125; &#125;, beforeCreate:function()&#123; console.log('1-beforeCreate 初始化之后'); &#125;, created:function()&#123; console.log('2-created 创建完成'); &#125;, beforeMount:function()&#123; console.log('3-beforeMount 挂载之前'); &#125;, mounted:function()&#123; console.log('4-mounted 被创建'); &#125;, beforeUpdate:function()&#123; console.log('5-beforeUpdate 数据更新前'); &#125;, updated:function()&#123; console.log('6-updated 被更新后'); &#125;, activated:function()&#123; console.log('7-activated'); &#125;, deactivated:function()&#123; console.log('8-deactivated'); &#125;, beforeDestroy:function()&#123; console.log('9-beforeDestroy 销毁之前'); &#125;, destroyed:function()&#123; console.log('10-destroyed 销毁之后') &#125; &#125;)","tags":[{"name":"vue2.0","slug":"vue2-0","permalink":"//carrot.me/tags/vue2-0/"}]},{"title":"微信小程序的坑和注意点","date":"2017-07-15T09:33:00.000Z","path":"2017/07/15/微信小程序的坑和注意点/","text":"微信小程序,没有坑只有更坑,这个注意点会在以后的开发中逐步完善","tags":[{"name":"wechat","slug":"wechat","permalink":"//carrot.me/tags/wechat/"}]},{"title":"微信小程序学习之旅","date":"2017-06-20T09:33:00.000Z","path":"2017/06/20/微信小程序学习之旅/","text":"微信小程序,没有坑只有更坑 介绍微信小程序是微信推出的,是一个类似于原生APP的应用,开发方便 文件目录介绍小程序逻辑1234567891011121314151617181920212223242526272829303132通过app.js设置app.js是小程序的脚本代码,可以监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的 API，如本例的同步存储及同步读取本地数据.默认设置App(&#123; onLaunch: function () &#123; //调用API从本地缓存中获取数据 var logs = wx.getStorageSync('logs') || [] logs.unshift(Date.now()) wx.setStorageSync('logs', logs) &#125;, getUserInfo:function(cb)&#123; var that = this; if(this.globalData.userInfo)&#123; typeof cb == \"function\" &amp;&amp; cb(this.globalData.userInfo) &#125;else&#123; //调用登录接口 wx.login(&#123; success: function () &#123; wx.getUserInfo(&#123; success: function (res) &#123; that.globalData.userInfo = res.userInfo; typeof cb == \"function\" &amp;&amp; cb(that.globalData.userInfo) &#125; &#125;) &#125; &#125;); &#125; &#125;, globalData:&#123; userInfo:null &#125;&#125;) 小程序公共设置123456789101112131415app.json 设置 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口\b背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释默认设置&#123; \"pages\":[ \"pages/index/index\", \"pages/logs/logs\" ], \"window\":&#123; \"backgroundTextStyle\":\"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"WeChat\", \"navigationBarTextStyle\":\"black\" &#125;&#125; 小程序公共样式表1234567891011通过app.wxss设置是整个小程序的公共样式表。我们可以在页面组件的 class 属性上直接使用 app.wxss 中声明的样式规则。.container &#123; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: space-between; padding: 200rpx 0; box-sizing: border-box;&#125; 创建页面12345通过app.json的 \"pages\"绑定 且第一个为首页每一个页面有4个文件组成index.js、 index.wxml、 index.wxss、 index.json.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。默认设置 index.wxml123456789&lt;view class=\"container\"&gt; &lt;view bindtap=\"bindViewTap\" class=\"userinfo\"&gt; &lt;image class=\"userinfo-avatar\" src=\"&#123;&#123;userInfo.avatarUrl&#125;&#125;\" background-size=\"cover\"&gt;&lt;/image&gt; &lt;text class=\"userinfo-nickname\"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view class=\"usermotto\"&gt; &lt;text class=\"user-motto\"&gt;&#123;&#123;motto&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; index.js12345678910111213141516171819202122232425index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。var app = getApp()Page(&#123; data: &#123; motto: 'Hello World', userInfo: &#123;&#125; &#125;, //事件处理函数 bindViewTap: function() &#123; wx.navigateTo(&#123; url: '../logs/logs' &#125;) &#125;, onLoad: function () &#123; console.log('onLoad') var that = this //调用应用实例的方法获取全局数据 app.getUserInfo(function(userInfo)&#123; //更新数据 that.setData(&#123; userInfo:userInfo &#125;) &#125;) &#125;&#125;) index.wxss1是页面的样式表 如果不指定会使用app.wxss的样式,如果写了会覆盖app.wxss的样式 视图容器1介绍这个常用的,具体方法都能在官方文档找到哦 view视图1234567891011121314151617写样式和html很类似 通过class绑定样式 style也可以设置样式其中flex-direction: row 弹性布局横向布局 direction:column 弹性布局纵向布局 具体属性作用hover-class 指定按下去的样式类。当 hover-class=\"none\" 时，没有点击态效果hover-start-time 按住后多久出现点击态，单位毫秒hover-stay-time 手指松开后点击态保留时间，单位毫秒&lt;view class=\"section\"&gt; &lt;view class=\"flex-wrp\" style=\"flex-direction:row;\"&gt; &lt;view class=\"flex-item bc_green\"&gt;1&lt;/view&gt; &lt;view class=\"flex-item bc_red\"&gt;2&lt;/view&gt; &lt;view class=\"flex-item bc_blue\"&gt;3&lt;/view&gt; &lt;/view&gt;&lt;/view&gt; scroll-view视图123456789101112131415161718192021注意点:使用竖向滚动时，需要给&lt;scroll-view/&gt;一个固定高度，通过 WXSS 设置 height。请勿在 scroll-view 中使用 textarea、map、canvas、video 组件scroll-into-view 的优先级高于 scroll-top在滚动 scroll-view 时会阻止页面回弹，所以在 scroll-view 中滚动，是无法触发 onPullDownRefresh若要使用下拉刷新，请使用页面的滚动，而不是 scroll-view ，这样也能通过点击顶部状态栏回到页面顶部&lt;view class=\"section\"&gt; &lt;view class=\"section__title\"&gt;vertical scroll&lt;/view&gt; &lt;scroll-view scroll-y style=\"height: 200px;\" bindscrolltoupper=\"upper\" bindscrolltolower=\"lower\" bindscroll=\"scroll\" scroll-into-view=\"&#123;&#123;toView&#125;&#125;\" scroll-top=\"&#123;&#123;scrollTop&#125;&#125;\"&gt; &lt;view id=\"green\" class=\"scroll-view-item bc_green\"&gt;&lt;/view&gt; &lt;view id=\"red\" class=\"scroll-view-item bc_red\"&gt;&lt;/view&gt; &lt;view id=\"yellow\" class=\"scroll-view-item bc_yellow\"&gt;&lt;/view&gt; &lt;view id=\"blue\" class=\"scroll-view-item bc_blue\"&gt;&lt;/view&gt; &lt;/scroll-view&gt; &lt;view class=\"btn-area\"&gt; &lt;button size=\"mini\" bindtap=\"tap\"&gt;click me to scroll into view &lt;/button&gt; &lt;button size=\"mini\" bindtap=\"tapMove\"&gt;click me to scroll&lt;/button&gt; &lt;/view&gt;&lt;/view&gt; swiper组件123456789101112131415滑块视图容器。 也就是轮播图组件swiper-item仅可放置在&lt;swiper/&gt;组件中，宽高自动设置为100%。&lt;swiper indicator-dots=\"&#123;&#123;indicatorDots&#125;&#125;\" autoplay=\"&#123;&#123;autoplay&#125;&#125;\" interval=\"&#123;&#123;interval&#125;&#125;\" duration=\"&#123;&#123;duration&#125;&#125;\"&gt; &lt;block wx:for=\"&#123;&#123;imgUrls&#125;&#125;\"&gt; &lt;swiper-item&gt; &lt;image src=\"&#123;&#123;item&#125;&#125;\" class=\"slide-image\" width=\"355\" height=\"150\"/&gt; &lt;/swiper-item&gt; &lt;/block&gt;&lt;/swiper&gt;&lt;button bindtap=\"changeIndicatorDots\"&gt; indicator-dots &lt;/button&gt;&lt;button bindtap=\"changeAutoplay\"&gt; autoplay &lt;/button&gt;&lt;slider bindchange=\"intervalChange\" show-value min=\"500\" max=\"2000\"/&gt; interval&lt;slider bindchange=\"durationChange\" show-value min=\"1000\" max=\"10000\"/&gt; duration icon12图标。用来设置不同的icon图标 progress1用来设置滚动条 picker1从底部弹起的滚动选择器，现支持五种选择器，通过mode来区分，分别是普通选择器，多列选择器，时间选择器，日期选择器，省市区选择器，默认是普通选择器。 slider1滑动选择器。","tags":[{"name":"wechat","slug":"wechat","permalink":"//carrot.me/tags/wechat/"}]},{"title":"css3模仿QQ浏览器","date":"2017-01-08T07:02:00.000Z","path":"2017/01/08/css3-综合运用/","text":"拿个QQ浏览器模仿一下,加深对CSS3的运用 前言这篇博客是CSS3的综合运用,说白了,其实没什么难度,主要是锻炼一个人的耐心.把知识点给总结一下 大纲现在很流行滚滚棒效果,就是把滚动条给隐藏了,只留一个屏幕,通过鼠标的滚轮进行切换.所以每一页的宽度和高度都为100%,这里仅仅用到了一个jquery的插件,用来监听用户的滚轮事件,其他基本就是CSS3的运用,先确定哪些是这一页特有的内容,哪一些是固定不动的,就是无论怎么滚动都始终在第一页显示,而且所有元素都定位在中间,然后基于中间做一些调整.至于具体的一些元素的显示和隐藏则通过js来控制,点击控制也是通过js来控制.这里用到了一个叫架空类的东西,主要作用是给某一页绑定一个类,比如叫current,这个类的作用是让你想要的动画进行放大或者缩小,或者旋转之类操作,给我们想要动画的元素绑定过渡效果transition,然后当我们点击或者滚动滚轮时候,会把这个类给清除,然后就能特定动画过渡到原先的样子.形成一种很好看的特效. 实现过程主要难点是动画的制作,我们要把各自需要动的动画放在自己的父盒子中,这样避免冲突.这里用到了一个属性,就是当面向屏幕的元素是可见,反正不可见backface-visibility: hidden; 然后为了让一些动画有立体感,需要加上transform-style: preserve-3d,但需要进大远小的效果时候,可以用perspective:1200px;然后基本所有动画都是基于transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);这几个属性进行变化,动画可以用animation和transition来实现. 所以几乎每页所执行的操作都很类似,所以考验的是我们的一个耐性 第一页HTML代码12345678910111213141516171819202122&lt;!--第一个屏幕--&gt; &lt;section class=\"p1 current\"&gt; &lt;!--中间大logo--&gt; &lt;div class=\"bigLogo\"&gt; &lt;img src=\"images/logo.png\" alt=\"\"&gt; &lt;a href=\"javascript:;\"&gt;立即下载&lt;/a&gt; &lt;/div&gt; &lt;!--中间内容--&gt; &lt;div class=\"content1\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/page1_main_1.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page1_main_2.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page1_main_3.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page1_main_4.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page1_main_5.png\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--黄金圆环--&gt; &lt;div class=\"circle\"&gt; &lt;img src=\"images/page1_3_round.png\" alt=\"\"&gt; &lt;/div&gt; &lt;/section&gt; css代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384ection&#123; overflow: hidden; position: relative;&#125;section.p1,section.p2&#123; transition: all 1s linear;&#125;/*************进场动画**************/.p1.current,.p2.current&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(5) scaleY(5) scaleZ(5);&#125;/****************第一页内容*****************/section.p1&#123; background: url(../images/page1_glow.png) no-repeat center 100px, linear-gradient(0deg, #395ecb 0%, #3657be 35%, #242161 75%, #1a0531 100%);&#125;section.p1 .content1,section.p1 .content1 ul&#123; width: 700px; height: 500px; position: absolute; left: 50%; top: 50%; margin-left: -350px; margin-top: -250px;&#125;/*********************Ul旋转**********************/section.p1 .content1 ul&#123; transform-style: preserve-3d; animation: p1move 15s infinite alternate;&#125;@keyframes p1move&#123; 0%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); &#125;100%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(360deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); &#125;&#125;section.p1 .content1 ul&gt;li&#123; width: 580px; height: 361px; position: absolute; top: 50%; left: 50%; margin-left: -290px; margin-top: -180px; /*背向屏幕的元素不可见*/ backface-visibility: hidden;&#125;/************具体每一个li**************/section.p1 .content1 ul&gt;li:nth-child(1)&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;section.p1 .content1 ul&gt;li:nth-child(2)&#123; transform: translateX(0px) translateY(0px) translateZ(70px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;section.p1 .content1 ul&gt;li:nth-child(3)&#123; transform: translateX(0px) translateY(0px) translateZ(-70px) rotateX(0deg) rotateY(180deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;section.p1 .content1 ul&gt;li:nth-child(4)&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(180deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;section.p1 .content1 ul&gt;li:nth-child(5)&#123; transform: translateX(0px) translateY(0px) translateZ(70px) rotateX(0deg) rotateY(180deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;/*****************圆环***************/.circle&#123; width: 680px; height: 680px; position: absolute; left: 50%; top: 50%; margin-left: -340px; margin-top: -340px; animation: circleMove 2s infinite linear; transition: all 0.5s linear;&#125;@keyframes circleMove &#123; 0%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(-80deg) rotateY(-10deg) rotateZ(0deg) scaleX(2) scaleY(2) scaleZ(2); &#125;100%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(-80deg) rotateY(-10deg) rotateZ(360deg) scaleX(2) scaleY(2) scaleZ(2); &#125;&#125; 第二页HTML代码123456789101112131415161718192021222324&lt;!--第二个屏幕--&gt; &lt;section class=\"p2 current \" style=\"display: none\"&gt; &lt;div class=\"bg\"&gt; &lt;span&gt;&lt;/span&gt; &lt;img src=\"images/page2_glow.png\" alt=\"\"&gt; &lt;img src=\"images/page2_lineglow.png\" alt=\"\"&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/page2_main_1.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page2_main_2.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page2_main_3.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page2_main_4.png\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--文字介绍--&gt; &lt;div class=\"text\"&gt; &lt;img src=\"images/page2_title.png\" alt=\"\"&gt; &lt;br&gt; &lt;p&gt;支持Chromium V40 稳定版 &lt;br&gt; Mac平台独家支持网址云安全检测&lt;/p&gt; &lt;/div&gt; &lt;/section&gt; css代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182section.p2&#123; perspective:1200px; background: linear-gradient(0deg, #41b93e 0%, #3b9e3c 35%, #274535 75%, #190530 100%);&#125;section.p2 .bg span&#123; width: 2500px; height: 1px; background: greenyellow; position: absolute; top: 50%; transform: rotateY(-183deg);&#125;section.p2 .bg img&#123; position: absolute; left: 50%; top: 50%;&#125;section.p2 .bg img:nth-of-type(1)&#123; width: 684px; height: 395px; margin-left:188px; margin-top: -197px;&#125;section.p2 .bg img:nth-of-type(2)&#123; width: 346px; height: 123px; margin-left:260px; margin-top: -62px;&#125;section.p2 ul&#123; width: 600px; height: 600px; position: absolute; left: 50%; top: 50%; margin-left: -300px; margin-top: -300px;&#125;section.p2 ul&gt;li&#123; width: 350px; height: 350px; position: absolute; left: 50%; top: 50%; margin-top: -175px; margin-left: -175px;&#125;section.p2 ul&gt;li:nth-of-type(1)&#123; animation: p2Move 0.5s infinite linear; left: 90%;&#125;section.p2 ul&gt;li:nth-of-type(2)&#123; animation: p2Move 1s infinite linear; left: 75%;&#125;section.p2 ul&gt;li:nth-of-type(3)&#123; animation: p2Move 1.5s infinite linear; left: 60%;&#125;section.p2 ul&gt;li:nth-of-type(4)&#123; animation: p2Move 2s infinite linear; left: 45%;&#125;@keyframes p2Move &#123; 0%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); &#125;100%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(360deg) scaleX(1) scaleY(1) scaleZ(1); &#125;&#125;.p2 .text&#123; width: 500px; height: 500px; position: absolute; top: 45%; left: 28%;&#125;.p2 .text p&#123; font-size: 20px; color: white;&#125; 第三页HTML代码1234567891011121314151617&lt;!--第三个屏幕--&gt; &lt;section class=\"p3 current\" style=\"display: none\"&gt; &lt;div class=\"p3-bg\"&gt; &lt;img src=\"images/page3_glow.png\" alt=\"\"&gt; &lt;img src=\"images/page3_logo.png\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"p3-title\"&gt; &lt;img src=\"images/page3_title.png\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"p3content\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/page1_3_round.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page1_3_round.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page1_3_round.png\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/section&gt; css代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/***********************第三页*******************/section.p3&#123; perspective:1200px; background: linear-gradient(0deg, #395ecb 0%, #3657be 35%, #242161 75%, #1a0531 100%);&#125;.p3 .p3-bg img&#123; position: absolute; left: 50%; top: 50%;&#125;.p3-bg img:nth-of-type(1)&#123; width: 1368px; height: 1111px; margin-left: -684px; margin-top: -555px;&#125;.p3-bg img:nth-of-type(2)&#123; width: 131px; height: 130px; margin-left: -65px; margin-top: -65px;&#125;.p3 .p3-title&#123; width: 450px; height: 149px; position: absolute; left: 50%; top: 50%; margin-left: 165px; margin-top: -175px; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(-45deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); transition: all 1s linear;&#125;.p3.current .p3-title&#123; transform: translateX(1000px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p3content ul&#123; width: 680px; height: 680px; position: absolute; left: 50%; top: 50%; margin-left: -340px; margin-top: -340px; transform-style:preserve-3d; animation: oUlMove 10s infinite alternate;&#125;.p3 .p3content&#123; width: 680px; height: 680px; position: absolute; left: 50%; top: 50%; margin-left: -340px; margin-top: -340px; transition: all 1s linear;&#125;.p3.current .p3content&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(5) scaleY(5) scaleZ(5);&#125;@keyframes oUlMove &#123; 0%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); &#125; 100%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(75deg) rotateY(180deg) rotateZ(360deg) scaleX(1) scaleY(1) scaleZ(1); &#125;&#125;.p3content ul li&#123; width: 680px; height: 680px; border: 1px solid skyblue; border-radius: 50%; position: absolute; transform-style:preserve-3d;&#125;.p3content ul li:nth-of-type(1)&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(-60deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p3content ul li:nth-of-type(2)&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p3content ul li:nth-of-type(3)&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(60deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p3content ul li img:nth-of-type(1)&#123; animation: imgMove 1s infinite linear;&#125;.p3content ul li img:nth-of-type(1)&#123; animation: imgMove 2s infinite linear;&#125;.p3content ul li img:nth-of-type(1)&#123; animation: imgMove 3s infinite linear;&#125;@keyframes imgMove &#123; 0%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); &#125; 100%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(360deg) scaleX(1) scaleY(1) scaleZ(1); &#125;&#125; 第四页HTML代码123456789101112131415161718192021222324252627282930&lt;!--第四个屏幕--&gt; &lt;section class=\"p4 current\" style=\"display: none\"&gt; &lt;div class=\"p4-line\"&gt; &lt;img src=\"images/page4_lineglow.png\" alt=\"\"&gt; &lt;img src=\"images/page4_lineglow.png\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"p4content\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/page4_main_clock.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page4_main_clockout.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page4_main_sheild.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page4_main_storm.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page4_main_xf.png\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"p4-title1\" &gt; &lt;img src=\"images/page4_tag.png\" alt=\"\"&gt; &lt;p&gt; BT/eMule/旋风文件一站式下载 &lt;/p&gt; &lt;/div&gt; &lt;div class=\"p4-title2\"&gt; &lt;img src=\"images/page4_title.png\" alt=\"\"&gt; &lt;/div&gt; &lt;/section&gt; css代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/***********************第四页内容**************************/section.p4&#123; background: url(../images/page4_glow.png) no-repeat center 200px, linear-gradient(0deg, #ff9f42 0%, #ed923d 35%, #6d3816 75%, #2e0b04 100%);&#125;.p4 .p4content,.p4 .p4content ul&#123; width: 414px; height: 414px; position: absolute; left: 50%; top: 50%; margin-left: -207px; margin-top: -207px; transform-style: preserve-3d; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(70deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p4 .p4content ul li&#123; width: 414px; height: 414px; position: absolute; left: 50%; top: 50%; margin-left: -207px; margin-top: -207px;&#125;.p4 .p4content ul li:nth-child(1)&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p4 .p4content ul li:nth-child(2)&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p4 .p4content ul li:nth-child(3)&#123; transform: translateX(0px) translateY(0px) translateZ(-100px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p4 .p4content ul li:nth-child(4)&#123; transform: translateX(0px) translateY(0px) translateZ(-100px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1.1) scaleY(1.1) scaleZ(1.1);&#125;.p4 .p4content ul li:nth-child(5)&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1.2) scaleY(1.2) scaleZ(1.2);&#125;.p4 .p4content ul li:nth-child(1) img&#123; animation:p4LiMove 60s infinite linear ;&#125;.p4 .p4content ul li:nth-child(2) img&#123; animation:p4LiMove 20s infinite linear ;&#125;.p4 .p4content ul li:nth-child(3) img&#123; animation:p4LiMove 10s infinite linear ;&#125;.p4 .p4content ul li:nth-child(4) img&#123; animation:p4LiMove 5s infinite linear ;&#125;.p4 .p4content ul li:nth-child(5) img&#123; animation:p4LiMove 3s infinite linear ;&#125;@keyframes p4LiMove &#123; 0%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); &#125; 100%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(360deg) scaleX(1) scaleY(1) scaleZ(1); &#125;&#125;.p4-line&#123; width: 100%; height: 200px; position:absolute; left: 0; top: 60%; border-bottom: 1px solid white; border-top: 1px solid white;&#125;.p4-line&gt;img:nth-of-type(1)&#123; position:absolute; left: 0; top: -63px;&#125;.p4-line&gt;img:nth-of-type(2)&#123; position:absolute; left: 0; bottom: -61px;&#125;.p4-line&gt;img:nth-of-type(1)&#123; animation: p4ImgMove 1s infinite linear;&#125;.p4-line&gt;img:nth-of-type(2)&#123; animation: p4ImgMove 1.5s infinite linear;&#125;@keyframes p4ImgMove &#123; 0%&#123; transform: translateX(-2000px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); &#125; 100%&#123; transform: translateX(2000px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); &#125;&#125;.p4-title1&#123; position: absolute; left: 50%; top: 50%; width: 250px; height: 29px; margin-left: -430px; margin-top: -38px;&#125;.p4-title1 p&#123; color: white; font-size: 16px; font-weight: bold;&#125;.p4-title2&#123; position: absolute; left: 50%; top: 50%; width: 300px; height: 71px; margin-left: 132px; margin-top: -94px; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(30deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p4.current .p4content&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(30deg) rotateY(0deg) rotateZ(0deg) scaleX(5) scaleY(5) scaleZ(5);&#125;.p4.current .p4-title2&#123; transform: translateX(-2000px) translateY(0px) translateZ(0px) rotateX(30deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p4.current .p4-title1&#123; transform: translateX(2000px) translateY(0px) translateZ(0px) rotateX(30deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p4content,.p4-title2,.p4-title1&#123; transition: all 1s linear;&#125; 第五页HTML代码1234567891011121314151617181920212223&lt;!--第五个屏幕--&gt; &lt;section class=\"p5 current\" style=\"display: none\"&gt; &lt;div class=\"p5content\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/page5_icon_1.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page5_icon_2.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page5_icon_3.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page5_icon_4.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page5_icon_5.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/page5_icon_6.png\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"p5-title1\"&gt; &lt;img src=\"images/page5_title.png\" alt=\"\"&gt; &lt;/div&gt; &lt;div class=\"p5-text\"&gt; &lt;p&gt; 双击关闭、超级拖拽、广告过滤 恢复按钮、网银插件、截图&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/section&gt; css代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/*********************第五页内容***************************/section.p5&#123; background: url(../images/page5_glow.png) no-repeat center -300px,linear-gradient(0deg, #d74d53 0%, #c44655 35%, #4c184c 75%, #110145 100%);&#125;.p5content ul&#123; width: 700px; height: 500px; position: absolute; left: 50%; top: 50%; margin-left: -350px; margin-top: -250px;&#125;.p5content ul li&#123; width: 305px; height: 305px; position: absolute; background: url(\"../images/page5_bubble.png\") no-repeat; display: flex; justify-content: center; align-items: center; transition: all 0.7s linear;&#125;.p5content ul li&gt;img&#123; animation: p5Imgmove 5s infinite linear;&#125;@keyframes p5Imgmove &#123; 0%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1); &#125; 100%&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(360deg) scaleX(1) scaleY(1) scaleZ(1); &#125;&#125;.p5content ul li:nth-child(1)&#123; left: 150px; top: 100px; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p5content ul li:nth-child(2)&#123; left: 401px; top: -100px; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.8) scaleY(0.8) scaleZ(0.8);&#125;.p5content ul li:nth-child(3)&#123; left: 301px; top: 300px; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.8) scaleY(0.8) scaleZ(0.8);&#125;.p5content ul li:nth-child(4)&#123; left: 1px; top: -41px; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.7) scaleY(0.7) scaleZ(0.7); &#125;.p5content ul li:nth-child(5)&#123; left: -99px; top: 300px; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.6) scaleY(0.6) scaleZ(0.6); &#125;.p5content ul li:nth-child(6)&#123; left: 502px; top: 150px; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.8) scaleY(0.8) scaleZ(0.8);&#125;.p5.current .p5content ul li:nth-child(1)&#123; transform: translateX(0px) translateY(-1000px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p5.current .p5content ul li:nth-child(2)&#123; transform: translateX(1000px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.7) scaleY(0.7) scaleZ(0.7);&#125;.p5.current .p5content ul li:nth-child(3)&#123; transform: translateX(1500px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.5) scaleY(0.5) scaleZ(0.5);&#125;.p5.current .p5content ul li:nth-child(4)&#123; transform: translateX(-1000px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.6) scaleY(0.6) scaleZ(0.6);&#125;.p5.current .p5content ul li:nth-child(5)&#123; transform: translateX(-1500px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.4) scaleY(0.4) scaleZ(0.4);&#125;.p5.current .p5content ul li:nth-child(6)&#123; transform: translateX(2000px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg) scaleX(0.8) scaleY(0.8) scaleZ(0.8);&#125;.p5-title1&#123; width: 410px; height: 121px; position: absolute; left: 50%; top: 50%; margin-left: -672px; margin-top: -29px; transition: all 0.7s linear;&#125;.p5.current .p5-title1,.p5.current .p5-text&#123; transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(90deg) rotateZ(0deg) scaleX(1) scaleY(1) scaleZ(1);&#125;.p5-text &#123; position: absolute; left: 50%; top: 50%; color: white; font-size: 18px; font-weight: bold; margin-left: 330px; margin-top: -150px; transition: all 0.7s linear;&#125; 其他位置HTML代码12345678910111213141516171819202122232425262728&lt;!--左上角logo--&gt; &lt;div class=\"logo\"&gt; &lt;img src=\"images/logo_small.png\" alt=\"\"&gt; &lt;a href=\"javascript:;\"&gt;立即下载&lt;/a&gt; &lt;/div&gt; &lt;!--小圆点--&gt; &lt;ul class=\"round\"&gt; &lt;li class=\"active\"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;!--底部--&gt; &lt;footer class=\"footer\"&gt; &lt;span&gt;&amp;copy; Tencent&lt;/span&gt; &lt;ul class=\"list\"&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;2.0版官网&lt;span&gt;|&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;历史版本下载&lt;span&gt;|&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;PC 版&lt;span&gt;|&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;论坛&lt;span&gt;|&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;微博&lt;span&gt;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/footer&gt; &lt;!--滚动指示器--&gt; &lt;div class=\"scroll\"&gt; &lt;img src=\"images/scroll.png\" alt=\"\"&gt; &lt;/div&gt; css代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122/**************小logo****************/.logo&#123; width: 300px; height: 200px; position: fixed; left: 0; top: 0; display: flex; align-items: center; justify-content: space-around;&#125;.logo img&#123; margin-top: -15px; margin-left: 30px; width: 104px; height: 21px;&#125;.logo a&#123; margin-top: -15px; margin-left: 30px; text-decoration: none; color: white; padding:10px 15px; border-radius: 24px; border: 1px solid #666;&#125;/****************大logo*******************/.bigLogo&#123; width: 1000px; height: 300px; position: absolute; left: 50%; margin-left: -500px; top: -50px; display: flex; align-items: center; justify-content: space-around; &#125;.bigLogo a&#123; margin-top: 10px; margin-left: -200px; text-decoration: none; color: white; padding:15px 25px; border-radius: 24px; border: 1px solid #666;&#125;.bigLogo img&#123; width: 50%;&#125;/*****************右边小圆点******************/.round&#123; width: 100px; height: 150px; position: fixed; right: 0; top: 50%; transform: translateY(-50%); display: flex; flex-direction: column; justify-content: space-between; align-items: center;&#125;.round li&#123; cursor: pointer; width: 20px; height: 20px; background-color:rgba(255,255,255,0.3); border-radius: 50%;&#125;.round li.active&#123; background-color:rgba(255,255,255,1);&#125;/**************底部*****************/.footer&#123; width: 100%; height: 60px; position: fixed; left: 0; bottom: 0; display: flex; justify-content: space-between; align-items: center;&#125;.footer,.footer li a&#123; font-size: 18px; color: white; font-weight: bold; text-decoration: none;&#125;.footer .list&#123; display: flex;&#125;.footer&gt;span&#123; margin-left: 20px;&#125;.footer li a&#123; margin-right: 30px;&#125;.footer li a span&#123; margin-left: 26px;&#125;/**************滚动指示器**************/.scroll&#123; width: 29px; height: 31px; position: fixed; left: 50%; margin-left: -15px; bottom: 20px; animation: upAndDown 1s infinite alternate;&#125;@keyframes upAndDown &#123; 0%&#123; transform: translateY(10px); &#125; 100%&#123; transform: translateY(0px); &#125;&#125; js代码主要实现了滚轮事件,点击事件,而某些元素根据第几页显示和隐藏,添加删除架空类,需要注意的是,滚轮事件要节流,而且添加类删除类执行动画的时候需要加定时器,避免动画效果失效1234567891011121314151617181920212223242526272829303132333435363738394041424344454647$(function () &#123; var $index = 0, timer = null; $('section').eq($index).removeClass('current'); showAndHide($index); // 监听屏幕滚动,使用jquery插件的mousewheel $(window).mousewheel(function (event, delta) &#123; //节流 clearTimeout(timer); timer = setTimeout(function () &#123; $index -= delta; if ($index &gt; $('.round li').length) &#123; $index = $('.round li').length; &#125; else if ($index &lt; 0) &#123; $index = 0; &#125; $('.round li').eq($index).addClass('active').siblings().removeClass('active'); $('section').eq($index).stop().show().siblings('section').stop().hide(); setTimeout(function () &#123; $('section').eq($index).removeClass('current').siblings('section').addClass('current'); showAndHide($index); &#125;,50) &#125;, 300) &#125;); //小圆点点击 $('.round li').click(function () &#123; $index = $(this).index(); $(this).addClass('active').siblings().removeClass('active'); $('section').eq($index).stop().show().siblings('section').stop().hide(); setTimeout(function () &#123; $('section').eq($index).removeClass('current').siblings('section').addClass('current'); showAndHide($index); &#125;,10) showAndHide($index); &#125;); //具体元素的隐藏和显示 function showAndHide(index) &#123; if (index == 0) &#123; $('.logo').hide(); $('.scroll').show(); $('.bigLogo').show(); &#125; else &#123; $('.logo').show(); $('.scroll').hide(); $('.bigLogo').hide(); &#125; &#125;&#125;); 效果","tags":[{"name":"css3","slug":"css3","permalink":"//carrot.me/tags/css3/"}]},{"title":"jquery插件的制作方法","date":"2016-06-06T06:36:00.000Z","path":"2016/06/06/jquery-插件制作/","text":"jquery插件的制作方法 jQuery插件开发模式12通过$.extend()来扩展jQuery通过$.fn 向jQuery添加新的方法 $.extend()方法123456789$.extend(&#123; sayHello: function(name) &#123; console.log('Hello,' + (name ? name : 'Dude') + '!'); &#125;&#125;)$.sayHello(); //调用$.sayHello('Wayou'); //带参调用缺点无法利用jQuery强大的选择器带来的便利，要处理DOM元素以及将插件更好地运用于所选择的元素身上 $.fn向jQuery添加新的方法1234$.fn.myPlugin = function() &#123; //在这里面,this指的是用jQuery选中的元素 this.css('color', 'red');&#125; 链式调用12345678$.fn.myPlugin = function() &#123; //在这里面,this指的是用jQuery选中的元素 this.css('color', 'red'); return this.each(function() &#123; //对每个元素进行操作 $(this).append(' ' + $(this).attr('href')); &#125;))&#125; 插件传参123456789101112131415161718192021222324252627282930313233在处理插件参数的接收上，通常使用jQuery的extend方法,给extend方法传递单个对象的情况下，这个对象会合并到jQuery身上，所以我们就可以在jQuery身上调用新合并对象里包含的方法了，像上面的例子。当给extend方法传递一个以上的参数时，它会将所有参数对象合并到第一个里。同时，如果对象中有同名属性时，合并的时候后面的会覆盖前面的。$.fn.myPlugin = function(options) &#123; var defaults = &#123; 'color': 'red', 'fontSize': '12px' &#125;; var settings = $.extend(defaults, options); return this.css(&#123; 'color': settings.color, 'fontSize': settings.fontSize &#125;);&#125;//传参数会覆盖$('a').myPlugin(&#123; 'color': '#2C9929'&#125;);缺点,会覆盖默认的值.将一个新的空对象做为$.extend的第一个参数，defaults和用户传递的参数对象紧随其后，这样做的好处是所有值被合并到这个空对象上，保护了插件里面的默认值。第一个参数传入一个空的&#123;&#125;$.fn.myPlugin = function(options) &#123; var defaults = &#123; 'color': 'red', 'fontSize': '12px' &#125;; var settings = $.extend(&#123;&#125;,defaults, options);//将一个空对象做为第一个参数 return this.css(&#123; 'color': settings.color, 'fontSize': settings.fontSize &#125;);&#125; 面向对象开发1234567891011121314151617181920212223242526272829303132将需要的重要变量定义到对象的属性上，函数变成对象的方法，当我们需要的时候通过对象来获取，一来方便管理，二来不会影响外部命名空间，//定义Beautifier的构造函数var Beautifier = function(ele, opt) &#123; this.$element = ele, this.defaults = &#123; 'color': 'red', 'fontSize': '12px', 'textDecoration':'none' &#125;, this.options = $.extend(&#123;&#125;, this.defaults, opt)&#125;//定义Beautifier的方法Beautifier.prototype = &#123; beautify: function() &#123; return this.$element.css(&#123; 'color': this.options.color, 'fontSize': this.options.fontSize, 'textDecoration': this.options.textDecoration &#125;); &#125;&#125;//在插件中使用Beautifier对象$.fn.myPlugin = function(options) &#123; //创建Beautifier的实体 var beautifier = new Beautifier(this, options); //调用其方法 return beautifier.beautify();&#125;好处:代码变得更面向对象了，也更好维护和理解，以后要加新功能新方法，只需向对象添加新变量及方法即可，然后在插件里实例化后即可调用新添加的东西。插件的调用还是一样的，我们对代码的改动并不影响插件其他地方，只是将代码的组织结构改动了而已。 命名空间保护12345678910111213141516171819202122232425262728293031在写任何JS代码时都应该注意的一点是不要污染全局命名空间。因为随着你代码的增多，如果有意无意在全局范围内定义一些变量的话，最后很难维护，也容易跟别人写的代码有冲突。将系统变量以变量形式传递到插件内部,可以提高访问速度，会有些许性能的提升,得到一个非常安全结构良好的代码;(function($, window, document,undefined) &#123; //定义Beautifier的构造函数 var Beautifier = function(ele, opt) &#123; this.$element = ele, this.defaults = &#123; 'color': 'red', 'fontSize': '12px', 'textDecoration': 'none' &#125;, this.options = $.extend(&#123;&#125;, this.defaults, opt) &#125; //定义Beautifier的方法 Beautifier.prototype = &#123; beautify: function() &#123; return this.$element.css(&#123; 'color': this.options.color, 'fontSize': this.options.fontSize, 'textDecoration': this.options.textDecoration &#125;); &#125; &#125; //在插件中使用Beautifier对象 $.fn.myPlugin = function(options) &#123; //创建Beautifier的实体 var beautifier = new Beautifier(this, options); //调用其方法 return beautifier.beautify(); &#125;&#125;)(jQuery, window, document);","tags":[{"name":"jquery","slug":"jquery","permalink":"//carrot.me/tags/jquery/"}]},{"title":"git的学习之旅","date":"2016-06-02T09:33:00.000Z","path":"2016/06/02/git学习之旅/","text":"管理代码的工具 介绍git是基于linux的操作命令工具,主要作用是方便我们托管我们的代码,因为基于linux系统,所以必要的linux命令要懂,而且还要了解加密过程,管理模式等等. 使用方法下载git 官网:https://git-scm.com/ 配置环境变量,打开bash即可! bash的基础语法git命令:http://yanhaijing.com/git/2014/11/01/my-git-note/廖雪峰学习地址:http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b0001234567891011121314151617181920212223常见命令格式：命令 [-options] [参数]pwd (Print Working Directory) 查看当前目录cd (Change Directory) 切换目录，如 cd /etcls (List) 查看当前目录下内容，如 ls -almkdir (Make Directory) 创建目录，如 mkdir blogtouch 创建文件，如 touch index.htmlwc (Word Count) 字数信息统计，如 wc index.htmlcat 查看文件全部内容，如 cat index.htmlmore less 查看文件，如more /etc/passwd、less /etc/passwdrm (remove) 删除文件，如 rm index.html、rm -rf blogrmdir (Remove Directory) 删除文件夹，只能删除空文件夹，不常用mv (move) 移动文件或重命名，如 mv index.html ./demo/index.htmlcp (copy) 复制文件，cp index.html ./demo/index.htmlhead 查看文件前几行，如 head -5 index.htmltail 查看文件后几行 –n –f，如 tail index.html、tail -5 index.html tab 自动补全，连按两次会将所有匹配内容显示出来history 查看操作历史ssh 远程登录，如ssh root@gitlab.study.com&gt; 和 &gt;&gt;重定向，如echo hello world! &gt; README.md，&gt;覆盖 &gt;&gt;追加把原来输入的内容，自己指定到别的地方。把原本输出到屏幕上的内容，写入到指定的文件当中。如果文件不存在，会自动帮你创建文件。wget 下载，如wget https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gztar 解压缩，如tar zxvf node-v4.4.0.tar.gz vi编辑器1234三种模式(默认命令行模式)1.命令行模式(Esc)2.输入模式(输入i或者a,下面显示INSERT)3.末行模式(shift+: 下面显示: ) 命令行语法123456789101112ZZ（大写）保存并退出u辙销操作，可多次使用dd删除当前行yy复制当前行p 粘贴内容ctrl+f向前翻页ctrl+b向后翻页i进入输入模式，当前光标处插入a进入输入模式，当前光标后插入A进入输入模式，光标移动到行尾o进入输入模式，当前行下面插入新行O进入输入模式，当前行上面插入新行 输入模式1输入你想要的内容即可 末行模式1234567w保存，w filenme另存为q退出wq保存并退出e! 撤销更改，返回到上一次保存的状态q! 不保存强制退出set nu 设置行号 SSH介绍SSH是一种网络协议，用于计算机之间的加密登录 对称加密原理123本地和服务器共有一个私钥,往服务器发送密钥根据私钥(同一个私钥)进行解密.(私钥和密钥可能被拦截,存在安全问题) 非对称加密原理12345命令:ssh-keygen-t rsa(生成本地的私钥和公钥)只生成秘钥的电脑公钥才能解开对应的私钥①通过ssh root@服务器地址 链接服务器②服务器的公钥发送到本地地址③把输入的密码和服务器的公钥一起加密传给服务器,然后由服务器的私钥进行解密. 免密码登录原理123免密码登录(已经登录过一次)①把本地的公钥放到服务器②服务器的公钥和本地的私钥一起发送到服务器,服务器根据自己的私钥和之前放到服务器上本地公钥进行匹配. 版本控制确保由不同人所编辑的同一档案都得到更新。 集中式管理12345①必须依赖服务器②所有文件都上传到该服务器上③本地电脑只有最新文件,没有旧版本的文件④开发者相互之间不能共享文件,只能通过服务器访问文件缺点:一旦服务器挂了,文件就不能访问了 分布式管理1234分布式管理①不依赖服务器,也可以往服务器上传文件②每一台电脑都存在版本记录(历史记录),服务器也可以!③开发者互相共享代码,也可以往服务器传输和拿文件 git工作原理三种状态12341.已提交（committed）2.已修改（modified）3.已暂存（staged）红色:已修改,绿色:已暂存,没有任何消息&gt;已提交 三个工作区域1231.Git的工作目录(仓库之外的文件或文件夹)2.暂存区域(是个简单的文件，一般都放在Git目录中。会把这个文件叫做索引文件 .index)3.以及本地仓库(是Git用来保存元数据和对象数据库的地方) 工作流程1231、在工作目录中修改文件。2、暂存文件，将文件的快照放入暂存区域。3、提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录。 原理图1234Workspace：工作区(工作目录)Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 git命令新建本地仓库12345678在当前目录新建一个Git代码库$ git init新建一个目录，将其初始化为Git代码库$ git init [project-name]下载一个项目和它的整个代码历史$ git clone [url] 共享仓库123456789101112131415创建以.git结尾目录mkdir repo.git 初始化一个共享仓库git init --bare将已有一个仓库导出成裸仓库git clone --bare [仓库地址] 向共享仓库共享内容git push [仓库地址] 从共享仓库里取出内容git clone ./repo.git demogit pull ../repo.git master 配置123456789101112131415161718显示当前的Git配置$ git config --list编辑Git配置文件$ git config -e --global设置提交代码时的用户信息$ git config --global user.name \"[name]\"$ git config --global user.email \"[email address]\"获取帮助信息git help config 配置自动换行,提交到git是自动将换行符转换为lfgit config --global core.autocrlf input生成密钥ssh-keygen -t rsa 增加/删除文件123456789101112131415161718192021添加指定文件到暂存区$ git add [file1] [file2] ...添加指定目录到暂存区，包括子目录$ git add [dir]添加当前目录的所有文件到暂存区$ git add .添加每个变化前，都会要求确认对于同一个文件的多处变化，可以实现分次提交$ git add -p删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 代码提交123456789101112131415161718提交暂存区到仓库区$ git commit -m [message]提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a提交时显示所有diff信息$ git commit -v使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142列出所有本地分支$ git branch列出所有远程分支$ git branch -r列出所有本地分支和远程分支$ git branch -a新建一个分支，但依然停留在当前分支$ git branch [branch-name]新建一个分支，并切换到该分支$ git checkout -b [branch]新建一个分支，指向指定commit$ git branch [branch] [commit]新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]切换到指定分支，并更新工作区$ git checkout [branch-name]切换到上一个分支$ git checkout -建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]合并指定分支到当前分支$ git merge [branch]选择一个commit，合并进当前分支$ git cherry-pick [commit]删除分支$ git branch -d [branch-name]删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526列出所有tag$ git tag新建一个tag在当前commit$ git tag [tag]新建一个tag在指定commit$ git tag [tag] [commit]删除本地tag$ git tag -d [tag]删除远程tag$ git push origin :refs/tags/[tagName]查看tag信息$ git show [tag]提交指定tag$ git push [remote] [tag]提交所有tag$ git push [remote] --tags新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 查看123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960显示有变更的文件$ git status显示当前分支的版本历史$ git log显示commit历史，以及每次commit发生变更的文件$ git log --stat搜索提交历史，根据关键词$ git log -S [keyword]显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件$ git log [tag] HEAD --grep feature显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]显示指定文件相关的每一次diff$ git log -p [file]显示过去5次提交$ git log -5 --pretty --oneline显示所有提交过的用户，按提交次数排序$ git shortlog -sn显示指定文件是什么人在什么时间修改过$ git blame [file]显示暂存区和工作区的差异$ git diff显示暂存区和上一个commit的差异$ git diff --cached [file]显示工作区与当前分支最新commit之间的差异$ git diff HEAD显示两次提交之间的差异$ git diff [first-branch]...[second-branch]显示今天你写了多少行代码$ git diff --shortstat \"@&#123;0 day ago&#125;\"显示某次提交的元数据和内容变化$ git show [commit]显示某次提交发生变化的文件$ git show --name-only [commit]显示某次提交时，某个文件的内容$ git show [commit]:[filename]显示当前分支的最近几次提交$ git reflog 远程同步1234567891011121314151617181920212223下载远程仓库的所有变动$ git fetch [remote]显示所有远程仓库$ git remote -v显示某个远程仓库的信息$ git remote show [remote]增加一个新的远程仓库，并命名$ git remote add [shortname] [url]取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]上传本地指定分支到远程仓库$ git push [remote] [branch]强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force推送所有分支到远程仓库$ git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031恢复暂存区的指定文件到工作区$ git checkout [file]恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]恢复暂存区的所有文件到工作区$ git checkout .重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]重置暂存区与工作区，与上一次commit保持一致$ git reset --hard重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]新建一个commit，用来撤销指定commit后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 工作流程常用命令123456789101112131415161718192021git init 创建本地仓库git diff 查看文件是否修改了git add 提交到暂存区git commit -m\"信息\" 提交到仓库git status 查看文件状态git log 查看显示从最近到最远的提交日志git log --pretty=oneline 单行显示git reset --hard [版本号] 退回到某个版本git reflog 列出版本号git checkout -- [文本名] 撤销到之前的文件状态git rm [文件名] 从暂存区删除文件git clone [远程仓库地址] 克隆远程仓库到本地git push -u origin [分支名称] 把本地仓库内容推送到远程仓库git checkout -b feature1 创建分支并进入git checkout [分支名称] 切换分支git merge [分支名称] 合并分支git branch -d [分支名称] 删除分支名称git branch 查看分支git branch [分支名称] 创建分支ssh-keygen -t rsa 配置本地的公钥和私钥git pull origin [分支名称] 从远处仓库推送到本地仓库 分支图解12每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： 1每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长,当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： 12Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变, 1假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并 123所以Git合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支 解决冲突12345678910111213两个人同时修改了同一个文件的同一部分代码。并且，两人都在本地做了提交。如果一个用户，早一此提前到共享仓库当中。另外一个用户，提交代码代码时，要求先去更新一下代码 git pull在pull过程当中会产生冲突。 哪个文件冲突，会有提示。手动找到冲突的文件。手动打开该文件,打开时，会看到如下代码：&lt;&lt;&lt;&lt;&lt; HEAD是自己写的代码======别人写的代码&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;0f68f3c80b954手动把&lt;&lt;&lt;&lt;&lt; ==== HEAD 删除掉。保留自己想要的代码之后，需要再提交到本地然后，再去push到共享仓库当中。 BUG分支12345678需要我们创建分支,然后回到上一个版本去解决BUG,在切回主分支合并分支即可,删除分支,继续做主分支原有的工作.例如git checkout -b [分支名称] 创建分支并进入git reset --hard [上一个版本号] 回到上一个版本解决BUGgit checkout master 切回主分支git merge [分支名称] 合并分支git branch -d 分支名称 删除分支","tags":[{"name":"git","slug":"git","permalink":"//carrot.me/tags/git/"}]},{"title":"zepto学习之旅","date":"2016-05-08T05:44:00.000Z","path":"2016/05/08/zepto学习之旅/","text":"只要你会jquery你也会zepto的框架 介绍zepto的用法基本和jquery差不多,不过zepto是把jquery分开,你具体需要用哪一个库,你就导入.大大压缩了空间,而且zepto是抛弃了低版本的浏览器,也就是不兼容,而且zepto的动画是基于css3的,比如像背景颜色,边框.官网:http://www.css88.com//doc//zeptojs_api// 使用方法基本和jquery相同,本身只是自带了核心的几个库,假如我们想要其他功能,需要另外引入js文件12345678910引入对应的库 &lt;script src=\"js/zepto.min.js\"&gt;&lt;/script&gt;执行&lt;script&gt; $(function () &#123; $('button').click(function () &#123; $('.box').css('background-color', 'red'); &#125;); &#125;); &lt;/script&gt; 模块zepto为了保持足够的轻量和效率,只保留了默认的最基本的功能,其他的功能,如果有需要,只要再次引入就可以了,比如我想用到jquery中的eq选择器,则需要另外引入selector库,否则会报错.123456789 &lt;script src=\"js/zepto.min.js\"&gt;&lt;/script&gt; &lt;script src=\"js/selector.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function () &#123; $('button').click(function (event) &#123; $('div:eq(1)').css('background-color', 'blue'); &#125;); &#125;); &lt;/script&gt; 模块总览 简单应用移动端touch主要用到了zepto中的移动端库,就是touch库,这个可以很方便我们在移动实现各种事件,比如tap事件,帮我们封装了,还有滑动事件,包括了上下左右4个时间.大大方便了我们使用. 效果","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"swiper学习之旅","date":"2016-05-05T07:44:00.000Z","path":"2016/05/05/swiper学习之旅/","text":"一个移动端设备触控滑块的库 介绍swiper是一款免费以及轻量级的移动设备触控滑块的js框架，主要是为iOS设计,同时,在Android、WP系统和其他PC浏览器上也有着良好的体验.定制性高,提供多种版本支持官网:http://www.swiper.com.cn/ 使用方法引入对应css和js库,然后HTML结构是固定,如下面显示,最后需要在js中初始化一下,该库提供很多方法,我们需要在html和js分别写上对应的属性,比如需要分页器,需要在html设置对应的类,然后在js也要设置一样的属性值12345678910111213引入对应的库&lt;link rel=\"stylesheet\" href=“css/swiper.min.css\"&gt; &lt;script src=“js/swiper.min.js\"&gt;&lt;/script&gt;HTML结构&lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;Slide 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 2&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 3&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;初始化var swiper = new Swiper('.swiper-container'); 常用参数123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;!-- 如果需要分页器 --&gt;js和HTML要一致 &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; pagination: '.swiper-pagination' 总览&lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt;Slide 1&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 2&lt;/div&gt; &lt;div class=\"swiper-slide\"&gt;Slide 3&lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;!-- 如果需要滚动条 --&gt; &lt;div class=\"swiper-scrollbar\"&gt;&lt;/div&gt;&lt;/div&gt;var mySwiper = new Swiper ('.swiper-container', &#123; // 如果需要分页器 pagination: '.swiper-pagination', // 如果需要前进后退按钮 nextButton: '.swiper-button-next', prevButton: '.swiper-button-prev', // 如果需要滚动条 scrollbar: '.swiper-scrollbar',loop: true, //循环开关autoplay: 3000, //自动播放间隔时间（单位：毫秒）默认不自动播放direction: 'vertical',//切换方向 水平或垂直(vertical)speed:300, //切换速度（单位：毫秒）keyboardControl:true, //键盘控制开关paginationType:‘bullets’, //分页器外观 bullets 、 fraction 、 progresseffect: 'fade', //切换效果 fade、cube、coverflow、flip&#125;) swiper animate多引入2个文件 在需要运动的元素上面增加类名ani,然后设置对应的属性值 swiper-animate-effect：切换效果，例如 fadeInUp,可以参考Animated里面的动画效果. swiper-animate-duration：动画持续时间（单位秒），例如 0.5s swiper-animate-delay: 延迟时间（单位秒） 在js中,根据需要调用不同的方法,不过常用如下几个方法123456789101112131415161718192021222324252627&lt;link rel=\"stylesheet\" href=“css/animate.min.css\"&gt;&lt;script src=“js/swiper.animate.min.js\"&gt;&lt;/script&gt;&lt;div class=\"swiper-container\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\"&gt; &lt;p class=\"ani\" swiper-animate-effect=\"fadeInUp\" swiper-animate-duration=\"0.5s\" swiper-animate-delay=\"0.3s\"&gt; 具体内容 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;js代码var mySwiper = new Swiper ('.swiper-container', &#123; onInit: function(swiper)&#123; //Swiper2.x的初始化是onFirstInit swiperAnimateCache(swiper); //隐藏动画元素 swiperAnimate(swiper); //初始化完成开始动画 &#125;, onSlideChangeEnd: function(swiper)&#123; swiperAnimate(swiper); //每个slide切换结束时也运行当前slide动画 &#125;&#125;) 效果","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"scrollReveal学习之旅","date":"2016-05-01T07:44:00.000Z","path":"2016/05/01/scrollReveal学习之旅/","text":"和wow框架很类似,不过该框架支持来回滚动都支持动画效果 介绍scrollReveal是一个兼容PC端和移动设备的滚动动画库。不同的是 WOW.js的动画只播放一次,而 scrollReveal.js 的动画可以播放一次或无限次,而且不依赖其他框架!github地址:https://github.com/jlmakes/scrollreveal 使用方法只需要引入对应js文件,然后在js中调用以下方法,绑定对应元素的类或者其他选择器即可,我们可以在config中配置对应的参数,而且我们还可以传入一个时间值,假如传入是多个元素,则每一个元素分别隔时间值来执行动画,类似帧动画效果1234567引入对应的库&lt;script src=\"js/scrollReveal.js\"&gt;&lt;/script&gt;初始化window.onload = function () &#123; window.sr = ScrollReveal(); sr.reveal('.box',config,时间值);&#125; 常用参数12345678910111213reset: false, // 滚动鼠标时，动画开关origin: 'bottom', // 动画开始的方向duration: 500, // 动画持续时间delay: 0, // 延迟rotate: &#123;x:0, y:0, z:0&#125;, // 过度到0的初始角度opacity: 0, // 初始透明度scale: 0.9, //缩放easing: 'cubic-bezier(0.6, 0.2, 0.2, 1)', // 缓动'ease', 'ease-in-out'，'linear'...// 回调函数beforeReveal: function(domEl)&#123;&#125;,beforeReset: function(domEl)&#123;&#125;,afterReveal: function(domEl)&#123;&#125;,afterReset: function(domEl)&#123;&#125; 效果帧动画效果 滚动下拉效果","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"WoW学习之旅","date":"2016-04-29T00:44:00.000Z","path":"2016/04/29/WoW学习之旅/","text":"一个基于Animated的框架,可以通过js,或者类名提供更多动画功能 介绍最主要功能是可以通过滚轮往下拉的时候实习动画,而且可以自由定制动画的效果,比过要和Animated配合一起使用,也是有兼容性问题的官网:http://mynameismatthieu.com/WOW/ 使用方法只需要引入对应的css文件,和Animated不同的是,所有动画都是基于一个wow的类,然后在后面添加Animated.css中具体动画的类名即可,然后还需要在js中初始化wow对象.12345678引入对应的库&lt;link rel=\"stylesheet\" href=\"animate.min.css\"&gt;&lt;script src=\"wow.min.js\"&gt;&lt;/script&gt;给需要动画元素添加类&lt;div class=\"wow slideInLeft\"&gt;&lt;/div&gt;&lt;div class=\"wow slideInRight\"&gt;&lt;/div&gt;初始化new WOW().init(); 常用属性data-wow-delay: 动画开始前延迟 data-wow-duration: 动画持续时长 data-wow-iteration: 动画重复次数 data-wow-offset: 距离浏览器底部到隐藏框顶部的距离（偏移量） 使用方法只需要在动画元素的标签内加上对应的属性即可12&lt;div class=\"wow slideInLeft\" data-wow-duration=\"3s\" data-wow-delay=\"1s\"&gt;&lt;/div&gt;&lt;div class=\"wow slideInRight\" data-wow-iteration=\"5\"&gt;&lt;/div&gt; data-wow-offset介绍该功能主要作用:用于决定当前的元素在滚动的时候到达怎样的位置出现其实现原理和瀑布流加载很类似,主要原理就是(屏幕的高度+滚轮下拉的高度)-(当前元素距离顶部的高度),假如我们设置data-wow-offset=60,意思就是当(屏幕的高度+滚轮下拉的高度)-(当前元素距离顶部的高度)这个值大于等于60的时候,就让其显示并出现动画效果,具体js代码如下 123456789101112131415// 2. 监听页面的滚动 var vHeight = 0, vScroll = 0, vOffSet = 0, vDataWowOffset = 0; $(window).on(\"scroll\", function () &#123; //console.log('滚动了!'); // 2.1 求出可视区域的高度 vHeight = $(window).height(); // console.log(vHeight); // 2.2 求出scrollTop vScroll = $(window).scrollTop(); // console.log(vScroll); // 2.3 求出当前元素的offsetTop vOffSet = $('#test').offset().top; // console.log(vOffSet); // 2.4 求出data-wow-offset vDataWowOffset = (vHeight + vScroll) - vOffSet; 常用参数设置可以自定义参数实现不同动画效果123456var wow = new WOW(&#123; boxClass: 'wow', // 动画元素的CSS类（默认类名wow） animateClass:'animated', // 动画CSS类 （默认类名animated） offset: 0, // 距离可视区域多少开始执行动画（默认为0） mobile: true, // 是否在移动设备上执行动画 （默认是true）&#125;); 效果设置了data-wow-offset时候以及滚轮下拉的效果1&lt;div id=\"test\" class=\"wow slideInRight\" data-wow-offset=\"900\"&gt;2&lt;/div&gt;","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"Animate.css学习之旅","date":"2016-04-25T03:44:00.000Z","path":"2016/04/25/AnimationCss/","text":"一个基于CSS3写的框架,实现了css3各种炫酷特效 介绍Animate.css是一个动画库,它集合了总共有70多种动画效果,而且使用方便,只需要在对应元素添加类即可.不过整个库都是基于CSS3来实现,所以在兼容性方面就差一点,需要浏览器支持CSS3的效果,其他浏览器不行!官网:http://daneden.github.io/animate.css/ 使用方法只需要引入对应的css文件,在需要动画的元素身上添加类名即可,不过所有动画都是基于一个叫animated,主要作用是控制动画的时间.具体添加什么方法可以到官网查询你想要的效果!1234引入对应的库&lt;link rel=\"stylesheet\" href=\"css/animate.css\"&gt;给需要动画元素添加类&lt;div class=\"animated slideInDown\"&gt;&lt;/div&gt; 效果","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"网页布局之布局技巧","date":"2016-04-20T09:36:00.000Z","path":"2016/04/20/webLayout-布局技巧/","text":"css布局技巧一个常用布局技巧,虽然现在都有框架布局,但是放到自己博客方便自己学习,原文地址https://segmentfault.com/a/1190000003931851 水平居中水平居中的页面布局中最为常见的一种布局形式，多出现于标题，以及内容区域的组织形式，下面介绍四种实现水平居中的方法（注：下面各个实例中实现的是child元素的对齐操作，child元素的父容器是parent元素） 使用inline-block 和 text-align实现123.parent&#123;text-align: center;&#125;.child&#123;display: inline-block;&#125;优点：兼容性好；不足：需要同时设置子元素和父元素 使用margin:0 auto来实现 12.child&#123;width: 200px; margin: 0 auto;&#125;优点：兼容性好缺点: 需要指定宽度 使用table实现12.child&#123;display: table; margin: 0 auto;&#125;优点:只需要对自身进行设置不足:IE6,7需要调整结构 使用绝对定位实现1234.parent&#123;position:relative;&#125;/*或者实用margin-left的负值为盒子宽度的一半也可以实现，不过这样就必须知道盒子的宽度，但兼容性好*/.child&#123;position:absolute; left:50%; transform:translate(-50%);&#125;不足：兼容性差,IE9及以上可用 实用flex布局实现123456/*第一种方法*/.parent&#123;display:flex; justify-content:center;&#125;/*第二种方法*/.parent&#123;display:flex;&#125;.child&#123;margin:0 auto;&#125;缺点：兼容性差，如果进行大面积的布局可能会影响效率 垂直居中vertical-align1234/*第一种方法*/.parent&#123;display:table-cell;vertical-align:middle;height:20px;&#125;/*第二种方法*/.parent&#123;display:inline-block;vertical-align:middle;line-height:20px;&#125; 实用绝对定位12.parent&#123;position:relative;&#125;.child&#123;positon:absolute; top:50%; transform:translate(0,-50%);&#125; 实用flex实现1.parent&#123;display:flex; align-items:center;&#125; 水平垂直全部居中利用vertical-align,text-align,inline-block实现12.parent&#123;display:table-cell; vertical-align:middle; text-align:center;&#125;.child&#123;display:inline-block;&#125; 利用绝对定位实现12.parent&#123;position:relative;&#125;.child&#123;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);&#125; 利用flex实现1.parent&#123;display:flex;justify-content:center;align-items:center;&#125; 左列定宽，右列自适应(其他演变原理基本一样)该布局方式非常常见，适用于定宽的一侧常为导航，自适应的一侧为内容的布局利用float+margin实现12.left&#123;float:left;width:100px;&#125;.right&#123;margin-left:100px;&#125; 利用float+margin(fix)实现123456789&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right-fix\"&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;.left&#123;width:100px;float:left;&#125;.right-fix&#123;width:100%;margin-left:-100px;float:right;&#125;.right&#123;margin-left:100px;&#125; 使用float+overflow实现12.left&#123;width:100px;float:left;&#125;.right&#123;overflow:hidden;&#125; 使用table实现123.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.left&#123;width:100px;&#125;.right,.left&#123;display:table-cell;&#125; 实用flex实现123.parent&#123;display:flex;&#125;.left&#123;width:100px;&#125;.right&#123;flex:1;&#125; 多列等分布局实用float实现12345678&lt;div class=\"parent\"&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt; &lt;div class=\"column\"&gt;1&lt;/div&gt;&lt;/div&gt;.parent&#123;margin-left:-20px&#125;/*假设列之间的间距为20px*/.column&#123;float:left;width:25%;padding-left:20px;box-sizing:border-box;&#125; 利用table实现123.parent-fix&#123;margin-left:-20px;&#125;.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.column&#123;display:table-cell;padding-left:20px;&#125; 九宫格布局使用table实现12345678&lt;div class=\"parent\"&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt;.parent&#123;display:table;table-layout:fixed;width:100%;&#125;.row&#123;display:table-row;&#125;.item&#123;display:table-cell;width:33.3%;height:200px;&#125; 实用flex实现12345678&lt;div class=\"parent\"&gt;&lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"row\"&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;div class=\"item\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;.parent&#123;display:flex;flex-direction:column;&#125;.row&#123;height:100px;display:flex;&#125;.item&#123;width:100px;background:red;&#125; 全屏布局利用绝对定位实现1234567891011&lt;div class=\"parent\"&gt;&lt;div class=\"top\"&gt;top&lt;/div&gt;&lt;div class=\"left\"&gt;left&lt;/div&gt;&lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;div class=\"bottom\"&gt;bottom&lt;/div&gt;&lt;/div&gt;html,body,parent&#123;height:100%;overflow:hidden;&#125;.top&#123;position:absolute:top:0;left:0;right:0;height:100px;&#125;.left&#123;position:absolute;top:100px;left:0;bottom:50px;width:200px;&#125;.right&#123;position:absolute;overflow:auto;left:200px;right:0;top:100px;bottom:50px;&#125;.bottom&#123;position:absolute;left:0;right:0;bottom:0;height:50px;&#125; 利用flex实现1234567891011121314&lt;div class=\"parent\"&gt;&lt;div class=\"top\"&gt;top&lt;/div&gt;&lt;div class=\"middle\"&gt;&lt;div class=\"left\"&gt;left&lt;/div&gt;&lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"bottom\"&gt;bottom&lt;/div&gt;&lt;/div&gt;.parent&#123;display:flex;flex-direction:column;&#125;.top&#123;height:100px;&#125;.bottom&#123;height:50px;&#125;.middle&#123;flex:1;display:flex;&#125;.left&#123;width:200px;&#125;.right&#123;flex:1;overflow:auto;&#125; 响应式布局meta标签的实用设置布局宽度等于设备宽度，布局viewport等于度量viewport1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1\"&gt; 媒体查询12@media screen and (max-width:960px)&#123;....&#125;&lt;link rel=\"stylesheet\" media=\"screen and (max-width:960px)\" href='xxx.css' /&gt;","tags":[{"name":"网页布局","slug":"网页布局","permalink":"//carrot.me/tags/网页布局/"}]},{"title":"js之内存管理","date":"2016-04-13T12:36:00.000Z","path":"2016/04/13/js-内存管理/","text":"学好内存管理,避免内存泄漏虽然js有垃圾回收机制,可以很大程度的避免内存泄漏,不过有时候当一个项目很大的时候,内存泄漏就应该要重视,学习内存管理也是一个不可少的步骤.原文地址http://www.jianshu.com/p/84a8fd5fa0ee 内存的生命周期JS环境中分配的内存一般有如下生命周期：内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存内存使用：即读写内存，也就是使用变量、函数等内存回收：使用完毕，由垃圾回收自动回收不再使用的内存内存分配的几个例子： 1234567891011121314// 为变量分配内存var i = 11;var s = \"ifcode\";// 为对象分配内存var person = &#123; age: 22, name: 'ifcode'&#125;;// 为函数分配内存function sum(a, b) &#123; return a + b;&#125; 垃圾回收算法引用计数算法引用计数算法定义“内存不再使用”的标准很简单，就是看一个对象是否有指向它的引用。如果没有其他对象指向它了，说明该对象已经不再需了。1234567891011121314151617181920// 创建一个对象person，他有两个指向属性age和name的引用var person = &#123; age: 22, name: 'ifcode'&#125;;person.name = null; // 虽然设置为null，但因为person对象还有指向name的引用，因此name不会回收var p = person; person = 1; //原来的person对象被赋值为1，但因为有新引用p指向原person对象，因此它不会被回收p = null; //原person对象已经没有引用，很快会被回收由上面可以看出，引用计数算法是个简单有效的算法。但它却存在一个致命的问题：循环引用。如果两个对象相互引用，尽管他们已不再使用，垃圾回收器不会进行回收，导致内存泄露。function cycle() &#123; var o1 = &#123;&#125;; var o2 = &#123;&#125;; o1.a = o2; o2.a = o1; return \"Cycle reference!\"&#125; 标记清除算法标记清除算法将“不再使用的对象”定义为“无法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 如何写出对内存管理友好的JS代码？对现代浏览器来说，唯一要注意的就是明确切断需要回收的对象与根部的联系。有时候这种联系并不明显，且因为标记清除算法的强壮性，这个问题较少出现。最常见的内存泄露一般都与DOM元素绑定有关","tags":[{"name":"内存管理","slug":"内存管理","permalink":"//carrot.me/tags/内存管理/"}]},{"title":"js之正则表达式","date":"2016-04-11T12:36:00.000Z","path":"2016/04/11/js-正则表达式/","text":"火星文虽难学,不过大概还是要懂得!!正则表达式我最不想学的东西,因为火星文谁看得懂啊,有事谷歌,百度不就好啦,虽然嘴上这样说,但是还是要去学习.以后不懂上自己博客找咯!原文地址http://www.cnblogs.com/China3S/archive/2013/11/30/3451971.html 介绍正则表达式就是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。 匹配工具http://www.regexpal.com/http://rubular.com/正则匹配软件 McTracer 正则字符简单介绍元字符介绍123456789101112131415161718192021222324252627282930313233343536373839404142\\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，“n”匹配字符“n”。“\\n”匹配一个换行符。串行“\\\\”匹配“\\”而“\\(”则匹配“(”。^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。$ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。* 匹配前面的子表达式零次或多次。例如，zo*能匹配“z”以及“zoo”。*等价于&#123;0,&#125;。+ 匹配前面的子表达式一次或多次。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于&#123;1,&#125;。? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“does”或“does”中的“do”。?等价于&#123;0,1&#125;。&#123;n&#125; n是一个非负整数。匹配确定的n次。例如，“o&#123;2&#125;”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。&#123;n,&#125; n是一个非负整数。至少匹配n次。例如，“o&#123;2,&#125;”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o&#123;1,&#125;”等价于“o+”。“o&#123;0,&#125;”则等价于“o*”。&#123;n,m&#125; m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o&#123;1,3&#125;”将匹配“fooooood”中的前三个o。“o&#123;0,1&#125;”等价于“o?”。请注意在逗号和两个数之间不能有空格。? 当该字符紧跟在任何一个其他限制符（*,+,?，&#123;n&#125;，&#123;n,&#125;，&#123;n,m&#125;）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+?”将匹配单个“o”，而“o+”将匹配所有“o”。. 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“(.|\\n)”的模式。(pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\\(”或“\\)”。(?:pattern) 匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。(?=pattern) 正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。(?!pattern) 正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始(?&lt;=pattern) 反向肯定预查，与正向肯定预查类拟，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。(?&lt;!pattern) 反向否定预查，与正向否定预查类拟，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”。“(z|f)ood”则匹配“zood”或“food”。[xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。[^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“p”。[a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。[^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。\\b 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。\\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。\\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。\\d 匹配一个数字字符。等价于[0-9]。\\D 匹配一个非数字字符。等价于[^0-9]。\\f 匹配一个换页符。等价于\\x0c和\\cL。\\n 匹配一个换行符。等价于\\x0a和\\cJ。\\r 匹配一个回车符。等价于\\x0d和\\cM。\\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。\\S 匹配任何非空白字符。等价于[^ \\f\\n\\r\\t\\v]。\\t 匹配一个制表符。等价于\\x09和\\cI。\\v 匹配一个垂直制表符。等价于\\x0b和\\cK。\\w 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。\\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。\\xn 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\\x41”匹配“A”。“\\x041”则等价于“\\x04&amp;1”。正则表达式中可以使用ASCII编码。.\\num 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\\1”匹配两个连续的相同字符。\\n 标识一个八进制转义值或一个向后引用。如果\\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。\\nm 标识一个八进制转义值或一个向后引用。如果\\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\\nm将匹配八进制转义值nm。\\nml 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。\\un 匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\\u00A9匹配版权符号（©）。 常用正则表达式大全123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108匹配中文字符的正则表达式： [u4e00-u9fa5] 评注：匹配中文还真是个头疼的事，有了这个表达式就好办了 匹配双字节字符(包括汉字在内)：[^x00-xff] 评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 匹配空白行的正则表达式：ns*r 评注：可以用来删除空白行 匹配HTML标记的正则表达式：&lt;(S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; 评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 匹配首尾空白字符的正则表达式：^s*|s*$ 评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 评注：表单验证时很实用 匹配网址URL的正则表达式：[a-zA-z]+://[^s]* 评注：网上流传的版本功能很有限，上面这个基本可以满足需求 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 评注：表单验证时很实用 匹配国内电话号码：d&#123;3&#125;-d&#123;8&#125;|d&#123;4&#125;-d&#123;7&#125; 评注：匹配形式如 0511-4405222 或 021-87888822 匹配腾讯QQ号：[1-9][0-9]&#123;4,&#125; 评注：腾讯QQ号从10000开始 匹配中国邮政编码：[1-9]d&#123;5&#125;(?!d) 评注：中国邮政编码为6位数字 匹配身份证：d&#123;15&#125;|d&#123;18&#125; 评注：中国的身份证为15位或18位 匹配ip地址：d+.d+.d+.d+ 评注：提取ip地址时有用 匹配特定数字： ^[1-9]d*$ //匹配正整数 ^-[1-9]d*$ //匹配负整数 ^-?[1-9]d*$ //匹配整数 ^[1-9]d*|0$ //匹配非负整数（正整数 + 0） ^-[1-9]d*|0$ //匹配非正整数（负整数 + 0） ^[1-9]d*.d*|0.d*[1-9]d*$ //匹配正浮点数 ^-([1-9]d*.d*|0.d*[1-9]d*)$ //匹配负浮点数 ^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$ //匹配浮点数 ^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$ //匹配非负浮点数（正浮点数 + 0） ^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$ //匹配非正浮点数（负浮点数 + 0） 评注：处理大量数据时有用，具体应用时注意修正 匹配特定字符串： ^[A-Za-z]+$ //匹配由26个英文字母组成的字符串 ^[A-Z]+$ //匹配由26个英文字母的大写组成的字符串 ^[a-z]+$ //匹配由26个英文字母的小写组成的字符串 ^[A-Za-z0-9]+$ //匹配由数字和26个英文字母组成的字符串 ^w+$ //匹配由数字、26个英文字母或者下划线组成的字符串 在使用RegularExpressionValidator验证控件时的验证功能及其验证表达式介绍如下: 只能输入数字：“^[0-9]*$” 只能输入n位的数字：“^d&#123;n&#125;$” 只能输入至少n位数字：“^d&#123;n,&#125;$” 只能输入m-n位的数字：“^d&#123;m,n&#125;$” 只能输入零和非零开头的数字：“^(0|[1-9][0-9]*)$” 只能输入有两位小数的正实数：“^[0-9]+(.[0-9]&#123;2&#125;)?$” 只能输入有1-3位小数的正实数：“^[0-9]+(.[0-9]&#123;1,3&#125;)?$” 只能输入非零的正整数：“^+?[1-9][0-9]*$” 只能输入非零的负整数：“^-[1-9][0-9]*$” 只能输入长度为3的字符：“^.&#123;3&#125;$” 只能输入由26个英文字母组成的字符串：“^[A-Za-z]+$” 只能输入由26个大写英文字母组成的字符串：“^[A-Z]+$” 只能输入由26个小写英文字母组成的字符串：“^[a-z]+$” 只能输入由数字和26个英文字母组成的字符串：“^[A-Za-z0-9]+$” 只能输入由数字、26个英文字母或者下划线组成的字符串：“^w+$” 验证用户密码:“^[a-zA-Z]w&#123;5,17&#125;$”正确格式为：以字母开头，长度在6-18之间， 只能包含字符、数字和下划线。 验证是否含有^%&amp;'',;=?$\"等字符：“[^%&amp;'',;=?$x22]+” 只能输入汉字：“^[u4e00-u9fa5],&#123;0,&#125;$” 验证Email地址：“^w+[-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$” 验证InternetURL：“^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$” 验证电话号码：“^((d&#123;3,4&#125;)|d&#123;3,4&#125;-)?d&#123;7,8&#125;$” 正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”， “XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。 验证身份证号（15位或18位数字）：“^d&#123;15&#125;|d&#123;&#125;18$” 验证一年的12个月：“^(0?[1-9]|1[0-2])$”正确格式为：“01”-“09”和“1”“12” 验证一个月的31天：“^((0?[1-9])|((1|2)[0-9])|30|31)$” 正确格式为：“01”“09”和“1”“31”。 匹配中文字符的正则表达式： [u4e00-u9fa5] 匹配双字节字符(包括汉字在内)：[^x00-xff] 匹配空行的正则表达式：n[s| ]*r 匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*|&lt;(.*) /&gt;/ 匹配首尾空格的正则表达式：(^s*)|(s*$) 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)* 匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)? (1)应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） String.prototype.len=function()&#123;return this.replace([^x00-xff]/g,\"aa\").length;&#125; (2)应用：JavaScript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现 String.prototype.trim = function() &#123; return this.replace(/(^s*)|(s*$)/g, \"\"); &#125; (3)应用：利用正则表达式分解和转换IP地址 function IP2V(ip) //IP地址转换成对应数值 &#123; re=/(d+).(d+).(d+).(d+)/g //匹配IP地址的正则表达式 if(re.test(ip)) &#123; return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1 &#125; else &#123; throw new Error(\"Not a valid IP address!\") &#125; &#125; (4)应用：从URL地址中提取文件名的javascript程序 s=\"http://www.9499.net/page1.htm\"; s=s.replace(/(.*/)&#123;0,&#125;([^.]+).*/ig,\"$2\") ;//Page1.htm (5)应用：利用正则表达式限制网页表单里的文本框输入内容 用正则表达式限制只能输入中文：onkeyup=\"value=value.replace(/[^u4E00-u9FA5]/g,'') \"onbeforepaste=\"clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[^u4E00-u9FA5]/g,''))\" 用正则表达式限制只能输入全角字符： onkeyup=\"value=value.replace(/[^uFF00-uFFFF]/g,'') \"onbeforepaste=\"clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[^uFF00-uFFFF]/g,''))\" 用正则表达式限制只能输入数字：onkeyup=\"value=value.replace(/[^d]/g,'') \"onbeforepaste= \"clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[^d]/g,''))\" 用正则表达式限制只能输入数字和英文：onkeyup=\"value=value.replace(/[W]/g,'') \"onbeforepaste=\"clipboardData.setData(''text'',clipboardData.getData(''text'').replace(/[^d]/g,''","tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"//carrot.me/tags/正则表达式/"}]},{"title":"Angular总结","date":"2016-04-11T06:11:00.000Z","path":"2016/04/11/Angular问题总结/","text":"angular关键核心点进行总结 前言12angular中有很多知识点需要学习,学习成本是很大的,我通过平常开发中把一些很重要知识点总结下来,不管是以后拿来用,或者跳槽面试需要,我都感觉是很有帮助的! angular的缺点123456本身它是比较笨重的,源码就有3w多行,并且替我封装了很多的方法,所以它的性能是比较差的.所以我们在用的时候,就要尽最多程度保证性能了.第一个:不要过多在$Scope.$watch方法,因为这个方法会一直执行,如果我们不去手动关闭,这个方法会一直监听绑定的属性,所以是非常耗性能的.减少不必要的数据展示,因为进行视图的展示,会触发脏值检测,如果一些不必要的数据展示到视图中,就会耗性能了 ng-if ,ng-show ,ng-hide 区别1234567这三者虽然很类似,但是还是不同首先是共同点:它们三者都可以起到隐藏显示元素的作用不同点:ng-if的隐藏是把dom元素直接删除,而show和hide只是类似使用display:none的方法第二个不同点使用场景不一样,ng-if一般用在单次显示隐藏的时候,比如页面一上来就出现的广告信息,关闭之后就不会在显示,而show hide一般是配套使用用来控制一些元素显示隐藏,多次使用,比如头部的返回和底部的tabbar,它们是相反的,通过show和hide方法就能用一个变量控制它们的显示和隐藏 ng-repeat迭代数据出现数据相同处理123平常使用ng-repeat时候,遍历数据可能会出现数据相同情况,这时候就会报错,如何解决这个问题呢?其实很简单,只需要在后面加上 track-by='索引' 里面传入一个不同的值,就能解决数据一样的情况了 ng-事件绑定,能否使用原生js对象方法12345我们在事件绑定时候,是不允许使用原生js对象的方法的,因为angualr不允许我们这样做,如何使用这些方法,angular为我们封装了属于自己的对象,在原生对象的前面加一个$,例如$window,$timeout.$interval 都是angular为我们封装,我们需要使用的使用,在依赖注入服务的时候把这些服务也一同注入进来,就能使用这样对象,它们的实现的功能和原生js对象是一样的,只不过用法稍微不同而尔! factory、service 和 provider 区别1234567891011121314151617在平常的开发中,需要用到很多自定义服务,而它们三者之间的共同点就是用来自定义服务的,它们的本质都是创建对象返回一个方法.而它们之间的不同就在于定义的方式不一样factory自定义服务:我们需要在内部返回一个一个对象,先通过function getData() 定义函数然后通过返回一个对象 return &#123;getDate:getData&#125;的方式,我们需要使用的时候通过服务名称.对象的key 例如上面的例子,服务名称.getDate()就能调用服务的方法了service服务:我们通过this来创建函数,例如,this.getData=function() 然后通过服务名称.getData() 就能调用服务里面的方法了provider服务:我们需要通过this调用 $get方法 this.$get(&#123;return｛｝&#125;) 方法里面返回一个对象，然后对象接收一个方法，我们通过服务名称.对象名称就能调用服务的方法了内置服务都会提供一个provider来进行配置,通过配置文件config方法,然后注入对应服务的名称例如 //开启和禁用 调用config方法app.config(['$logProvider',function ($logProvider) &#123; $logProvider.debugEnabled(false);&#125;]) angular当中数据绑定的机制和原理 $digest $apply12345angular中是通过脏值检测的方式来进行数据展示到视图的每次在视图中绑定数据的时候,都会把这个数据添加到一个$watchlist数组当中,里面的属性会被$watch监听,只要有事件的方式,就会触发$degist事件,它第一次会遍历$watchlist数组,询问每一个属性是否有更改,然后回再次遍历一次$scope上面的属性,是否有更新,如果有,会再次遍历数组,如果没有就会触发$apply方法,把数据展示到视图中 定时器的取消和$watch的停止123456当我们项目需要用到定时器时候,我们肯定需要关闭定时,原生js通过clearInterval来关闭而angular中通过 $interval.cancel(timer)来关闭 先用一个变量接收var timer=$interval();$watch方法调用的时候会返回一个函数,如果我们想要停止某个监听,在定义时候接收一下var stopWatch = $scope.$watch('监听的值',回调) ,再次调用该方法即可关闭监听 stopWatch(); angualr中指令以及里面的常用方法1234567891011121314151617181920212223242526自定义指令是可以以哪种方式进行展示的,通过 restrict 来定义 里面具体的值 为 E==&gt;元素 &lt;nav&gt;&lt;/nav&gt; A==&gt;属性 &lt;div nav&gt;&lt;/div&gt; C==&gt;类 &lt;div class='nav'&gt;&lt;/div&gt; M==&gt;注释 不建议使用template:模板,可以直接写html结构 并且里面的标签必须有一个父级包着,要不会报错.templateUrl:模板地址 写一个路径replace:true 设置为true会替换原来的标签transculde:true 该方法之适用外链模板 会保留标签里面的元素 在需要保留的元素添加 &lt;div transculde&gt;&lt;/div&gt;link:里面接收三个参数,分别是scope,ele,attr,它们分别是scope服务,ele为模板的元素,它会默认转换成jQ对象,attr为元素身上的属性scope修饰符: 里面有三个选项 该方法作用用于外界传值使用 第一种：自定义名称:'@' 通过&lt;xmg content=\"&#123;&#123;content&#125;&#125;\"\"&gt;&lt;/xmg&gt; 的插值语法获取值,该修饰符特点:外界数据修改,内部数据会一起修改,内部修改外部不修改, 并且如果指令本身具有该属性,外界同名的属性会覆盖 第二种:自定义名称:'=' &lt;xmg content=\"content\"&gt;&lt;/xmg&gt; 通过这中语法获取值 该修饰符特点:外界数据和内部数据会互相更改,并且内部同名的属性会被外部同名的属性覆盖 第三种 自定义名称:'&amp;' &lt;xmg content=\"content()\"&gt;&lt;/xmg&gt; 外界传入的是一个函数 angular常用的路由和它们之间的区别1234567angular当中常用路由是原生ngRoute 和 ui.router并且ui.router是依赖angualr的它们的共同点都是用来进行设置单页面(spa)不同的是,原生angular的路由只支持单视图展示,也就是说视图与视图不能嵌套,用法上受到很大的限制.而ui.router方法弥补了原生路由的不足,它不仅可以设置多视图的展示,还可以设置子路由的概念,就是同一个页面存在多个路由 angular依赖注入的原理123456我们知道依赖注入是angualr的核心之一,我们通过注入服务的方式,达到不同功能之间的相互联系,angualr当中有2种注入方式,一种是行内是注入,即我们帮注入的名称放到[]中例如 app.controller('控制器名称',[$scope,funtion($scope)&#123;&#125;]) 另外一种是推断式注入 app.controller('控制器名称',funtion($scope)&#123;&#125;]) 不写[],直接跟一个函数,它的缺点是很明显的,我们的项目都是需要经过压缩的,压缩会把一些形参转换成一些简单的字母,这时候anular就不能通过形参的值来判断需要哪一个服务,就会报错,所以这种方式不建议使用.. $rootScope 和$scope 区别123它们的共同点都是作业域.只不过$rootScope是作为根作用域,$scope的作用域和原生js的作用域链类似,都是由底层往上找,上面不能往下找,所以在$rootScope中定义的数据,在任何地方都能被使用,它就是一个数的根节点, $scope就像它的分支,一层层的往下分,形成一个树状分支. 数据绑定出现闪烁处理123当我们使用插值语法进行数据绑定的时候,会出现闪烁.解决办法第一种是ng-bind的方法或者ng-bind-template 方法第二个是绑定一个类ng-cloak 添加 display:none的方法 angular mvc和mvvm123简单的来说,angular是属于mvc和mvvmmvc指视 视图模型控制器mvvm值 数据的双向绑定 控制器之间的通讯12345想要实现控制器的通讯,先清楚作用域之间的关系,父控制器想要传输数据到子控制器,通过$scope.$broadcast 方法发送一个广播给子控制器,里面绑定一个通讯名称key 后面带上参数子空控制器通过$scope.$on 方法接收 传入key名称和一个回调.如果是子向父传数据,通过$scope.$emit方法发送,父级也是通过 $scope.$on方法来接收数据另外需要注意,一定要等指令加载完毕才去发送广播! 单页面应用的优缺点123spa应用,优缺点还是很明显的优点是性能高,始终只有一个页面,不需要跳转页面,减轻了服务器的压力.让用户的体验更加好.缺点就是不利于seo,对搜索引擎不友好.另外就是没有新窗口的跳转,对应习惯新窗口的用户来说可能造成不适应!!!","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"Angular综合应用","date":"2016-04-10T06:11:00.000Z","path":"2016/04/10/Angular综合应用/","text":"综合运用angular的各种方法实现简单webApp的开发 手机端适配123456789101112131415161718一般做webApp,都需要使用rem作为单位,所以不同于做pc端使用px,我们需要在手机端正常显示,第一步需要设置视口meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt;第二部是需要设置html的字体大小 var font = window.screen.width / 10 + 'px'; document.getElementsByTagName('html')[0].style.fontSize = font;我们开发比较习惯使用px,作为单位,我们可以通过css unit 方法 传入一个px值,转换成rem的值例如我们以i6位宽度单位 ,这样就能愉快的使用px作为单位去开发项目啦 *把像素转成rem 375/10 = 37.5 375 它是ipone6的屏幕宽度*/.fs(@px)&#123; font-size: unit(@px/37.5,rem);&#125; 模块化入口1234567分析当前需要什么模块,我需要用到ui-router所以在创建模块化的时候要依赖进去;(function (angular) &#123; //严格模式 \"use strict\"; //模块化名字 依赖模块 var app = angular.module('app',['ui.router']);&#125;)(angular); 顶部nav自定义指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657应该把样式分成不同的部位,例如,头部,底部,中间显示区域,点击之后出现详情等等,每一个部位用一个自定义的指令去构成,达到复用效果.首先搭建的是头部nav,需要注意的是,我们在使用同一个模块的时候,只需要写上app参数即可,不用再写依赖的模块了.下面为利用自定义创建一个nav的自定义指令,使用tempateUrl的方法导入html结构,所以需要再创建一个对应的html结构,下面的link方法后面解释;(function (angular) &#123; \"use strict\"; //顶部组件 angular.module('app').directive('nav', function () &#123; return &#123; restrict: 'EA', templateUrl: '../view/template/nav.html', link: function ($scope, ele, attr) &#123; //监听广播.改变内容 $scope.$on('tabbarChange', function (ev, attr) &#123; ele.find('span').html(attr.title); &#125;) &#125; &#125; &#125;);&#125;)(angular);创建指令需要的模板nav.html 里面就是写上html代码块,给上样式即可.就能实现一个自定义指令所需要的模板,以后我们要用的时候,只需要在index.html或者其他地方写上 &lt;nav&gt;&lt;/nav&gt; 就能达到模板的复用了!!//html结构&lt;div class=\"nav\"&gt; &lt;!--返回--&gt; &lt;a href=\"javascript:;\" ng-click=\"back()\" ng-show=\"flag\"&gt;&lt;&lt;/a&gt; &lt;!--标题--&gt; &lt;span&gt;今日一说&lt;/span&gt;&lt;/div&gt;//less结构.nav &#123; width: 100%; z-index: 100; .h(64px); background: lightseagreen; position: fixed; top: 0; left: 0; right: 0; color: white; .fs(30px); a &#123; line-height: 64px; text-decoration: none; color: white; &#125; span &#123; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); &#125;&#125; 底部tabbar的自定义指令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566按照上面的思想,我们继续创建底部tabbar的自定义指令;(function (angular) &#123; \"use strict\"; //底部组件 angular.module('app').directive('tabbar',function () &#123; return &#123; restrict:'EA', templateUrl:'../view/template/tabbar.html', /*controller:function ($scope) &#123; $scope.tabbarClick=function (type) &#123; $scope.$emit('tabbarChange',&#123;type:type&#125;); &#125; &#125;*/ &#125; &#125;);&#125;)(angular);然后创建html文件 ,对应的内容后面解释&lt;div class=\"tabbar\" ng-hide=\"flag\"&gt; &lt;ul&gt; &lt;li ng-click=\"tabbarClick('home')\" &gt;&lt;a &gt;&lt;img ng-src=\"images/&#123;&#123;type == 'home'?'homeSel.png':'home_icon.png'&#125;&#125;\" alt=\"\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li ng-click=\"tabbarClick('author')\" &gt;&lt;a &gt;&lt;img ng-src=\"images/&#123;&#123;type == 'author'?'authorSel.png':'author_icon.png'&#125;&#125;\" alt=\"\"&gt;作者&lt;/a&gt;&lt;/li&gt; &lt;li ng-click=\"tabbarClick('content')\" &gt;&lt;a &gt;&lt;img ng-src=\"images/&#123;&#123;type == 'content'?'contentSel.png':'content_icon.png'&#125;&#125;\" alt=\"\"&gt;栏目&lt;/a&gt;&lt;/li&gt; &lt;li ng-click=\"tabbarClick('my')\" &gt;&lt;a &gt;&lt;img ng-src=\"images/&#123;&#123;type == 'my'?'mySel.png':'my_icon.png'&#125;&#125;\" alt=\"\"&gt;我的&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;样式.tabbar &#123; .h(49px); position: fixed; left: 0; bottom: 0; right: 0; z-index: 101; background: #fff; ul &#123; display: flex; border-top: 1px solid #ccc; li &#123; float: left; flex: 1; list-style: none; text-align: center; .fs(16px); .mt(3px); a &#123; color: #666; text-decoration: none; &#125; img &#123; .w(25px); .h(25px); display: block; margin: 0 auto; &#125; &#125; &#125;&#125; 点击底部实现头部文字的改变12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667现在需要点击底部的tabbar四个按钮,然后改变nav上的文字, 先给底部tabbar绑定点击事件&lt;div class=\"tabbar\" ng-hide=\"flag\"&gt; &lt;ul&gt; &lt;li ng-click=\"tabbarClick('home')\" &gt;&lt;a &gt;&lt;img ng-src=\"images/&#123;&#123;type == 'home'?'homeSel.png':'home_icon.png'&#125;&#125;\" alt=\"\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li ng-click=\"tabbarClick('author')\" &gt;&lt;a &gt;&lt;img ng-src=\"images/&#123;&#123;type == 'author'?'authorSel.png':'author_icon.png'&#125;&#125;\" alt=\"\"&gt;作者&lt;/a&gt;&lt;/li&gt; &lt;li ng-click=\"tabbarClick('content')\" &gt;&lt;a &gt;&lt;img ng-src=\"images/&#123;&#123;type == 'content'?'contentSel.png':'content_icon.png'&#125;&#125;\" alt=\"\"&gt;栏目&lt;/a&gt;&lt;/li&gt; &lt;li ng-click=\"tabbarClick('my')\" &gt;&lt;a &gt;&lt;img ng-src=\"images/&#123;&#123;type == 'my'?'mySel.png':'my_icon.png'&#125;&#125;\" alt=\"\"&gt;我的&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;绑定ng-click 在点击的时候传入一个参数,参数为对应的文字内容,指令与指令之间怎么互相联系呢?这时候需要用到它们共有的一个父控制器,我们点击的时候把数据传给父控制器,然后父控制器发送一个广播,然后顶部的nav指令通过link方法去接收广播,就能达到指令与指令之间的联系了. 定义一个type的数据,然后点击时候接收参数赋值给type,然后定义一个变量title用来赋值,根据传入的参数不同赋值对应的值.然后父控制器发送广播,传入对象作为参数.然后我们在nav指令方法接收到传入的参数,通过里面的ele属性,这个属性是获取当前nav的dom对象,所以找到里面显示标题的标签赋值为对应的值就能实现点击改变标题了;(function (angular) &#123; \"use strict\"; angular.module('app').controller('lbmController', ['$scope', '$window', '$location', function ($scope, $window, $location) &#123; //标题名称 $scope.titleName = '今日一说'; //类型 $scope.type = 'home'; //标题 var title = '今日一说'; //底部导航切换 $scope.tabbarClick = function (type) &#123; $scope.type = type; switch (type) &#123; case 'home': title = '今日一说'; break; case 'author': title = '作者'; break; case 'content': title = '栏目'; break; case 'my': title = '我的'; break; &#125; //发送广播 $scope.$broadcast('tabbarChange', &#123;type: type, title: title&#125;); &#125;;angular.module('app').directive('nav', function () &#123; return &#123; restrict: 'EA', templateUrl: '../view/template/nav.html', link: function ($scope, ele, attr) &#123; //监听广播.改变内容 $scope.$on('tabbarChange', function (ev, attr) &#123; ele.find('span').html(attr.title); &#125;) &#125; &#125; &#125;); 配置路由12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970我们在页面中需要同时显示2种不同类型的页面,这时候就用到了子路由的方法,在一个路由中定义多个子路由实现不同页面的展示,首先是配置一个主路由,主路由使用多视图的方法,这些视图一开始是全部加载到页面中的,我们通过ng-show的方法,通过判断底部tababar传入的参数而进行显示和隐藏,每一个视图绑定一个模板,绑定一个自己的控制器.主页创建一个叫home.html的文件,里面用来展示子路由&lt;!--首页--&gt;&lt;div ui-view=\"home\" ng-show=\"type == 'home'\"&gt;&lt;/div&gt;&lt;!--作者--&gt;&lt;div ui-view=\"author\" ng-show=\"type == 'author'\"&gt;&lt;/div&gt;&lt;!--栏目--&gt;&lt;div ui-view=\"content\" ng-show=\"type == 'content'\"&gt;&lt;/div&gt;&lt;!--我的--&gt;&lt;div ui-view=\"my\" ng-show=\"type == 'my'\"&gt;&lt;/div&gt;&lt;!--展示子路由对应的数据--&gt;&lt;div ui-view ng-show=\"load\"&gt;&lt;/div&gt;&lt;!--加载效果--&gt;&lt;div ng-hide=\"load\"&gt; &lt;img src=\"images/loading.gif\" alt=\"\"&gt;&lt;/div&gt;\"use strict\"; //配置文件,依赖服务 angular.module('app').config(['$stateProvider', '$urlRouterProvider', function ($stateProvider, $urlRouterProvider) &#123; $stateProvider.state('app', &#123; url: '/app', views: &#123; home: &#123; templateUrl: '../view/home.html', controller:'homeController' &#125;, author: &#123; template: '作者' &#125;, content: &#123; template: '栏目' &#125;, my: &#123; template: '我的' &#125; &#125; &#125;); //默认跳转 $urlRouterProvider.otherwise('/app') &#125;])这时候就设置子路由了 一个是显示首页的,一个是点击首页的内容进行跳转的.我们通过主路由.名字来设定,然后每一个子路由对应一个模板.因为详情页对应多个数据,所以需要传入参数..,涉及到参数的话,需要在自己的范围内绑定一个控制器用来获取路由的参数了.. //配置home路由 .config(['$stateProvider',function ($stateProvider) &#123; $stateProvider.state('app.home', &#123; url: '/home', template:'&lt;list list-item=\"data.posts\"&gt;&lt;/list&gt;' &#125;); &#125;]) //配置首页路由 .config(['$stateProvider',function ($stateProvider) &#123; $stateProvider.state('app.detail', &#123; url: '/detail/:id', template:'&lt;detail content=\"&#123;&#123;content&#125;&#125;\"&gt;&lt;/detail&gt;', controller:'detailController' &#125;); &#125;]) 自定义请求服务12345678910111213141516171819202122232425262728293031为什么需要自定义请求服务呢?就是以后的扩展性,应为angular的http方法经过改动,如果我们都使用原生,一旦修改了,那项目中所有用到请求的地方都需要修改,所以我们需要自定义一个服务,这样以后修改的话,只需要修改自定义服务即可.通过service定义一个方法代替http,我们需要跨域请求访问,就需要设置白名单了.;(function (angular) &#123; \"use strict\"; //自定义服务用来获取数据 angular.module('app').service('myHttp',['$http',function ($http) &#123; this.getData = function (success,error) &#123; $http(&#123; url:'http://localhost/api/home.php', method:'jsonp', &#125;).then(function (res) &#123; success(res.data); &#125;).catch(function (err) &#123; error(err); &#125;) &#125; &#125;])&#125;)(angular);;(function (angular) &#123; \"use strict\"; /*设置白名单，允许哪些网址可以跨域*/ angular.module('app').config(['$sceDelegateProvider', function ($sceDelegateProvider) &#123; $sceDelegateProvider.resourceUrlWhitelist([ 'self', 'http://localhost/api/**' ]); &#125;]);&#125;)(angular); 主页控制器发送请求拿数据123456789101112131415;(function (angular) &#123; &quot;use strict&quot;; //主页发送请求拿到主页数据 angular.module(&apos;app&apos;).controller(&apos;homeController&apos;,[&apos;$scope&apos;,&apos;myHttp&apos;,&apos;$state&apos;,function ($scope,myHttp,$state) &#123; //默认跳转的子路由 $state.go(&apos;app.home&apos;); myHttp.getData(function (res) &#123; $scope.load = true ; $scope.data = res ; console.log($scope.data); &#125;,function (err) &#123; &#125;) &#125;]);&#125;)(angular); 拿到数据展示数据到首页路由123456789101112131415161718192021222324252627282930313233343536373839404142我们和之前一样,设置自定义指令展示首页数据,里面scope的作用是用来和外界之间数据的联系,通过这种方法可以达到扩展性作用,如果一旦数据更改,只需要更改一处地方即可;(function (angular) &#123; \"use strict\"; //列表内容组件 angular.module('app').directive('list', function () &#123; return &#123; restrict: 'EA', templateUrl: '../view/template/list.html', scope:&#123; listItem:'=' &#125; &#125; &#125;);&#125;)(angular);我们创建list.html通过请求到数据展示数据 先用自己listItem接收到数据,再用listItem展示数据,这样好处上面已经说了.&lt;div class=\"list clearfix\" ng-repeat=\"(key,item) in listItem\" ui-sref=\"app.detail(&#123;id:key&#125;)\"&gt; &lt;p class=\"tag\" ng-bind=\"item.column.name\"&gt;&lt;/p&gt; &lt;h3 ng-bind=\"item.title\"&gt;&lt;/h3&gt; &lt;!--只有文字--&gt; &lt;div class=\"content1\" ng-if=\"item.display_style=='10001'\"&gt; &lt;p ng-bind=\"item.abstract\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;!--图片加文字--&gt; &lt;div class=\"content2\" ng-if=\"item.display_style=='10002'\"&gt; &lt;p ng-bind=\"item.abstract\"&gt;&lt;/p&gt; &lt;img src=\"images/post_1.png\" alt=\"\"&gt; &lt;/div&gt; &lt;!--三张图片--&gt; &lt;div class=\"content3\" ng-if=\"item.display_style=='10003'\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"images/post_2.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/post_3.png\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"images/post_4.png\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt;首页展示数据使用了一个技巧,因为可能布局都不一样,所以我们需要先把全部样式写好,然后根据后台返回的数据对无关的样式进行隐藏即可. 子路由详情控制器拿到参数进行页面展示123456789101112131415只能是通过点击具体的详情,然后获取对应参数拿到对应的数据.;(function (angular) &#123; \"use strict\"; //详情控制器,拿到路由传递的参数 angular.module('app').controller('detailController',['$scope','$stateParams',function ($scope,$stateParams) &#123; console.log($stateParams.id); var content = $scope.data.posts[$stateParams.id].content; $scope.content = content ; &#125;]);&#125;)(angular);首页这里作用就是点击,获取具体的参数,传到控制器,由控制器根据对应参数拿到对应的数据,通过ui-sref 来展示子路由页面&lt;div class=\"list clearfix\" ng-repeat=\"(key,item) in listItem\" ui-sref=\"app.detail(&#123;id:key&#125;)\"&gt; 子路由详情页模板123456789101112131415161718同样,在子路由中绑定模板,自定义详情指令;(function (angular) &#123; \"use strict\"; //通过指令操作属性,获取数据利用html插入html标签 angular.module('app').directive('detail', function () &#123; return &#123; restrict: 'EA', link:function ($scope,ele,attr) &#123; ele.html(attr.content); &#125; &#125; &#125;);&#125;)(angular);因为angular无法解析html的数据结构,所以只能通过link方法操作dom元素了,在子路由的模板这样设置 template:'&lt;detail content=\"&#123;&#123;content&#125;&#125;\"&gt;&lt;/detail&gt;', 通过一个属性来绑定之前详情控制器拿到的数据,里面就是html结构数据,然后通过link方法获取到属性的内容设置到模板里面即可 这应该算是angular的一个缺点吧! 其他小技巧123456789101112131415161718192021加载动画也数据展示通过一标志来进行判断,获取数据时候隐藏,获取到数据时候就展示,两者对应关系, 返回按钮和底部菜单根据哈希值来进行观察,当哈希值发生变化就让具体的显示或者隐藏,也是通过一个标签控制 //绑定location到scope,作用是让其可以监听location里面的变化 $scope.$location = $location; //控制后退和底部导航的显示隐藏 $scope.flag = true; //监听哈希值变化 $scope.$watch('$location.url()', function (newVal, oldVal) &#123; if (newVal == '/app/home') &#123; $scope.flag = true; &#125;else&#123; $scope.flag = false; &#125; &#125;);返回按钮通过window对象的histroy.back()进行返回 //后退功能 $scope.back = function () &#123; $window.history.back(); &#125;; 总结12345整一个应用基本使用到angular中很多常用的方法了,指令,服务,路由,控制器,通过这样一个应用,加深自己对angular的理解,所以当我写完这篇博客时候,对angular中各种方法的使用更加熟练,对于数据的关系,不同控制器,指令之间的数据传输,更加可以灵活运用,对于路由,子路由,多视图的理解,又更进一步了.希望继续努力吧,通过angular让开发更加得心应手,开放出一个让客户满意的webApp. 效果","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"Angular简单应用","date":"2016-04-09T06:11:00.000Z","path":"2016/04/09/Angular简单应用/","text":"利用豆瓣api实现的简单电影搜索功能 整体思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264第一步:先把整体的样式搭建好,创立一个假数据测试,然后就可以准备从服务器拿数据第二步:我们可以把angular中每一部分的指令都独立出来一个文件,方便管理. angular1.6.js angular-route.js config.js controller.js directive.js index.js jquery-3.1.1.js service.js第三步:在index.js创建好模块化的名字以及依赖路由,所有js文件都通过;()()闭包方式来进行,保证内部的变量不受外界干扰 ;(function (angular) &#123; //创建模块,依赖路由服务 var app=angular.module('app',['ngRoute']); &#125;)(angular,document); 第四步:配置路由,根据豆瓣api提供的接口来进行参数的设置 ,在config文件进行 ;(function (angular) &#123; //配置路由 angular.module('app').config(['$routeProvider', function ($routeProvider) &#123; //监听哈希值变化 $routeProvider.when('/movie/:name', &#123; //模板地址 templateUrl: 'content.html', //控制器名字 controller: 'movieController' //点击出现详情 &#125;).when('/details/:id', &#123; //模板地址 templateUrl: 'movie_detail_tpl.html', //控制器名字 controller: 'detailsController' &#125;).otherwise(&#123; //找不到对应的参数默认显示 redirectTo: '/movie/in_theaters' &#125;); //设置白名单 &#125;]).config(['$sceDelegateProvider', function ($sceDelegateProvider) &#123; $sceDelegateProvider.resourceUrlWhitelist([ 'self', 'https://api.douban.com/**' ]); &#125;]);&#125;)(angular);第五步:因为豆瓣api接收回调不允许出现.语法,而原生的angualr回调函数会出现.,所以需要自己手动封装一个jsonp,原理是随机自定义一个函数,然后绑定在window上,通过回调执行.传入url,参数,对参数进行格式处理拼接到url上,最后创建script标签设置src地址即可. ;(function (angular, document) &#123; //自定义服务 angular.module('app').service('$myHttp', ['$window', function ($window) &#123; /** * 定义jsonp方法用来跨域请求数据 * @param url 传入跨域的地址 * @param params 传入需要的参数 * @param callBack 回调操作 */ this.jsonp = function (url, params, callBack) &#123; //随机一个函数名,用来给服务器接收进行回调拿到数据 var callBackName = 'carrotming' + Math.random().toString().slice(2); //定义一个全局函数,调用回调函数 $window[callBackName] = function (data) &#123; callBack &amp;&amp; callBack(data); &#125;; //对传入的参数进行处理 拼接到url后面 //格式 url?key=value&amp;... var newParams = ''; for (var key in params) &#123; newParams += key + '=' + encodeURI(params[key]) + '&amp;'; &#125; url += '?' + newParams + 'callback=' + callBackName; //动态创建script标签 var oScript = document.createElement('script'); //添加src oScript.src = url; //插入到body标签里面 document.body.appendChild(oScript); &#125;; //配置apikey服务 &#125;]).value('apikey', '0b2bdeda43b5688921839c8ecb20399b') //配置url .value('url', 'https://api.douban.com/v2/movie/');&#125;)(angular, document);第6步:在控制器执行跨域访问,只需要调用之前封装的jsonp来进行跨域,并且查询豆瓣api来进行参数设置,最后添加上一页下一页的方法,即可完成跨域获取数据,需要强调的是,因为跨域存在延迟,而angular的机制是通过脏值检测来控制dom元素的展示,所以我们需要手动调用$apply的方法来触发脏值检测,才能正确的展示数据 ;(function (angular) &#123; angular.module('app') //电影控制器 .controller('movieController', ['$scope', '$myHttp', '$routeParams', 'apikey', 'url', '$timeout',function ($scope, $myHttp, $routeParams, apikey, url) &#123; //路由参数,对应标签的值 var name = $routeParams.name; // api密钥 var apikey = apikey; // 跨域的地址 var url = url + name; //跨域参数 //索引 $scope.index = 1; $scope.count = 5; $scope.totalCount=''; var movieParams = &#123; 'apikey': apikey, 'count': 5, 'start': 0, 'city': '中山' &#125;; $scope.flag = true ; $myHttp.jsonp(url, movieParams, function (data) &#123; $scope.flag = false ; //接收数据 $scope.data = data; $scope.totalCount=Math.floor(data.total/data.count); //触发脏值检测 $scope.$apply(); &#125;); $scope.search=function (text) &#123; $scope.info = text ; &#125;; $scope.all=function () &#123; $scope.info = '' ; &#125;; $scope.prev=function () &#123; $scope.flag = true ; $scope.index --; var start=( $scope.index - 1) * $scope.count; var movieParams = &#123; 'apikey': apikey, 'count': $scope.count, 'start': start, 'city': '中山' &#125;; $myHttp.jsonp(url, movieParams, function (data) &#123; $scope.flag = false ; //接收数据 $scope.data = data; //触发脏值检测 $scope.$apply(); &#125;); &#125;; $scope.next=function () &#123; $scope.flag = true ; $scope.index ++; var start=( $scope.index - 1) * $scope.count; var movieParams = &#123; 'apikey': apikey, 'count': $scope.count, 'start': start, 'city': '中山' &#125;; $myHttp.jsonp(url, movieParams, function (data) &#123; $scope.flag = false ; //接收数据 $scope.data = data; //触发脏值检测 $scope.$apply(); &#125;); &#125;; //详情控制器 &#125;]).controller('detailsController', ['$scope', '$myHttp', '$routeParams', 'apikey', 'url', function ($scope, $myHttp, $routeParams, apikey, url) &#123; $scope.flag = true ; //发送请求,重新获取数据 var url = url + $routeParams.id; var detailsParams = &#123;'apikey': apikey&#125;; $myHttp.jsonp(url, detailsParams, function (data) &#123; $scope.flag = false ; //接收数据 $scope.data = data; //触发脏值检测 $scope.$apply(); &#125;); &#125;])&#125;)(angular,document);第7步:我们设置自定义指令控制点击样式改变,重点是监听hash值得变化,把$location的服务绑定在$scope中,那样$location就会存放$watchlist队列中,然后脏值检测就能一个监听$location的变化,包括hash值,这里要操作元素,需要使用到link的参数,该方法会把绑定了指令的元素转化成jquery对象,能够使用基本的jquery方法,我们要做的就是判断该元素身上绑定a标签的href值与hash值是否相等即可改变样式 ;(function (angular) &#123; //自定义指令 angular.module('app').directive('ngactive', ['$location', function ($location) &#123; return &#123; restrict: 'A', link: function ($scope, ele, attr) &#123; //把location服务绑定到$scope中 $scope.$location = $location; //监听 $scope.$watch('$location.url()', function (newVal) &#123; //当点击的hash值等于当前的哈希值时候,添加样式,其余删除样式 var href = ele.find('a').attr('href').slice(2); if (newVal == href) &#123; ele.addClass(attr.ngactive).siblings('li').removeClass(attr.ngactive); &#125; &#125;) &#125; &#125; &#125;])&#125;)(angular);第8步:把获取到数据展示到页面中,只需要观察豆瓣api文档和观察返回的数据,然后进行数据传送即可把数据展示到是视图中 &lt;div ng-show=\"flag\" style=\"text-align: center\"&gt; &lt;img ng-src=\"loading.gif\" alt=\"\" &gt;&lt;/div&gt;&lt;div ng-hide=\"flag\"&gt; &lt;!--绑定标题--&gt; &lt;h1 ng-bind=\"data.title\"&gt;&lt;/h1&gt; &lt;div class=\"list\" ng-repeat=\"movie in data.subjects | filter: info \"&gt; &lt;!--遍历data.subjects数据--&gt; &lt;a href=\"#!/details/&#123;&#123;movie.id&#125;&#125;\" &gt; &lt;dl&gt; &lt;!--绑定图片--&gt; &lt;dt&gt;&lt;img src=\"&#123;&#123;movie.images.small&#125;&#125;\" alt=\"\"&gt;&lt;/dt&gt; &lt;dd&gt; &lt;!--绑定电影名字--&gt; &lt;h4 ng-bind=\"movie.title\"&gt;&lt;/h4&gt; &lt;!--绑定类型--&gt; &lt;p&gt;类型:&lt;span ng-repeat=\"genres in movie.genres\" ng-bind=\"genres+','\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;!--电影导演--&gt; &lt;p &gt;导演:&lt;span ng-bind=\"movie.directors[0].name\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;!--主演--&gt; &lt;p&gt;主演:&lt;span ng-repeat=\"casts in movie.casts\" ng-bind=\"casts.name+','\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;!--地区--&gt; &lt;p&gt;上演时间:&lt;span ng-repeat=\"pubdates in movie.pubdates\" ng-bind=\"pubdates+','\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;时长:&lt;span ng-bind=\"movie.durations[0]\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;/dd&gt; &lt;span class=\"score\" ng-bind=\"movie.rating.average\"&gt;&lt;/span&gt; &lt;/dl&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"page\"&gt; &lt;a ng-click=\"prev()\"&gt;上一页&lt;/a&gt; &lt;a ng-click=\"next()\"&gt;下一页&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; &lt;div ng-show=\"flag\" style=\"text-align: center\"&gt; &lt;img ng-src=\"loading.gif\" alt=\"\" &gt;&lt;/div&gt;&lt;div ng-hide=\"flag\"&gt; &lt;h1 ng-bind=\"data.alt_title\"&gt;&lt;/h1&gt; &lt;div class=\"detail_content\"&gt; &lt;dl class=\"detail_dl\"&gt; &lt;dt&gt;&lt;img ng-src=\"&#123;&#123;data.image&#125;&#125;\" width=\"300px\" height=\"400px\"&gt;&lt;/dt&gt; &lt;dd&gt; &lt;p&gt;类型: &lt;span ng-repeat=\"type in data.attrs.movie_type\" ng-bind=\"type+','\"&gt;&lt;/span&gt;&lt;/p&gt; &lt;p&gt;导演: &lt;span ng-repeat=\"author in data.author\" ng-bind=\"author.name\"&gt;&lt;/span&gt; &lt;/p&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;div ng-bind=\"data.summary\"&gt;&lt;/div&gt;&lt;/div&gt;总结:angular是一个模块化的开发过程,我们把不同的需求放到不同的模块来实现功能,并且我们全程无需操作dom元素.都是通过数据进行传送,虽然是一个简单的应用,但也很好的把angualr当中几个很重要的功能结合到一起,像内置命令,依赖注入,服务,控制器,配置等等,把核心的功能结合到一起.对加深angular的理解又更进一步了. 效果","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"Angular学习之旅","date":"2016-04-08T12:11:00.000Z","path":"2016/04/08/Angular学习之旅/","text":"谷歌推出的angular,数据驱动,模块化!值得学习 angular介绍1谷歌推出的一个框架,一个模块化,数据驱动,简化开发流程,更好的管理代码. 基本使用步骤创建模块1234提供了一个一个全局对象angular,调用module()方法第一个参数：模块名称，第二个参数：依赖模块名称var app = angular.module('app',[]); 创建控制器1234567控制器作为连接模型和视图的桥梁存在第一个参数：控制器的名称，第二个参数：依赖的服务 app.controller('lbmControler',['$scope',function ($scope) &#123; 创建数据 //$scope.name='lbm' &#125;]); 绑定模块12只需要绑定一个,一般在body或者html上&lt;body ng-app=\"app\"&gt; 绑定控制器12一个控制器绑定一个元素,绑定了控制器的元素,里面的视图的数据可从模型获得&lt;ul ng-controller=\"lbmControler\"&gt; 内置指令作用1通过扩展一系列的html属性来弥补在构建app时的不足,以ng-做为前缀 常用内置指令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182ng-app 指定应用根元素，至少有一个元素指定了此属性。ng-controller 指定控制器ng-show控制元素是否显示，true显示、false不显示ng-hide控制元素是否隐藏，true隐藏、false不隐藏ng-if控制元素是否“存在”，true存在、false不存在ng-src增强图片路径ng-href增强地址ng-class控制类名ng-include引入模板ng-disabled表单禁用ng-readonly表单只读ng-checked单/复选框表单选中ng-selected下拉框表单选中例子&lt;script&gt; 内置指令:angular开始为html内置好的一些特定功能的属性标签. 当解析到ng代码时， 会回头到html当中解析自己的指令。 var app = angular.module('app',[]); app.controller('lbmControler',['$scope',function ($scope) &#123; 在模型上绑定数据 $scope.isShow = 1; $scope.path = \"image/03.jpg\"; $scope.name = \"lbm\"; $scope.active = false; $scope.sty = &#123; 'font-size': '30px' &#125;; &#125;]);&lt;/script&gt;&lt;body ng-app=\"app\" ng-controller=\"lbmControler\"&gt;它的做法，其它就是把把样式display:none&lt;p ng-show=\"isShow\"&gt;ng-show 控制标签是否显示&lt;/p&gt;ng-hide控制标签是否隐藏 取值为bool （true/false 1/0）&lt;p ng-hide=\"false\"&gt;ng-hide控制标签是否隐藏 取值为bool （true/false 1/0）&lt;/p&gt;ng-if控制标签是否存在 取值为bool （true/false 1/0&lt;p ng-if=\"false\"&gt;ng-if控制标签是否存在 取值为bool （true/false 1/0）&lt;/p&gt;使用ng-src加载图片&lt;img ng-src=\"&#123;&#123;path&#125;&#125;\" alt=\"\"&gt;使用ng-href跳转&lt;a ng-href=\"#\"&gt;&lt;/a&gt;ng-class指令 ，控制是否添加某个类 为true为添加,为false不添加&lt;p ng-class=\"&#123;red:active,font:true&#125;\"&gt;ng-class指令 ，控制是否添加某个类&lt;/p&gt;给当前标签手动添加样式&lt;p ng-style=\"sty\"&gt;ng-style 控制样式&lt;/p&gt;ng-include 它的本质是发送了一个aJax请求，把请求的结果，放入对应标签里边。,实现模块的复用&lt;div ng-include=\"'./head.html'\"&gt;&lt;/div&gt;&lt;div ng-include=\"'./body.html'\"&gt;&lt;/div&gt;&lt;div ng-include=\"'./foot.html'\"&gt;&lt;/div&gt;控制表单是否可用 值为bool类型&lt;input type=\"text\" ng-disabled=\"true\"&gt;控制表单为只读属性&lt;input type=\"text\" value=\"ng-readonly\" ng-readonly=\"true\"&gt;设置复选框为选中状态&lt;input type=\"checkbox\" ng-checked=\"true\"&gt;ng-switch=“筛选对象\"ng-switch-when=“筛选对象的值.如果筛选对象的值与该值相同,那么该值所在的标签就显示,否则就隐藏”&lt;ul ng-controller=\"lbmControler\"&gt; &lt;li ng-repeat=\"value in course\" ng-switch=\"value\"&gt; &lt;!--对&#123;&#123;value&#125;&#125; 进行判断，when就是条件。满足条件，就显示出来。否则就隐藏 --&gt; &lt;p ng-switch-when=\"css\"&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt;&lt;/body&gt; 数据单向绑定作用1数据单向绑定：把模型的数据展示到视图当中 绑定方式12345678910111213141.使用插值语法:&#123;&#123;模型属性&#125;&#125; 加载时，-&gt;会造成闪烁。可以使用ng-cloak来避免闪烁2.使用ng-bind:ng-bind=“模型属性” -&gt;不会造成闪烁, 只能绑定一个属性3.使用ng-bind-template=“&#123;&#123;模型属性&#125;&#125;,&#123;&#123;模型属性&#125;&#125;”-&gt;可以绑定多值, 不会闪烁使用&#123;&#123;&#125;&#125; 可以把模型的数据绑定到视图当中 加载时，会造成闪烁。 &lt;li&gt;&#123;&#123;name&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/li&gt; &lt;li ng-cloak&gt;&#123;&#123;name&#125;&#125;&#123;&#123;age&#125;&#125;&lt;/li&gt; 数据绑定 不会造成闪烁 没有办法绑定多个属性 &lt;li ng-bind=\"name\"&gt;&lt;/li&gt; 可以绑定多个数据。 不会造成闪烁 &lt;li ng-bind-template=\"&#123;&#123;name&#125;&#125;&#123;&#123;age&#125;&#125;\"&gt;&lt;/li&gt; 数据双向绑定作用12345视图的数据可以绑定到模型当中,模型的数据可以绑定到视图当中.想要实现视图的数据绑定到模型当中必须得要借助表单才行在表单当中使用ng-model指令.在input标签当中绑定属性. 方式123456789101112131415视图中的usname和pwd和传送数据到模型里面&lt;input type=\"text\" ng-model=\"userName\"&gt;&lt;input type=\"password\" ng-model=\"pwd\"&gt;&lt;button ng-click=\"login()\"&gt;登录&lt;/button&gt;&lt;script&gt; var app = angular.module('app',[]); app.controller('lbmControler',['$scope',function ($scope) &#123; 在模型当定义name属性 $scope.name = \"登录\" 事件的实现 $scope.login = function () &#123; alert($scope.userName+$scope.pwd); &#125;; &#125;]);&lt;/script&gt; 事件处理1234567事件名字就是原生具有的click,mouseover之类使用方法为:ng-事件名称 = “事件响应方法名称( 参数)\" 参数可以自己指定, 也可以传入事件对象$event使用$scope来去实现事件定义的方法 $scope.事件名称 = function(参数)&#123; &#125; 自定义指令1234567891011121314151617181920212223通过全局对象下的directive方法实现 自定义指令: 第一个参数 指令名称 第二个参数:回调函数 app.directive('nav',[function () &#123; return&#123; E:元素 A:属性 C:当做类 M:可以注释形式出 restrict:'EA', template:'&lt;ul&gt;&lt;li&gt;列表&lt;/li&gt;&lt;li&gt;列表&lt;/li&gt;&lt;li&gt;列表&lt;/li&gt;&lt;/ul&gt;', //templateUrl:'./nav.html', replace:true 是否替换原标签 &#125; &#125;]); app.directive('navHead',[function () &#123; return&#123; restrict:'EA', /*以什么形式出现。*/ //template:'&lt;ul&gt;&lt;li&gt;列表&lt;/li&gt;&lt;li&gt;列表&lt;/li&gt;&lt;li&gt;列表&lt;/li&gt;&lt;/ul&gt;', templateUrl:'./nav.html', replace:true /*是否替换原标签*/ transculde:true /*是否保留原有数据*/ &#125; &#125;]); 过滤器内置过滤器12345678910111213141516171819配合管道符使用 |1、currency:将数值格式化为货币格式2、date:日期格式化，年（y）、月（M）、日（d）、星期（EEEE/EEE）、时（H/h）、分（m）、秒（s）、毫秒（.sss），也可以组合到一起使用。3、filter:在给定数组中选择满足条件的一个子集，并返回一个新数组，其条件可以是一个字符串、对象、函数4、json:将Javascrip对象转成JSON字符串。5、limitTo:取出字符串或数组的前（正数）几位或后（负数）几位6、lowercase:将文本转换成小写格式7、uppercase:将文本转换成大写格式8、number:数字格式化，可控制小位位数9、orderBy:对数组进行排序，第2个参数可控制方向&lt;p&gt;&#123;&#123;price|currency:'&amp;'&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;nowDate|date:'yyyy/MM/dd h:m:s'&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;course|filter:'s'&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;student|json&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;student|limitTo:-2&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;str|uppercase|lowercase&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;student|orderBy:'age':false&#125;&#125;&lt;/p&gt; true 是降序，false是升序&lt;p&gt;&#123;&#123;num|number:2&#125;&#125;&lt;/p&gt; 在num当中不能出现非数字 自定义过滤器1234567891011121314151617181920通过全局对象下的filter方法来定义自定义过滤器 第一个参数:过滤器的名称 第二个参数:回调函数 返回值为一个函数(input 为自动传入的数据,它为管道符前面的内容) app.filter('filterName',[function () &#123; return function (input) &#123; console.log('hello'+ input); &#125; &#125;]); app.filter('firstUppcase',[function () &#123; return function (input) &#123; slice:从指定的位置，截取到末尾 return input[0].toUpperCase()+input.slice(1) &#125;; &#125;]);&lt;p&gt;&#123;&#123;name|filterName&#125;&#125;&lt;/p&gt;&lt;p&gt;&#123;&#123;str|firstUppcase&#125;&#125;&lt;/p&gt; 依赖注入1234AngularJS采用模块化的方式组织代码，将一些通用逻辑封装成一个对象或函数，实现最大程度的复用这导致了使用者和被使用者之间存在依赖关系。所谓依赖注入是指在运行时自动查找依赖关系然后将查找到依赖传递给使用者的一种机制。 2种方式12345678910111213141516171.行内式注入 以数组形式明确声明依赖，数组元素都是包含依赖名称的字符串，数组最后一个元素是依赖注入的目标函数 推荐使用行内式注入.2.推断式注入 没有明确声明依赖，AngularJS会将函数参数名称当成是依赖的名称 这种方式会带来一个问题，当代码经过压缩后函数的参数被压缩，这样便会造成依赖无法找到。app.controller('lbmController',['$scope','$http',function ($scope,$http) &#123; $scope.name = \"121\"; $scope.str = \"hello\"; &#125;]); 2.推断式注入 根据函数的形参去推断查找服务 app.controller('lbmController',function ($scope,$http) &#123; $scope.name = 'xmg'; &#125;); 常见内置服务123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566$scope: 用来定义变量,传输数据给视图$location: 查看一些类似主机名,端口号,锚点 $scope.url = $location.url(); 端口号 $scope.port = $location.port(); 主机名 $scope.host = $location.host(); 获取的锚点。从第二个锚点开始的值。 $scope.hash = $location.hash();$timeout和$interval: 单次定时器和多次定时器 $interval.cancel(timer);关闭定时器$filter: 我们不想在视图处理过多业务,使用这个服务var currency = $filter('currency');$scope.price = currency($scope.price);$log服务 在控制台打印信息 $log.log('信息'); $log.info('信息'); $log.warn('信息'); $log.error('信息'); $log.debug('信息');$http服务 用来发送Ajax请求 get请求 $http(&#123; url: 'get.php', 请求地址 method:'get', 请求方式 params:&#123; get方式传递参数 在传递过程当中 会自动帮你转成 get.php?name=xmg 传递时-&gt;name:xmg name:'xmg' &#125; &#125;).success(function (res) &#123; alert(res); 成功时回调 &#125;).error(function(error)&#123; 失败时回调 &#125;); post请求 $http(&#123; url: 'post.php', 请求地址 method:'post', 请求方式 post必须得要设置请求头 headers:&#123; 'Content-Type':'application/x-www-form-urlencoded' &#125;, data:'name=xmg&amp;age=123' &#125;).success(function (res) &#123; alert(res); &#125;).error(function (res) &#123; &#125;); 跨域请求 $http(&#123; url:'http://api.douban.com/book/subjects', method:'jsonp', params:&#123; 'q': $scope.msg, 'alt':'xd', callback:'JSON_CALLBACK', 'max-results':10, 'start-index':10 &#125; &#125;).success(function (res) &#123; 自定义服务factory12345678910111213141516171819app.factory('show',function () &#123; return function () &#123; 直接以方法来调用。 alert(\"hello\"); &#125;; function show1() &#123; alert(\"show1\"); 逻辑 &#125; function show2() &#123; alert(\"show2\"); &#125; return &#123; show1:show1, show2:show2 &#125;&#125;); service服务12345678910111213app.service('showTime',['$filter',function ($filter) &#123; 里面所有的功能要使用this来定义 this.cur_date = function () &#123; var cur_date = new Date(); var date = $filter('date'); return date(cur_date,'yyyy-MM-dd h:m:s'); &#125;; this.sayHello = function () &#123; alert(\"hello world\"); &#125; &#125;]); value服务1234value 表现形式上是一个服务本质上可看做是一个常量。app.value('version','1.0’);app.value('key','xmg'); 配置块1234567891011121314151617通过config方法实现对模块的配置，AngularJS中的服务大部分都对应一个“provider”，用来执行与对应服务相同的功能或对其进行配置,相对应的“provider”分别是$logProvider、$httpProvider、$locationPorvider。//开启和禁用 调用config方法app.config(['$logProvider',function ($logProvider) &#123; $logProvider.debugEnabled(false); &#125;]);//配置过滤内置功能 调用register方法app.config(['$filterProvider',function ($filterProvider) &#123; $filterProvider.register('firstUpp',function () &#123; 可以在配置过程当中,给过滤器添加过滤功能 return function (input) &#123; return input[0].toUpperCase() + input.slice(1); &#125; &#125;) &#125;]); 运行块123AngularJS提供了run方法来实现。run方法还是最先执行的，利用这个特点我们可以将一些需要优先执行的功能通过run方法来运行比如验证用户是否登录，未登录则不允许进行任何其它操作 单页面应用程序(spa)1234SPA（Single Page Application）指的是通单一页面展示所有功能，通过Ajax动态获取数据然后进行实时渲染，结合CSS3动画模仿原生App交互，然后再进行打包（使用工具把Web应用包一个壳，这个壳本质上是浏览器）变成一个“原生”应用。实现单页面应用需要具备：a、只有一页面b、链接使用锚点 路由必要东西,①angular-route.js文件②[‘ngRoute’]依赖模块名字③配置路由$routeProvider④调用when方法 routeProvider.when(‘/index/:id’)⑤ng-view展示路由数据⑥控制器的服务$routeParams.id,拿到when的形参 12345678910111213141516171819202122232425262728293031323334353637383940414243444546在angular当中路由就是锚点用来做单页面应用程序的切换。锚点的变化，我们又称为路由的变化。路由在angular当中属于单独的一个模块。帮你监听锚点的跳转，它就是路由。&lt;script src=\"angular-route.js\"&gt;&lt;/script&gt;&lt;script&gt;在创建模块时，注入路由模块var app = angular.module('app',['ngRoute']);配置路由。让路由帮你去监听哪些锚点的变化。app.config(['$routeProvider',function ($routeProvider) &#123; 当锚点为指定值时， 帮你处理相应的逻辑 路由规定，在锚点之前， 加上一个\"/\" $routeProvider.when('/index',&#123; 可以外链一个模板,指定控制器 // templateUrl:'template/music_tpl.html', // controller:'musicController' template:\"&lt;h1&gt;首页&lt;/h1&gt;\" &#125;) .when('/music',&#123; template:\"&lt;h1&gt;音乐&lt;/h1&gt;\" &#125;) .when('/singer',&#123; template:\"&lt;h1&gt;首页&lt;/h1&gt;\" &#125;) //默认显示哪一个 .otherwise(&#123; redirectTo:'/index' &#125;) &#125;]); &lt;/script&gt;&lt;div class=\"nav\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#/index\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/music\"&gt;音乐&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/singer\"&gt;歌手&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; ng-view 把内容展示&lt;div class=\"content\" ng-view&gt; 路由传参数加发送请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script src=\"angular.js\"&gt;&lt;/script&gt;&lt;script src=\"angular-route.js\"&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module('app',['ngRoute']); 配置路由 app.config(['$routeProvider',function ($routeProvider) &#123; $routeProvider.when('/index/:id’,&#123;传参 templateUrl:'template/musicList_tpl.html', controller:\"musicControler\" &#125;).otherwise(&#123; redirectTo:'/index/1' &#125;) &#125;]); 定义控制器 app.controller('musicControler',['$routeParams','$http','$scope',function ($routeParams,$http,$scope) &#123; console.log($routeParams.id); $http(&#123;访问地址 url:'listMusic.php', method:'get', params:&#123; id:$routeParams.id &#125; &#125;).success(function (res) &#123; 把获取的结果赋值给模型 $scope.musicList = res; &#125;) &#125;]);&lt;/script&gt;&lt;body ng-app=\"app\"&gt;&lt;div class=\"nav\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#/index/1\"&gt;流行&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/index/2\"&gt;复古&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#/index/3\"&gt;欧美&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=\"content\" ng-view&gt;&lt;/div&gt; 1.6angular版本$http和路由1234567891011121314取消了success和error方法 用then catch代替锚点以这种形式&lt;li&gt;&lt;a href=\"#!/index/1\"&gt;首页&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#!/music\"&gt;音乐&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=\"#!/singer\"&gt;歌手&lt;/a&gt;&lt;/li&gt;跨域需要设置白名单.config(['$sceDelegateProvider',function ($sceDelegateProvider) &#123; 设置白名单 $sceDelegateProvider.resourceUrlWhitelist([ 'self', 'http://localhost/api/**' ]);&#125;]); $watch监听$broadcast,$on $emit 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475$watch监听方法&lt;script src=\"angular.js\"&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module('app',[]); app.controller('xmgController',['$scope',function ($scope) &#123; 如果是一个对象。在监听时，要在最后添加一个参数：true 如果不添加，是监听不到的。 默认情况，对象监听是地址。 对象值修改了， 地址没有改变。 var count = 0; var unWatch = $scope.$watch('persion.age',function (newValue,oldValue) &#123; console.log('新值：'+ newValue+'旧值：'+oldValue); count++; if (count &gt; 5)&#123; 取消监听 unWatch(); &#125; &#125;,true); &#125;]);&lt;/script&gt;&lt;body ng-app=\"app\" ng-controller=\"xmgController\"&gt;&lt;input type=\"text\" ng-model=\"persion.age\"&gt;&lt;/body&gt;$broadcast,$on $emit 方法&lt;script src=\"angular.js\"&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module('app',[]); app.controller('xmgController',['$scope',function ($scope) &#123; $scope.names = \"父级的名字\"; 发送广播 发送广播时，一定要等指令加载完毕之后，才去发送广播 $scope.click = function () &#123; $scope.$broadcast('aaa',&#123;id:1&#125;) &#125;; 监听广播 $scope.$on('bbbb',function ($event,data) &#123; console.log(data); &#125;); &#125;]); app.directive('tag',[function () &#123; return &#123; restrict:'EA', template:\"&lt;h1 ng-click='tagClick()'&gt;子级自定义指令&lt;/h1&gt;\", replace:true, controller:function ($scope) &#123; 监听广播 $scope.$on('aaa',function ($event,data) &#123; console.log(data); &#125;); $scope.tagClick = function () &#123; 向上级冒泡一个事件 $scope.$emit('bbbb',&#123;name:'xmg'&#125;); &#125; &#125; &#125; &#125;]);&lt;/script&gt;&lt;body ng-app=\"app\" ng-controller=\"xmgController\"&gt;&lt;button ng-click=\"click()\"&gt;广播&lt;/button&gt;&lt;div tag&gt;&lt;/div&gt;&lt;/body&gt; $degist()和$apply()1234每一次在界面上,绑定一个数据时就会把对应的属性添加到一个叫$watchList数组中,里面的属性会被$watch监听,一直处于监听事件状态只要发生了事件,就会触发$degist事件,它会遍历$watchList数组,询问每一个属性有没有被更改过,再去查看$scope有没有更新,如果有更新,再次遍历$watchList,遍历结束,会调用$apply()更新DOM节点里面数据.脏值检测,$degist遍历$watchList的过程在网络请求中,因为可能出现延时效果,所以有时候需要手动调用$apply方法来让数据展示到dom节点中! 指令的作用域1默认情况下,指令的控制器和父级的控制器是一致的,是同一个作用域,修改任何一个作用域都会互相影响,所以可以设置scope属性来控制,默认情况scope为false,当设置为true的时候,会各自使用自己控制器里面的作用域,不过当自己没找到的时候,还是会跑到父级去寻找,当为一个对象的时候,则会独立出来一个作用域 @修饰符12345scope:'@'外界传递参数时，使用&#123;&#123;&#125;&#125;来传递 &lt;xmg content=\"&#123;&#123;content&#125;&#125;\" my-title=\"&#123;&#123;title&#125;&#125;\"&gt;&lt;/xmg&gt;特点:属于单向传递,如果外界修改了,则内部也会跟着修改,如果内部修改了,外部不会修改,如果内部当中有一样的属性,则外部的属性会覆盖内部的属性 =修饰符1234567scope:'='不需要&#123;&#123;&#125;&#125; 直接在后面写上要传递数据即可 格式：&lt;xmg content=\"content\" my-title=\"title\"&gt;&lt;/xmg&gt;特点:属于双向的传递,无论哪一边进行更改,都会受到影响.外部的属性会覆盖内部的属性 &amp;修饰符1234外界传入方法(函数)进来scope:&#123; click:'&amp;'&#125; link1234567用来操作dom元素,属于jqlite对象里面有三个参数 link:function ($scope,ele,attr) &#123; @param $scope 就是控制器当中的模型 * @param ele 指令所在的dom元素。注意：它是一个jQlite对象 * @param attr 指令身上绑定的所有属性 &#125; ui-router路由基本使用ui-router弥补了原生路由的不足,例如多视图的嵌入.或者一些方法封装1234567891011121314151617181920212223242526272829303132333435&lt;script src=\"angular-ui-router.js\"&gt;&lt;/script&gt;//依赖ui.router服务 var app = angular.module('app',['ui.router']);//配置路由 app.config(['$stateProvider','$urlRouterProvider',function ($stateProvider,$urlRouterProvider) &#123; $stateProvider.state('home',&#123; url:'/index', template:\"&lt;h1&gt;首页&lt;/h1&gt;\", controller:\"xmgController\" &#125;) .state('music',&#123; url:'/music', template:\"&lt;h1&gt;音乐&lt;/h1&gt;\", controller:\"xmgController\" &#125;) .state('singer',&#123; url:'/singer', template:\"&lt;h1&gt;歌手&lt;/h1&gt;\", controller:\"xmgController\" &#125;) $urlRouterProvider.otherwise('index'); &#125;]); state的第一个参数和对应点击的ui-sref要一致 ui-sref代替了a标签的href属性,也是用来当作锚点,ui-sref-active让我们绑定啦,点击哪一个改变样式&lt;ul&gt; ui-sref-active=“active\" 如果选中当前的路由,就会给该标签添加class类 ui-sref=“home” 跳转路由 &lt;li ui-sref-active=\"active\" ui-sref=\"home\"&gt;&lt;a&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li ui-sref-active=\"active\" ui-sref=\"music\"&gt;&lt;a&gt;音乐&lt;/a&gt;&lt;/li&gt; &lt;li ui-sref-active=\"active\" ui-sref=\"singer\"&gt;&lt;a&gt;歌手&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 最后通过ui-view去展示对应的模板&lt;div class=\"content\" ui-view&gt; 多视图1234567891011121314151617181920212223242526272829多一个页面可以进行锚点的跳转app.config(['$stateProvider','$urlRouterProvider',function ($stateProvider,$urlRouterProvider) &#123; $stateProvider.state('index',&#123; url:\"/\", views:&#123; header:&#123; template:\"&lt;h1&gt;头部&lt;/h1&gt;\" &#125;, left:&#123; template:\"&lt;h1&gt;左侧&lt;/h1&gt;\" &#125;, right:&#123; template:\"&lt;h1&gt;右侧&lt;/h1&gt;\" &#125; &#125; &#125;) $urlRouterProvider.otherwise('/');&#125;]);上面配置views参数写上对应的参数,下图使用ui-view=对应的参数来绑定&lt;div class=\"header\" ui-view=\"header\"&gt;&lt;/div&gt;&lt;div class=\"content\"&gt; &lt;div class=\"left\" ui-view=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\" ui-view=\"right\"&gt;&lt;/div&gt;&lt;/div&gt; 传参12345678910111213141516171819202122232425262728293031323334通常使用url:/music/:id 方法传参app.config(['$stateProvider','$urlRouterProvider',function ($stateProvider,$urlRouterProvider) &#123; $stateProvider.state('home',&#123; url:'/index/:id', url:'/index/&#123;id:int&#125;', url:'/index/?id&amp;name', template:\"&lt;h1&gt;首页&lt;/h1&gt;\", controller:\"xmgController\" &#125;) .state('music',&#123; url:'/music/:id', template:\"&lt;h1&gt;音乐&lt;/h1&gt;\", controller:\"xmgController\" &#125;) .state('singer',&#123; url:'/singer/:id', template:\"&lt;h1&gt;歌手&lt;/h1&gt;\", controller:\"xmgController\" &#125;) $urlRouterProvider.otherwise('index/1');通过$stateParams来获取路由的参数app.controller('xmgController',['$scope','$stateParams',function ($scope,$stateParams) &#123; console.log($stateParams); &#125;]);通过ui-sref=\"home&#123;&#123;id:1&#125;&#125;\"来进行传参数&lt;ul&gt; &lt;li ui-sref-active=\"active\" ui-sref=\"home(&#123;id:1&#125;)\"&gt;&lt;a&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li ui-sref-active=\"active\" ui-sref=\"music(&#123;id:2&#125;)\"&gt;&lt;a&gt;音乐&lt;/a&gt;&lt;/li&gt; &lt;li ui-sref-active=\"active\" ui-sref=\"singer(&#123;id:3&#125;)\"&gt;&lt;a&gt;歌手&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 子路由12345678910111213141516171819202122 字路由的参数在父的基础上加上. 例如父 home 子home.list 对应的按钮ui-sref和state第一个参数一样 .config(['$stateProvider','$urlRouterProvider',function ($stateProvider,$urlRouterProvider) &#123; $stateProvider.state('home',&#123; url:'/home', templateUrl:\"../view/home_tpl.html”, 在一个模板当中再放入一个路由占位符 controller:\"homeController\" &#125;).state('home.list',&#123; url:'/list', template:\"&lt;div list-view&gt;&lt;/div&gt;\", controller:\"homeController\" &#125;).state('home.detail',&#123; url:'/detail/:id', templateUrl:'../view/template/detail_tpl.html', controller:\"detailController\" &#125;) $urlRouterProvider.otherwise('home');&#125;])默认子路由angular.module('app').controller('homeController',['$scope','httpTool','$state',function ($scope,httpTool,$state) &#123; 设置默认子路由 $state.go('home.list');&#125;]); angular简单应用通过跨域访问别人的数据,然后获取数据进行展示,根据数据的多少进行分页设置.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;body ng-app=\"app\" ng-controller=\"lbmController\"&gt;&lt;form action=\"\" ng-click=\"send()\"&gt; &lt;input type=\"text\" ng-model=\"msg\"&gt; &lt;input type=\"button\" value=\"搜索\"&gt;&lt;/form&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;书名&lt;/li&gt; &lt;li&gt;作者&lt;/li&gt; &lt;li&gt;图片&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"box\"&gt; &lt;ul ng-repeat=\"(key,value) in res\" class=\"clearfix\"&gt; &lt;li&gt;&#123;&#123;res[key].title.$t&#125;&#125;&lt;/li&gt; &lt;li&gt;&#123;&#123;res[key].author[0].name.$t&#125;&#125;&lt;/li&gt; &lt;li &gt;&lt;img ng-src=\"&#123;&#123;res[key].link[2]['@href']&#125;&#125;\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;div class=\"tcdPageCode\"&gt;&lt;/div&gt;&lt;!--//http://api.douban.com/book/subjects?q='+oQ.value+'&amp;alt=xd&amp;callback=fn1&amp;start-index=(当前页*每页显示的条数)&amp;max-results=10(每页显示的条数)--&gt;&lt;script src=\"jQueryPager20160918/js/jquery-1.8.3.min.js\"&gt;&lt;/script&gt;&lt;script src=\"jQueryPager20160918/js/jquery.page.js\"&gt;&lt;/script&gt;&lt;script src=\"angular.js\"&gt;&lt;/script&gt;&lt;script&gt; angular.module('app',[]).controller('lbmController',['$scope','$http',function ($scope,$http) &#123; $scope.msg=''; $scope.arr=[]; $scope.send=function ()&#123; $http(&#123; url:'http://api.douban.com/book/subjects', method:'jsonp', params:&#123; 'q': $scope.msg, 'alt':'xd', callback:'JSON_CALLBACK', 'max-results':10, 'start-index':10 &#125; &#125;).success(function (res) &#123; $scope.total=res['opensearch:totalResults'].$t; $scope.maxPage=res['opensearch:itemsPerPage'].$t; var page=parseInt( $scope.total/$scope.maxPage); $(\".tcdPageCode\").createPage(&#123; pageCount:page, current:1, backFn:function(p)&#123; $http(&#123; url:'http://api.douban.com/book/subjects', method:'jsonp', params:&#123; 'q': $scope.msg, 'alt':'xd', callback:'JSON_CALLBACK', 'max-results':10, 'start-index':p*10 &#125; &#125;).success(function (res) &#123; $scope.res=res['entry']; &#125;).error(function (err) &#123; &#125;) &#125; &#125;); $scope.res=res['entry']; console.log(res); &#125;).error(function (err) &#123; console.log(err); &#125;) &#125; &#125;])&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"Bootstrap应用布局(二)","date":"2016-04-06T10:50:00.000Z","path":"2016/04/06/Bootstarp-应用布局(二)详解/","text":"详解详解,详细介绍如何运用bootstrap进行布局利用bootstrap进行网页布局,里面用到了最常见的几个方法.我将一步步分析每一个地方的做法.再也不用担心面试被问到bootstrap咯 介绍这是一个瞎搞瞎弄得网站,没有设计,没有审美的网站.你信不信? 那你必须不要信,这是一个炫酷的,可运行在pc,手机的一个响应式网站.但你看到这段话你就是一个会设计的程序员啦.(以下所有图片效果都是在浏览器运行,拉伸屏幕宽度而来的) head标签内容介绍ie告诉浏览器以哪一个版本的解析器去解析,主要兼容ie,让低版本ie可使用h5的标签,让低版本的ie支持响应式.12345&lt;!--[if lt IE 9]&gt; &lt;script src=\"lib/html5shiv/html5shiv.min.js\"&gt;&lt;/script&gt; &lt;script src=\"lib/respond/respond.min.js\"&gt;&lt;/script&gt; &lt;![endif]--&gt;&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; 视口规定在手机端运行的一些规范1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt; 站点图标设置站点图标1&lt;link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"favicon.ico\"&gt; 头部头部原理很简单,主要用到了bootstrap的栅格布局,我把它分成了4块,对应的类就是,.col-md-* 因为我头部只需要在中等屏幕以上才进行处理,中等屏幕以下会把它隐藏,所以还需要用到 hidden-sm hidden-xs两个类然后头部内容居中用到 text-center这个类 ,颜色用到text-muted这个类 具体代码效果如下 布局代码123456789101112131415161718192021222324252627&lt;!--顶部通栏--&gt; &lt;div class=\"top-bar text-center text-muted hidden-xs hidden-sm\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"top-bar-1 col-md-2\"&gt; &lt;a href=\"javascript:;\" class=\"text-muted\"&gt; &lt;i class=\"icon-phone\"&gt;&lt;/i&gt; &lt;span&gt;手机游戏APP&lt;/span&gt; &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;img src=\"img/c_06.jpg\" class=\"e-code\" width=\"120\" height=\"136\"&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"top-bar-2 col-md-5\"&gt; &lt;i class=\"icon-tel\"&gt;&lt;/i&gt; &lt;span&gt;4006-89-4006（服务时间：不上班）&lt;/span&gt; &lt;/div&gt; &lt;div class=\"top-bar-3 col-md-2\"&gt; &lt;a href=\"javascript:;\" class=\"text-muted\"&gt;常见问题&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"text-muted\"&gt;BUG提交&lt;/a&gt; &lt;/div&gt; &lt;div class=\"top-bar-4 col-md-3\"&gt; &lt;a class=\"btn btn-sm btn-register\" href=\"#\" role=\"button\" data-toggle=\"modal\" data-target=\"#btnLogin\"&gt;免费注册&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"text-muted\" style=\"margin-left: 10px;\"&gt;立即登录&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 效果中等屏幕以上自适应中等屏幕以下消失 导航栏导航条主要原理是,用到了bootstrap的导航条样式,其最主要功能是当在超小屏幕的时候,会把导航条内容集中到一个按钮上,当你点击按钮的时候会把内容垂直居中的展示出来,注意按钮绑定的id要和对应内容的id一致才可以.这里用到了字体图标i 主要通过i的伪类创建字体图标,主体用法看代码,后面所用到字体图标方法都一样,这里我需要导航栏固定在顶部,用到了js插件的affix 给导航栏添加 data-spy=”affix” data-offset-top=”60” 这样属性,注意我们需要让导航栏的top设置为零,宽度为100%,具体看代码.另外有一个li除了大屏幕显示,其余都消失,所以添加了hidden-xs hidden-sm hidden-md 3个类 字体图标方法给font-family:’’起一个名字后面代码放你字体图标的文件路劲,format作用主要用于兼容,给i起一个类名,类名为对应字体图标的名字12345678910111213声明@font-face &#123; font-family: 'xmg'; src: url('../fonts/MiFie-Web-Font.eot') format('embedded-opentype'), url('../fonts/MiFie-Web-Font.svg') format('svg'), url('../fonts/MiFie-Web-Font.ttf') format('truetype'), url('../fonts/MiFie-Web-Font.woff') format('woff');&#125;创建字体图标.icon-phone::before&#123; content: '\\e908'; font-size: 13px;&#125; affix找到导航栏,要添加以下样式,当然,如果你导航栏本身就在顶部,可以不用设置top和left.123width: 100%; top: 0; left: 0; 布局代码12345678910111213141516171819202122232425262728293031&lt;!--导航栏--&gt; &lt;nav class=\"navbar navbar-default navbar-xmg navbar-static-top\" data-spy=\"affix\" data-offset-top=\"60\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#wjs_nav\" aria-expanded=\"false\"&gt; &lt;span class=\"sr-only\"&gt;Toggle navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;a class=\"navbar-brand\" href=\"#\"&gt; &lt;i class=\" glyphicon glyphicon-piggy-bank\" style=\"font-size: 50px\"&gt;&lt;/i&gt; &lt;span style=\"position: relative;top: -15px;\"&gt;小猪游戏中心&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"collapse navbar-collapse\" id=\"wjs_nav\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;新手区&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;游戏介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;游戏视频&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;充值&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;小猪游戏值得你拥有&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=\"nav navbar-nav navbar-right hidden-xs hidden-sm hidden-md\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;个人中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/nav&gt; 效果大屏幕以下个人中心消失,超小屏幕只留一个logo,内容集成到右边按钮,点击按钮会展开内容,而且会一直置顶 轮播图轮播图主要用到js轮播图插件,代码基本固定,不过说一说思路,因为要放在pc端和手机端运行,所以图片是不能一直缩放,这样效果不好,所以具体思路是在中等屏幕以上使用大图片作为背景图,当屏幕为中等屏幕以下就立即使用小图片,大图片设置为背景,且永远居中,高度固定不变,宽度跟随屏幕改动,小图片跟随屏幕进行缩放,有2个中方法实现,一个通过js,一个通过css方法,这里两种方法我都写上 css写法当宽度为750以上时候让大图片高度固定,小图片隐藏,一旦当宽度小于750,就会使用小图片进行缩放.达到了很好效果.12345678910111213141516171819202122232425@media screen and (min-width: 750px)&#123; #wjs_carousel .item div&#123; height: 410px; &#125; #wjs_carousel .item div img&#123; display: none; &#125;&#125;#wjs_carousel .item div img&#123; width: 100%;&#125;#wjs_carousel .item .pic1&#123; background: url(\"../img/bigImg1.jpg\") no-repeat center center; background-size: cover;&#125;#wjs_carousel .item .pic2&#123; background: url(\"../img/bigImg2.jpg\") no-repeat center center;&#125;#wjs_carousel .item .pic3&#123; background: url(\"../img/bigImg3.jpg\") no-repeat center center;&#125;#wjs_carousel .item .pic4&#123; background: url(\"../img/bigImg4.jpg\") no-repeat center center;&#125; js写法其实js写法基本和css原理一样,主要是监听屏幕的改变,使用window.resiez方法,然后设置一个临界值,拿屏幕宽度和临界值进行比较,当大于750时候就使用背景图片,当小于750时候就使用img的src123456789101112131415161718192021222324252627282930$(window).on('resize', changeImg); function changeImg() &#123; // 1.0 获取屏幕的宽度 var screenW = $(window).width(); // 1.1 设置临界值 true false var isShowBigImage = screenW &gt; 750; // 1.3 获取所有的item var $itemEles = $('#wjs_carousel .item'); // 1.4 遍历 $itemEles.each(function (index, item) &#123; var $item = $(item); // 1.4.1 获取attr var attr = isShowBigImage ? $item.data('lg-img'): $item.data('sm-img'); // console.log(attr); var url = 'url(' + attr + ')'; // console.log(url); // 1.4.2 设置背景 $item.css(&#123; backgroundImage:url &#125;); // 1.4.3 插入img标签 if(!isShowBigImage)&#123; // 显示小图的尺寸 var $img = '&lt;img src=\"'+ attr +'\"&gt;'; // 注意:先清除后插入 $item.empty().append($img); &#125;else &#123; $item.empty(); &#125; &#125;); &#125; 布局代码123456789101112131415161718192021222324252627282930313233343536&lt;!--轮播图区域--&gt;&lt;section id=\"wjs_carousel\" class=\"carousel slide\" data-ride=\"carousel\"&gt; &lt;!-- 指示器 --&gt; &lt;ol class=\"carousel-indicators\"&gt; &lt;li data-target=\"#wjs_carousel\" data-slide-to=\"0\" class=\"active\"&gt;&lt;/li&gt; &lt;li data-target=\"#wjs_carousel\" data-slide-to=\"1\"&gt;&lt;/li&gt; &lt;li data-target=\"#wjs_carousel\" data-slide-to=\"2\"&gt;&lt;/li&gt; &lt;li data-target=\"#wjs_carousel\" data-slide-to=\"3\"&gt;&lt;/li&gt; &lt;/ol&gt; &lt;!-- 中间滚动内容 --&gt; &lt;div class=\"carousel-inner\" role=\"listbox\"&gt; &lt;div class=\"item active\"&gt; &lt;div class=\"pic1\"&gt;&lt;img src=\"img/smimg1.jpg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"pic2\"&gt;&lt;img src=\"img/smimg2.jpg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"pic3\"&gt;&lt;img src=\"img/smimg3.jpg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;div class=\"pic4\"&gt;&lt;img src=\"img/smimg4.jpg\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 控制 --&gt; &lt;a class=\"left carousel-control\" href=\"#wjs_carousel\" role=\"button\" data-slide=\"prev\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"&gt;&lt;/span&gt; &lt;span class=\"sr-only\"&gt;上一张&lt;/span&gt; &lt;/a&gt; &lt;a class=\"right carousel-control\" href=\"#wjs_carousel\" role=\"button\" data-slide=\"next\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"&gt;&lt;/span&gt; &lt;span class=\"sr-only\"&gt;下一张&lt;/span&gt; &lt;/a&gt;&lt;/section&gt; 效果大图片背景,宽度随屏幕变化,高度固定,小图片,随屏幕移动一起缩小.轮播图可以切换. 支付中心支付中心原理很简单,也是运用了栅格布局,在中等屏幕以上每一行显示三个,用.col-md-4 当中等屏幕以下每一行显示2个,就用.col-sm-6,等在超小屏幕下,我不需要这个支付中心,把他隐藏,所以用hidden-xs在布局里面内容时候,我用到了媒体标签 用到了.media .media-heading.media-body 这里用到了.pull-left 作用是让某个元素左浮动,字体图标用法和上面一样 布局代码123456789101112131415161718192021&lt;!--支付中心区域--&gt;&lt;section id=\"wjs_feature\" class=\" hidden-xs\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;!--复制我--&gt; &lt;div class=\"col-md-4 col-sm-6\"&gt; &lt;div class=\"media text-muted\"&gt; &lt;div class=\"media-heading pull-left\"&gt; &lt;i class=\"icon-uniE907\"&gt;&lt;/i&gt; &lt;/div&gt; &lt;div class=\"media-body\"&gt; &lt;dt&gt;支付交易保证&lt;/dt&gt; &lt;dd&gt;银联支付全程保证安全&lt;/dd&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--/复制我--&gt; &lt;/div&gt; 下面把上面代码复制5个即可,布局都一样,到时候具体改内容就好了 &lt;/div&gt;&lt;/section&gt; 效果中等屏幕每一行3个,以下2个,超小隐藏掉 下载这部分没什么难度,还是运用了栅格布局 左边内容使用.col-md-9,右边内容使用col-md-3 并且右面内容在小屏幕以下就隐藏掉,使用hidden-sm,hidden-xs 字体图片用法一样 布局代码1234567891011121314151617&lt;!--下载区域--&gt;&lt;section id=\"wjs_order\" class=\"text-muted\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-9 \"&gt; &lt;i class=\"icon-uniE906\"&gt;&lt;/i&gt; &lt;span style=\"margin: 0\"&gt; 现在有&lt;strong class=\"text-danger\"&gt;10000&lt;/strong&gt;人在下载游戏,累计下载游戏人数&lt;strong class=\"text-danger\"&gt;100000000&lt;/strong&gt;次.什么是小猪游戏？&lt;a href=\"javascript:;\" class=\"text-muted\"&gt;立即下载&lt;/a&gt; &lt;/span&gt; &lt;/div&gt; &lt;div class=\"col-md-3 hidden-sm hidden-xs\"&gt; &lt;i class=\"icon-uniE905\"&gt;&lt;/i&gt; &lt;a href=\"javascript:;\" class=\"text-muted\" style=\"font-size: 16px\"&gt;小猪游戏宣传片&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 效果自适应改变宽度,小屏幕以下右边内容隐藏 产品中心这一部分稍微复杂一点,不过其实也不难,主要原理是,用到了标签页,点击对应的标签会显示对应的面板,在标签导航我做了处理,就是当屏幕宽度很少的时候,让其显示一条滚动条,利用overflow:auto 让滚动条出现,使用js来实现该功能,然后在对应的面板中,我需要在大屏幕时候每一行显示3个,所以用了.col-lg-4 中等屏幕显示2个,用到了.col-md-6 ,然后里面的内容我用到了面板标签, panel panel-heading panel-body ,在panel-body里面,我对里面的内容再进行了处理,让里面内容无论何时都各占一半,用到.col-xs-6,然后还用到了提示标签 在需要提示的标签上面加上data-toggle=”tooltip” data-placement=”left” title=”快点买啊” 这样属性,设置方向和文字,然后需要在js中调用一个方法.然后具体细节不同的样式,也就是主题,给panel绑定一个特有主题的类即可,当想用什么主题的时候,就在panel这个上面添加对应的类即可 鼠标移入某个标签出现提示内容找到绑定了该属性的标签调用tooltip()这个方法1$('[data-toggle=\"tooltip\"]').tooltip(); 导航标签滚动条监听屏幕的拉伸,window.resize 然后获取一个ul的宽度,获取其父盒子的宽度,其宽度跟随屏幕宽度变化而变化 2者进行比较,当ul小于父盒子宽度时候,采用自适应屏幕,当ul的宽度大于父盒子宽度时候,就让ul固定一个宽度,宽度为li加起来的宽度,这样就可以让滚动条出现了注意当ul小于屏幕宽度时候要让其固定的宽度再次除掉12345678910111213141516171819202122232425$(function () &#123; $(window).on('resize',change); function change() &#123; var $oUl=$('#wjs_product .nav'); var $oUlW=0; var $oLi=$('li[role=\"presentation\"]',$oUl); $oLi.each(function (index,obj) &#123; $oUlW+=$(obj).width(); &#125;); var $panentW= $oUl.parent().width(); if($oUlW&gt;=$panentW)&#123; $oUl.css(&#123; width: $oUlW &#125;); $('#wjs_product').css(&#123; paddingTop:'30px' &#125;) $('#wjs_news').css(&#123; paddingTop:'20px' &#125;) &#125;else&#123; $oUl.removeAttr('style'); &#125; &#125; $(window).trigger('resize'); 布局代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;section id=\"wjs_product\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div style=\"overflow: auto\"&gt; &lt;ul class=\"nav nav-tabs\" role=\"tablist\"&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#product1\" aria-controls=\"product1\" role=\"tab\" data-toggle=\"tab\"&gt;优惠卷&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#product2\" aria-controls=\"product2\" role=\"tab\" data-toggle=\"tab\"&gt;装备区&lt;/a&gt; &lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#product3\" aria-controls=\"product3\" role=\"tab\" data-toggle=\"tab\"&gt;攻略区&lt;/a&gt; &lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#product4\" aria-controls=\"product4\" role=\"tab\" data-toggle=\"tab\"&gt;视频区&lt;/a&gt; &lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#product5\" aria-controls=\"product5\" role=\"tab\" data-toggle=\"tab\"&gt;BUG区&lt;/a&gt; &lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#product6\" aria-controls=\"product6\" role=\"tab\" data-toggle=\"tab\"&gt;游戏截图&lt;/a&gt; &lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#product7\" aria-controls=\"product7\" role=\"tab\" data-toggle=\"tab\"&gt;游戏论坛&lt;/a&gt; &lt;/li&gt; &lt;!--右边--&gt; &lt;li class=\"pull-right hidden-xs hidden-sm\"&gt;&lt;a href=\"javascript:;\" class=\"more\"&gt;更多&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"tab-content\"&gt; &lt;div role=\"tabpanel\" class=\"tab-pane fade in active\" id=\"product1\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;!--复制我--&gt; &lt;div class=\"col-md-6 col-lg-4\"&gt; &lt;div class=\"panel-product current\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;div&gt; &lt;strong&gt;5&lt;/strong&gt;&lt;sub&gt;%&lt;/sub&gt; &lt;br&gt; &lt;span&gt;优惠率&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;h3 class=\"\" data-toggle=\"tooltip\" data-placement=\"left\" title=\"快点买啊\"&gt; 优惠卷100万元&lt;/h3&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6\"&gt; &lt;dt&gt;原来价钱&lt;/dt&gt; &lt;dd&gt;优惠10&lt;sub&gt;元&lt;/sub&gt;&lt;/dd&gt; &lt;/div&gt; &lt;div class=\"col-xs-6\"&gt; &lt;dt&gt;原来价钱(元)&lt;/dt&gt; &lt;dd&gt;优惠10&lt;sub&gt;万&lt;/sub&gt;&lt;/dd&gt; &lt;/div&gt; &lt;div class=\"col-xs-6\"&gt; &lt;dt&gt;原来价钱(元)&lt;/dt&gt; &lt;dd&gt;优惠10&lt;sub&gt;万&lt;/sub&gt;&lt;/dd&gt; &lt;/div&gt; &lt;div class=\"col-xs-6\"&gt; &lt;dt&gt;原来价钱(元)&lt;/dt&gt; &lt;dd&gt;优惠10&lt;sub&gt;万&lt;/sub&gt;&lt;/dd&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--复制我--&gt; 下面代码复制上面 根据需求放到不同的面板上 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 效果大屏幕每行3个,中屏幕每行2个,小屏幕一行一个,拉到某个宽度时候出现滚动条,移入某个元素出现提示,.panel-body内容始终各占一半 新闻中心,基本到这里的话,很多操作都是一样的啦,主要原理是使用了栅格布局,不过这一次我用到了offset这个属性 在第一个使用.col-md-2 然后使用col-md-offset-2 这样第一个位置就占4份了.就是把内容移动多少在col-md-1我用一个胶囊导航包着,用来控制对应的面板,使用nav-stacked,让列表垂直分布面板标签占7分.col-md-7 里面用一个简单的ul即可了,要想点击出现动画效果,需要在对应面板添加 fade 第一个面板需要添加 fade in,前面的动画都是一样原理,而且每一个点击控制的按钮,都是添加data-toggle=?绑定,通过a的href或者data-target来绑定对应的元素 布局代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!--新闻中心区域--&gt;&lt;section id=\"wjs_news\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-2 col-md-offset-2\"&gt; &lt;h3&gt;全部新闻&lt;/h3&gt; &lt;/div&gt; &lt;div class=\"col-md-1\"&gt; &lt;ul class=\"nav nav-pills nav-stacked\"&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a href=\"#news1\" aria-controls=\"news1\" role=\"tab\" data-toggle=\"tab\"&gt; &lt;i class=\"icon-news01\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#news2\" aria-controls=\"news2\" role=\"tab\" data-toggle=\"tab\"&gt; &lt;i class=\"icon-news02\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#news3\" aria-controls=\"news3\" role=\"tab\" data-toggle=\"tab\"&gt; &lt;i class=\"icon-news03\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"#news4\" aria-controls=\"news4\" role=\"tab\" data-toggle=\"tab\"&gt; &lt;i class=\"icon-news04\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class=\"col-md-7\"&gt; &lt;div class=\"tab-content\"&gt; &lt;div role=\"tabpanel\" class=\"tab-pane fade in active\" id=\"news1\"&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div role=\"tabpanel\" class=\"tab-pane fade\" id=\"news2\"&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div role=\"tabpanel\" class=\"tab-pane fade\" id=\"news3\"&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div role=\"tabpanel\" class=\"tab-pane fade\" id=\"news4\"&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;li&gt;没有新闻啊,怎么办啊,那就别看咯,赶紧下载游戏去玩吧!!!!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/section&gt; 效果能够自适应屏幕宽度 底部底部原理非常简单,基本没什么难度,在小屏幕以下消失,用了hidden-xs,hidden-sm 布局代码12345678910111213141516171819&lt;!--尾部区域--&gt;&lt;footer id=\"wjs_footer\" class=\"hidden-xs hidden-sm\"&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row text-center\"&gt; &lt;h3&gt;合作伙伴&lt;/h3&gt; &lt;ul class=\"nav\"&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;i class=\"icon-uniE930\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;i class=\"icon-uniE92F\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;i class=\"icon-uniE92E\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;i class=\"icon-uniE92A\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;i class=\"icon-uniE929\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;i class=\"icon-uniE931\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;i class=\"icon-uniE92C\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;i class=\"icon-uniE92B\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;i class=\"icon-uniE92D\"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt;&lt;/footer&gt; 效果小屏幕,底部消失 模态框这一部分不难,在body的直接子元素添加模态框的布局代码,然后在对应的按钮绑定data-toggle=”modal” data-target=”#btnLogin” 模态框的id和target的id必须一致,这样点击就能实现模态框的效果 模态框代码123456789101112131415161718192021222324对应的按钮&lt;a class=\"btn btn-sm btn-register\" href=\"#\" role=\"button\" data-toggle=\"modal\"data-target=\"#btnLogin\"&gt;免费注册&lt;/a&gt; &lt;!--模态框--&gt;&lt;div class=\"modal fade\" id=\"btnLogin\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myModalLabel\"&gt; &lt;div class=\"modal-dialog\" role=\"document\"&gt; &lt;div class=\"modal-content modal-center\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"&gt;&lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt; &lt;h4 class=\"modal-title\" id=\"myModalLabel\"&gt;欢迎来到注册界面&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;form action=\"\"&gt; &lt;span&gt;用户名:&lt;/span&gt; &lt;input type=\"text\" placeholder=\"请输入用户名\"&gt; &lt;span&gt;密码:&lt;/span&gt; &lt;input type=\"password\" placeholder=\"请输入密码\"&gt; &lt;/form&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"&gt;关闭&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;注册&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果 总结整一个网页布局其实也很繁琐,需要注意的细节非常多.基本用到bootstrap的重要部分,最重要还是栅格布局,几乎每一个地方都会用到.其他例如导航条,标签页,轮播图,或者模态框啊,置于顶部等等方法也用到这个布局上面了,所以只有把bootstrap运动到布局上面,才能加快去理解,去记忆其中的用法.来帮助我们更快的去实现一个又好看又漂亮的布局. 总体效果","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"Bootstrap应用布局(一)","date":"2016-04-05T03:44:00.000Z","path":"2016/04/05/Bootstarp-应用布局(一)/","text":"学完基础语法肯定要用在布局上面,这是其中一个demo这是其中一个demo,下一个demo我会把所有步骤都分解一次,这个demo做一个简单参考.","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"Bootstrap学习之旅","date":"2016-04-04T06:20:00.000Z","path":"2016/04/04/Bootstarp-Bootstarp学习/","text":"千万别点进去啊,因为里面东西好多啊..吓死你哦.最近有点忙啊,不过学习的事情肯定不能停止啦,随着现在移动行业的大力发展,一些移动端框架也火了起来,虽然现在忙,但是也抽时间出来学习最新的技术,学习现在流行的框架.最近也是花了时间去学习bootstrap,一个推特的开源项目,而且公司需求越来越大.这博客由基础开始,到网页布局实践.学习地址是慕课网看到后面才给你地址,所以要坚持看完哦.所有笔记都是一边学习一边写下来的.实在太全面了,当我学完这个笔记肯定对bootstrap这个框架又进一步熟悉了. 标题Bootstrap和普通的HTML页面一样，定义标题都是使用标签到只不过Bootstrap覆盖了其默认的样式,在Bootstrap中为了让非标题元素和标题使用相同的样式，还特意定义了.h1~.h6六个类名。代码块123456789101112131415&lt;!--Bootstrap中的标题--&gt;&lt;h1&gt;Bootstrap标题一&lt;/h1&gt;&lt;h2&gt;Bootstrap标题二&lt;/h2&gt;&lt;h3&gt;Bootstrap标题三&lt;/h3&gt;&lt;h4&gt;Bootstrap标题四&lt;/h4&gt;&lt;h5&gt;Bootstrap标题五&lt;/h5&gt;&lt;h6&gt;Bootstrap标题六&lt;/h6&gt;&lt;!--Bootstrap中让非标题元素和标题使用相同的样式--&gt;&lt;div class=\"h1\"&gt;Bootstrap标题一&lt;/div&gt;&lt;div class=\"h2\"&gt;Bootstrap标题二&lt;/div&gt;&lt;div class=\"h3\"&gt;Bootstrap标题三&lt;/div&gt;&lt;div class=\"h4\"&gt;Bootstrap标题四&lt;/div&gt;&lt;div class=\"h5\"&gt;Bootstrap标题五&lt;/div&gt;&lt;div class=\"h6\"&gt;Bootstrap标题六&lt;/div&gt; 副标题使用了标签来制作副标题。这个副标题具有其自己的一些独特样式：代码块1234567&lt;!--Bootstrap中使用了&lt;small&gt;标签来制作副标题--&gt;&lt;h1&gt;Bootstrap标题一&lt;small&gt;我是副标题&lt;/small&gt;&lt;/h1&gt;&lt;h2&gt;Bootstrap标题二&lt;small&gt;我是副标题&lt;/small&gt;&lt;/h2&gt;&lt;h3&gt;Bootstrap标题三&lt;small&gt;我是副标题&lt;/small&gt;&lt;/h3&gt;&lt;h4&gt;Bootstrap标题四&lt;small&gt;我是副标题&lt;/small&gt;&lt;/h4&gt;&lt;h5&gt;Bootstrap标题五&lt;small&gt;我是副标题&lt;/small&gt;&lt;/h5&gt;&lt;h6&gt;Bootstrap标题六&lt;small&gt;我是副标题&lt;/small&gt;&lt;/h6&gt; 段落强调内容如果想让一个段落p突出显示，可以通过添加类名“.lead”实现，其作用就是增大文本字号，加粗文本，而且对行高和margin也做相应的处理。1&lt;p class=\"lead\"&gt;我是突出文本哦&lt;/p&gt; 粗体在Bootstrap中，可以使用b和strong标签让文本直接加粗。1&lt;p&gt;我在学习&lt;strong&gt;Bootstrap&lt;/strong&gt;，我要掌握&lt;strong&gt;Bootstrap&lt;/strong&gt;的所有知识。&lt;/p&gt; 斜体在Bootstrap中还可以通过使用标签em或i来实现1&lt;p&gt;啦啦啦&lt;em&gt;我是斜体哦&lt;/em&gt;一起学习&lt;i&gt;我也是斜体哦&lt;/i&gt;的使用。我一定要学会&lt;i&gt;Bootstrap&lt;/i&gt;。&lt;/p&gt; 强调颜色句子的重要性，Bootstrap还定义了一套类名，这里称其为强调类名,这些强调类都是通过颜色来表示强调，分别是:提示,主要,成功,通知信息,警告,危险.123456&lt;div class=\"text-muted\"&gt;浅灰色（#999）效果&lt;/div&gt;&lt;div class=\"text-primary\"&gt;蓝色（#428bca）效果&lt;/div&gt;&lt;div class=\"text-success\"&gt;浅绿色(#3c763d)效果&lt;/div&gt;&lt;div class=\"text-info\"&gt;浅蓝色（#31708f)效果&lt;/div&gt;&lt;div class=\"text-warning\"&gt;黄色（#8a6d3b）效果&lt;/div&gt;&lt;div class=\"text-danger\"&gt;褐色（#a94442）效果&lt;/div&gt; 文本对齐Bootstrap通过定义四个类名来控制文本的对齐风格.text-left：左对齐.text-center：居中对齐.text-right：右对齐.text-justify：两端对齐1234&lt;p class=\"text-left\"&gt;我居左&lt;/p&gt;&lt;p class=\"text-center\"&gt;我居中&lt;/p&gt;&lt;p class=\"text-right\"&gt;我居右&lt;/p&gt;&lt;p class=\"text-justify\"&gt;两端对齐&lt;/p&gt; 去点列表通过给无序列表添加一个类名“.list-unstyled”,这样就可以去除默认的列表样式的风格。1234&lt;ul class=\"list-unstyled\"&gt; &lt;li&gt;不带点的li&lt;/li&gt; &lt;li&gt;不带点的li&lt;/li&gt;&lt;/ul&gt; 内联列表Bootstrap像去点列表一样，通过添加类名“.list-inline”来实现内联列表，1234567&lt;ul class=\"list-inline\"&gt; &lt;li&gt;水平排版的li&lt;/li&gt; &lt;li&gt;水平排版的li&lt;/li&gt; &lt;li&gt;水平排版的li&lt;/li&gt; &lt;li&gt;水平排版的li&lt;/li&gt; &lt;li&gt;水平排版的li&lt;/li&gt;&lt;/ul&gt; 水平定义列表Bootstrap可以给dl添加类名“.dl-horizontal”给定义列表实现水平显示效果。1234&lt;dl class=\"dl-horizontal\"&gt; &lt;dt&gt;标题会加重&lt;/dt&gt; &lt;dd&gt;内容&lt;/dt&gt; &lt;/dl&gt; 代码块风格在Bootstrap主要提供了三种代码风格：1、使用code code来显示单行内联代码2、使用pre pre来显示多行块代码3、使用kbd kbd来显示用户输入代码 pre代码块pre元素一般用于显示大块的代码，并保证原有格式不变。但有时候代码太多，而且不想让其占有太大的页面篇幅,你只需要在pre标签上添加类名“.pre-scrollable”，就可以控制代码块区域最大高度为340px，一旦超出这个高度，就会在Y轴出现滚动条。123456789101112131415161718&lt;pre class=\"pre-scrollable\"&gt;&lt;ol&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt; &lt;li&gt;内容很多高度超出340啦&lt;/li&gt;&lt;/ol&gt;&lt;/pre&gt; 表格Bootstrap为表格提供了1种基础样式和4种附加样式以及1个支持响应式的表格。在使用Bootstrap的表格过程中，只需要添加对应的类名就可以得到不同的表格风格,都需要基于table这个基类..table：基础表格.table-striped：斑马线表格.table-bordered：带边框的表格.table-hover：鼠标悬停高亮的表格.table-condensed：紧凑型表格.table-responsive：响应式表格123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181&lt;table class=\"table\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;table class=\"table table-striped\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;h1&gt;带边框的表格&lt;/h1&gt; &lt;table class=\"table table-bordered\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;h1&gt;鼠标悬浮高亮的表格&lt;/h1&gt;&lt;table class=\"table table-striped table-bordered table-hover\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;h1&gt;紧凑型表格&lt;/h1&gt; &lt;table class=\"table table-condensed\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;h1&gt;响应式表格&lt;/h1&gt; &lt;div class=\"table-responsive\"&gt; &lt;table class=\"table table-bordered\"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;th&gt;表格标题&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;td&gt;表格单元格&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 表格背景颜色Bootstrap还为表格的行元素tr提供了五种不同的类名，每种类名控制了行的不同背景颜色(给tr加类名) 类名 描述.active: 表示当前活动的信息.success: 表示成功或者正确的行为.info: 表示中立的信息或行为.warning: 表示警告，需要特别注意.danger: 表示危险或者可能是错误的行为 基础表单表单中常见的元素主要包括：文本输入框、下拉选择框、单选按钮、复选按钮、文本域和按钮等。下面是一个基本表单的样式12345678910111213141516&lt;form role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputEmail1\"&gt;邮箱：&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail1\" placeholder=\"请输入您的邮箱地址\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"exampleInputPassword1\"&gt;密码&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword1\" placeholder=\"请输入您的邮箱密码\"&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;进入邮箱&lt;/button&gt;&lt;/form&gt; 水平表单1、在form元素是使用类名“form-horizontal”。2、配合Bootstrap框架的栅格系统。12345678910111213141516171819202122232425262728&lt;form class=\"form-horizontal\" role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputEmail3\" class=\"col-sm-2 control-label\"&gt;邮箱&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"email\" class=\"form-control\" id=\"inputEmail3\" placeholder=\"请输入您的邮箱地址\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"inputPassword3\" class=\"col-sm-2 control-label\"&gt;密码&lt;/label&gt; &lt;div class=\"col-sm-10\"&gt; &lt;input type=\"password\" class=\"form-control\" id=\"inputPassword3\" placeholder=\"请输入您的邮箱密码\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-offset-2 col-sm-10\"&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-sm-offset-2 col-sm-10\"&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;进入邮箱&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt; 内联表单有时候我们需要将表单的控件都在一行内显示,只需要在form元素中添加类名“form-inline”即可。如果你要在input前面添加一个label标签时，会导致input换行显示。如果你必须添加这样的一个label标签，并且不想让input换行，你需要将label标签也放在容器“form-group”中,可以给label添加一个类sr-only让其隐藏,12345678910111213141516&lt;form class=\"form-inline\" role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"sr-only\" for=\"exampleInputEmail2\"&gt;邮箱&lt;/label&gt; &lt;input type=\"email\" class=\"form-control\" id=\"exampleInputEmail2\" placeholder=\"请输入你的邮箱地址\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"sr-only\" for=\"exampleInputPassword2\"&gt;密码&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" id=\"exampleInputPassword2\" placeholder=\"请输入你的邮箱密码\"&gt; &lt;/div&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\"&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;进入邮箱&lt;/button&gt;&lt;/form&gt; 表单控件的具体研究输入框单行输入框，常见的文本输入框，也就是input的type属性值为text。为了让控件在各种表单风格中样式不出错，需要添加类名“form-control”12345&lt;form role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"我是输入框\"&gt; &lt;/div&gt;&lt;/form&gt; 下拉选择框Bootstrap框架中的下拉选择框使用和原始的一致，多行选择设置multiple属性的值为multiple。12345678910111213141516171819202122&lt;form role=\"form\"&gt; 单行下拉 &lt;div class=\"form-group\"&gt; &lt;select class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; 多行下拉 &lt;div class=\"form-group\"&gt; &lt;select multiple class=\"form-control\"&gt; &lt;option&gt;1&lt;/option&gt; &lt;option&gt;2&lt;/option&gt; &lt;option&gt;3&lt;/option&gt; &lt;option&gt;4&lt;/option&gt; &lt;option&gt;5&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/form&gt; 文本域设置rows可定义其高度，设置cols可以设置其宽度。但如果textarea元素中添加了类名“form-control”类名，则无需设置cols属性。因为Bootstrap框架中的“form-control”样式的表单控件宽度为100%或auto。12345&lt;form role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;textarea class=\"form-control\" rows=\"10\"&gt;&lt;/textarea&gt; &lt;/div&gt;&lt;/form&gt; 复选框和单选按钮Bootstrap框架中checkbox和radio有点特殊，Bootstrap针对他们做了一些特殊化处理，不管是checkbox还是radio都使用label包起来了,checkbox连同label标签放置在一个名为“.checkbox”的容器内radio连同label标签放置在一个名为“.radio”的容器内.123456789101112131415161718192021&lt;form role=\"form\"&gt; &lt;h3&gt;复选框和单选按钮&lt;/h3&gt; &lt;div class=\"checkbox\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"\"&gt; 记住密码 &lt;/label&gt; &lt;/div&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"optionsRadios\" id=\"optionsRadios1\" value=\"love\" checked&gt; 喜欢 &lt;/label&gt; &lt;/div&gt; &lt;div class=\"radio\"&gt; &lt;label&gt; &lt;input type=\"radio\" name=\"optionsRadios\" id=\"optionsRadios2\" value=\"hate\"&gt; 不喜欢 &lt;/label&gt; &lt;/div&gt;&lt;/form&gt; 复选框和单选框水平排列如果checkbox需要水平排列，只需要在label标签上添加类名“checkbox-inline”如果radio需要水平排列，只需要在label标签上添加类名“radio-inline”123456789101112131415161718192021222324&lt;form role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" value=\"option1\"&gt;游戏 &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" value=\"option2\"&gt;摄影 &lt;/label&gt; &lt;label class=\"checkbox-inline\"&gt; &lt;input type=\"checkbox\" value=\"option3\"&gt;旅游 &lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"radio-inline\"&gt; &lt;input type=\"radio\" value=\"option1\" name=\"sex\"&gt;男性 &lt;/label&gt; &lt;label class=\"radio-inline\"&gt; &lt;input type=\"radio\" value=\"option2\" name=\"sex\"&gt;女性 &lt;/label&gt; &lt;label class=\"radio-inline\"&gt; &lt;input type=\"radio\" value=\"option3\" name=\"sex\"&gt;中性 &lt;/label&gt; &lt;/div&gt;&lt;/form&gt; 表单按钮在Bootstrap框架中的按钮都是采用button来实现。所有按钮都有一个基类叫btn1234567&lt;button class=\"btn\" href=\"#\"&gt;Default默认&lt;/button&gt;&lt;button class=\"btn btn-primary\" href=\"#\"&gt;Primary主要&lt;/button&gt;&lt;button class=\"btn btn-info\" href=\"#\"&gt;Info信息&lt;/button&gt;&lt;button class=\"btn btn-success\" href=\"#\"&gt;Success成功&lt;/button&gt;&lt;button class=\"btn btn-warning\" href=\"#\"&gt;Warning警告&lt;/button&gt;&lt;button class=\"btn btn-danger\" href=\"#\"&gt;Danger危险&lt;/button&gt;&lt;button class=\"btn btn-inverse\" href=\"#\"&gt;Inverse相反&lt;/button&gt; 表单控件大小Bootstrap框架还提供了两个不同的类名，用来控制表单控件的高度。这两个类名是：1、input-sm:让控件比正常大小更小2、input-lg:让控件比正常大小更大这两个类适用于表单中的input，textarea和select控件,我们需要控件宽度也要做一定的变化处理。这个时候就要借住Bootstrap框架的网格系统。123456789101112131415161718192021222324252627282930313233343536373839404142改变高度&lt;form role=\"form\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"control-label\"&gt;控件变大&lt;/label&gt; &lt;input class=\"form-control input-lg\" type=\"text\" placeholder=\"添加.input-lg，控件变大\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"control-label\"&gt;正常大小&lt;/label&gt; &lt;input class=\"form-control\" type=\"text\" placeholder=\"正常大小\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"control-label\"&gt;控件变小&lt;/label&gt; &lt;input class=\"form-control input-sm\" type=\"text\" placeholder=\"添加.input-sm，控件变小\"&gt; &lt;/div&gt; &lt;/form&gt; 改变宽度&lt;form role=\"form\" class=\"form-horizontal\"&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-xs-4\"&gt; &lt;input class=\"form-control input-lg\" type=\"text\" placeholder=\".col-xs-4\"&gt; &lt;/div&gt; &lt;div class=\"col-xs-4\"&gt; &lt;input class=\"form-control input-lg\" type=\"text\" placeholder=\".col-xs-4\"&gt; &lt;/div&gt; &lt;div class=\"col-xs-4\"&gt; &lt;input class=\"form-control input-lg\" type=\"text\" placeholder=\".col-xs-4\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-xs-6\"&gt;&lt;input class=\"form-control\" type=\"text\" placeholder=\".col-xs-6\"&gt;&lt;/div&gt; &lt;div class=\"col-xs-6\"&gt;&lt;input class=\"form-control\" type=\"text\" placeholder=\".col-xs-6\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-xs-5\"&gt; &lt;input class=\"form-control input-sm\" type=\"text\" placeholder=\".col-xs-5\"&gt; &lt;/div&gt; &lt;div class=\"col-xs-7\"&gt; &lt;input class=\"form-control input-sm\" type=\"text\" placeholder=\".col-xs-7\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 表单控件焦点状态比如表单有焦点的状态可以告诉用户可以输入或选择东西，禁用状态可以告诉用户不可以输入或选择东西，还有就是表单控件验证状态，可以告诉用户的操作是否正确等。那么在Bootstrap框架中的表单控件也具备这些状态。焦点状态是通过伪类“:focus”来实现。Bootstrap框架中表单控件的焦点状态删除了outline的默认样式，重新添加阴影效果。要让控件在焦点状态下有样式效果，需要给控件添加类名“form-control”12345678910&lt;form role=\"form\" class=\"form-horizontal\"&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-xs-6\"&gt; &lt;input class=\"form-control input-lg\" type=\"text\" placeholder=\"不是焦点状态下效果\"&gt; &lt;/div&gt; &lt;div class=\"col-xs-6\"&gt; &lt;input class=\"form-control input-lg\" type=\"text\" placeholder=\"焦点点状态下效果\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; 表单控件禁用状态Bootstrap框架的表单控件的禁用状态和普通的表单禁用状态实现方法是一样的，在相应的表单控件上添加属性“disabled”。和其他表单的禁用状态不同的是，Bootstrap框架做了一些样式风格的处理,只需要在需要禁用的表单控件上加上“disabled”即可,在Bootstrap框架中，如果fieldset设置了disabled属性，整个域都将处于被禁用状态。如果legend中有输入框的话，这个输入框是无法被禁用的.如果控件中不使用类名“form-control”，禁用的控件只会有一个不准输入的手型出来。1&lt;input class=\"form-control\" type=\"text\" placeholder=\"表单已禁用，不能输入\" disabled&gt; 表单控件验证状态在制作表单时，不免要做表单验证。同样也需要提供验证状态样式，在Bootstrap框架中同样提供这几种效果。12345678910111213141516171819202122232425262728293031323334351、.has-warning:警告状态（黄色）2、.has-error：错误状态（红色）3、.has-success：成功状态（绿色）&lt;form role=\"form\"&gt; &lt;div class=\"form-group has-success\"&gt; &lt;label class=\"control-label\" for=\"inputSuccess1\"&gt;成功状态&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"inputSuccess1\" placeholder=\"成功状态\" &gt; &lt;/div&gt; &lt;div class=\"form-group has-warning\"&gt; &lt;label class=\"control-label\" for=\"inputWarning1\"&gt;警告状态&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"inputWarning1\" placeholder=\"警告状态\"&gt; &lt;/div&gt; &lt;div class=\"form-group has-error\"&gt; &lt;label class=\"control-label\" for=\"inputError1\"&gt;错误状态&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"inputError1\" placeholder=\"错误状态\"&gt; &lt;/div&gt;&lt;/form&gt; 如果你想让表单在对应的状态下显示 icon 出来，只需要在对应的状态下添加类名“has-feedback”。请注意，此类名要与“has-error”、“has-warning”和“has-success”在一起&lt;form role=\"form\"&gt; &lt;div class=\"form-group has-success has-feedback\"&gt; &lt;label class=\"control-label\" for=\"inputSuccess1\"&gt;成功状态&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"inputSuccess1\" placeholder=\"成功状态\" &gt; &lt;span class=\"glyphicon glyphicon-ok form-control-feedback\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group has-warning has-feedback\"&gt; &lt;label class=\"control-label\" for=\"inputWarning1\"&gt;警告状态&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"inputWarning1\" placeholder=\"警告状态\"&gt; &lt;span class=\"glyphicon glyphicon-warning-sign form-control-feedback\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group has-error has-feedback\"&gt; &lt;label class=\"control-label\" for=\"inputError1\"&gt;错误状态&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"inputError1\" placeholder=\"错误状态\"&gt; &lt;span class=\"glyphicon glyphicon-remove form-control-feedback\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/form&gt; 表单提示信息常在制作表单验证时，要提供不同的提示信息。在Bootstrap框架中也提供了这样的效果。使用了一个”help-block”样式，将提示信息以块状显示，并且显示在控件底部。1234567891011121314151617181920&lt;form role=\"form\"&gt; &lt;div class=\"form-group has-success has-feedback\"&gt; &lt;label class=\"control-label\" for=\"inputSuccess1\"&gt;成功状态&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"inputSuccess1\" placeholder=\"成功状态\" &gt; &lt;span class=\"help-block\"&gt;你输入的信息是正确的&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-ok form-control-feedback\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group has-warning has-feedback\"&gt; &lt;label class=\"control-label\" for=\"inputWarning1\"&gt;警告状态&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"inputWarning1\" placeholder=\"警告状态\"&gt; &lt;span class=\"help-block\"&gt;请输入正确信息&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-warning-sign form-control-feedback\"&gt;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"form-group has-error has-feedback\"&gt; &lt;label class=\"control-label\" for=\"inputError1\"&gt;错误状态&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"inputError1\" placeholder=\"错误状态\"&gt; &lt;span class=\"glyphicon glyphicon-remove form-control-feedback\"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/form&gt; 按钮通过一个基类.btn实现 基础按钮1&lt;button class=\"btn\" type=\"button\"&gt;我是一个基本按钮&lt;/button&gt; 默认按钮1&lt;button class=\"btn btn-default\" type=\"button\"&gt;默认按钮&lt;/button&gt; 多标签支持还可以使用在其他的标签元素上，唯一需要注意的是，要在制作按钮的标签元素上添加类名“btn”。1234&lt;button class=\"btn btn-default\" type=\"button\"&gt;button标签按钮&lt;/button&gt; &lt;input type=\"submit\" class=\"btn btn-default\" value=\"input标签按钮\"/&gt;&lt;span class=\"btn btn-default\"&gt;span标签按钮&lt;/span&gt; &lt;div class=\"btn btn-default\"&gt;div标签按钮&lt;/div&gt; 主要按钮1&lt;button class=\"btn btn-primary\" type=\"button\"&gt;主要按钮.btn-primary&lt;/button&gt; 成功按钮1&lt;button class=\"btn btn-success\" type=\"button\"&gt;成功按钮.btn-success&lt;/button&gt; 警告按钮1&lt;button class=\"btn btn-warning\" type=\"button\"&gt;警告按钮.btn-warning&lt;/button&gt; 危险按钮1&lt;button class=\"btn btn-danger\" type=\"button\"&gt;危险按钮.btn-danger&lt;/button&gt; 链接按钮1&lt;button class=\"btn btn-link\" type=\"button\"&gt;链接按钮.btn-link&lt;/button&gt; 按钮大小在Bootstrap框架中，对于按钮的大小，也是可以定制的。类似于input一样，通过在基础按钮“.btn”的基础上追加类名来控制按钮的大小。123&lt;button class=\"btn btn-primary btn-lg\" type=\"button\"&gt;大型按钮.btn-lg&lt;/button&gt; &lt;button class=\"btn btn-primary\" type=\"button\"&gt;正常按钮&lt;/button&gt;&lt;button class=\"btn btn-primary btn-sm\" type=\"button\"&gt;小型按钮.btn-sm&lt;/button&gt; 块状按钮Bootstrap框架中提供了一个类名“btn-block”。按钮使用这个类名就可以让按钮充满整个容器，并且这个按钮不会有任何的padding和margin值。 1234&lt;button class=\"btnbtn-primary btn-lg btn-block\" type=\"button\"&gt;大型按钮.btn-lg&lt;/button&gt;&lt;button class=\"btnbtn-primary btn-block\" type=\"button\"&gt;正常按钮&lt;/button&gt;&lt;button class=\"btnbtn-primary btn-sm btn-block\" type=\"button\"&gt;小型按钮.btn-sm&lt;/button&gt;&lt;button class=\"btnbtn-primary btn-xs btn-block\" type=\"button\"&gt;超小型按钮.btn-xs&lt;/button&gt; 按钮状态在Bootstrap框架中针对按钮的状态效果主要分为两种：活动状态和禁用状态。Bootstrap按钮的活动状态主要包括按钮的悬浮状态(:hover)，点击状态(:active)和焦点状态（:focus）在Bootstrap框架中，要禁用按钮有两种实现方式：方法1：在标签中添加disabled属性方法2：在元素标签中添加类名“disabled”“.disabled”样式不会禁止按钮的默认行为，比如说提交和重置行为等如果通过类名“.disable”来禁用按钮，其链接行为是无法禁止。而在元素标签中添加“disabled”属性的方法是可以禁止元素的默认行为的123&lt;button class=\"btn btn-primary btn-lg btn-block\" type=\"button\" disabled=\"disabled\"&gt;通过disabled属性禁用按钮&lt;/button&gt; &lt;button class=\"btn btn-primary btn-block disabled\" type=\"button\"&gt;通过添加类名disabled禁用按钮&lt;/button&gt;&lt;button class=\"btn btn-primary btn-sm btn-block\" type=\"button\"&gt;未禁用的按钮&lt;/button&gt; 图像在Bootstrap框架中对于图像的样式风格提供以下几种风格1、img-responsive：响应式图片，主要针对于响应式设计2、img-rounded：圆角图片3、img-circle：圆形图片4、img-thumbnail：缩略图片1234567891011121314151617181920212223242526&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm-4\"&gt; &lt;img alt=\"140x140\" src=\"http://placehold.it/140x140\"&gt; &lt;div&gt;默认图片&lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-sm-4\"&gt; &lt;img class=\"img-rounded\" alt=\"140x140\" src=\"http://placehold.it/140x140\"&gt; &lt;div&gt;圆角图片&lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-sm-4\"&gt; &lt;img class=\"img-circle\" alt=\"140x140\" src=\"http://placehold.it/140x140\"&gt; &lt;div&gt;圆形图片&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-sm-6\"&gt; &lt;img class=\"img-thumbnail\" alt=\"140x140\" src=\"http://placehold.it/140x140\"&gt; &lt;div&gt;缩略图&lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-sm-6\"&gt; &lt;img class=\"img-responsive\" alt=\"140x140\" src=\"http://placehold.it/140x140\" /&gt; &lt;div&gt;响应式图片&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 图标在Bootstrap框架中也为大家提供了近200个不同的icon图片，而这些图标都是使用CSS3的@font-face属性配合字体来实现的icon效果。有一个基类glyphicon1234&lt;span class=\"glyphicon glyphicon-search\"&gt;&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-asterisk\"&gt;&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-plus\"&gt;&lt;/span&gt; &lt;span class=\"glyphicon glyphicon-cloud\"&gt;&lt;/span&gt; 栅格系统工作原理Bootstrap框架中的网格系统就是将容器平分成12份。数据行(.row)必须包含在容器（.container）中，以便为其赋予合适的对齐方式和内距(padding)。在行(.row)中可以添加列(.column)，但列数之和不能超过平分的总列数，比如12具体内容应当放置在列容器（column）之内，而且只有列（column）才可以作为行容器(.row)的直接子元素通过设置内距（padding）从而创建列与列之间的间距。然后通过为第一列和最后一列设置负值的外距（margin）来抵消内距(padding)的影响 列偏移使用列偏移也非常简单，只需要在列元素上添加类名“col-md-offset-”(其中星号代表要偏移的列组合数)不过有一个细节需要注意，使用”col-md-offset-”对列进行向右偏移时，要保证列与偏移列的总数不超过12，不然会致列断行显示123456789101112&lt;div class=\"container\"&gt;&lt;h4&gt;列向右移动四列的间距&lt;/h4&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-2 col-md-offset-4\"&gt;列向右移动四列的间距&lt;/div&gt; &lt;div class=\"col-md-2\"&gt;.col-md-3&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-4 col-md-offset-4\"&gt;列向右移动四列的间距&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列排序列排序其实就是改变列的方向，就是改变左右浮动，并且设置浮动的距离。在Bootstrap框架的网格系统中是通过添加类名“col-md-push-”和“col-md-pull-” (其中星号代表移动的列组合数)。123456&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4 col-md-push-8\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-8 col-md-pull-4\"&gt;.col-md-8&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 列的嵌套但在列容器中的行容器（row），宽度为100%时，就是当前外部列的宽度。1234567891011121314151617181920212223&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-8\"&gt; 我的里面嵌套了一个网格 &lt;div class=\"row\"&gt; &lt;div class=\"col-md-6\"&gt;col-md-6&lt;/div&gt; &lt;div class=\"col-md-6\"&gt;col-md-6&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"col-md-4\"&gt;col-md-4&lt;/div&gt; &lt;/div&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt;.col-md-4&lt;/div&gt; &lt;div class=\"col-md-8\"&gt; 我的里面嵌套了一个网格 &lt;div class=\"row\"&gt; &lt;div class=\"col-md-4\"&gt;col-md-4&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;col-md-4&lt;/div&gt; &lt;div class=\"col-md-4\"&gt;col-md-4&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 下拉菜单在使用Bootstrap框架的下拉菜单时，必须调用Bootstrap框架提供的bootstrap.js文件.因为Bootstrap的组件交互效果都是依赖于jQuery库写的插件，所以在使用bootstrap.min.js之前一定要先加载jquery.min.js才会生效果。123456789101112131415使用一个名为“dropdown”的容器包裹了整个下拉菜单元素使用了一个&lt;button&gt;按钮做为父菜单，并且定义类名“dropdown-toggle”和自定义“data-toggle”属性，且值必须和最外容器类名一致下拉菜单项使用一个ul列表，并且定义一个类名为“dropdown-menu”，&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" type=\"button\" id=\"dropdownMenu1\" data-toggle=\"dropdown\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"dropdownMenu1\"&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 下拉菜单原理分析1234567891011121314dropdown-menu”默认样式设置了“display:none”当用户第一次点击时，“div.dropdown”会添加类名“open”,当用户再次点击时，“div.dropdown”容器中的类名“open”又会被移除。&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" type=\"button\" id=\"dropdownMenu\" data-toggle=\"dropdown\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"dropdownMenu1\"&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 下拉分隔线假设下拉菜单有两个组，那么组与组之间可以通过添加一个空的li，并且给这个li添加类名“divider”来实现添加下拉分隔线的功能。1234567891011121314&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" type=\"button\" id=\"dropdownMenu1\" data-toggle=\"dropdown\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"dropdownMenu1\"&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; 下拉分隔线 &lt;li role=\"presentation\" class=\"divider\"&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 菜单标题可以给每个组添加一个头部（标题）,加上一个类名dropdown-header1234567891011121314151617&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" type=\"button\" id=\"dropdownMenu1\" data-toggle=\"dropdown\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"dropdownMenu1\"&gt; &lt;li role=\"presentation\" class=\"dropdown-header\"&gt;第一部分菜单头部&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"divider\"&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"dropdown-header\"&gt;第二部分菜单头部&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 对齐方式如果你想让下拉菜单相对于父容器右对齐时，可以在“dropdown-menu”上添加一个“pull-right”或者“dropdown-menu-right”类名(left把right改成left)12345678910111213&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" type=\"button\" id=\"dropdownMenu1\" data-toggle=\"dropdown\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu dropdown-menu-right\" role=\"menu\" aria-labelledby=\"dropdownMenu1\"&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"divider\"&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 菜单项状态下拉菜单项的默认的状态（不用设置）有悬浮状态（:hover）和焦点状态（:focus）下拉菜单项除了上面两种状态，还有当前状态（.active）和禁用状态（.disabled）。这两种状态使用方法只需要在对应的菜单项上添加对应的类名12345678910111213&lt;div class=\"dropdown\"&gt; &lt;button class=\"btn btn-default dropdown-toggle\" type=\"button\" id=\"dropdownMenu1\" data-toggle=\"dropdown\"&gt; 下拉菜单 &lt;span class=\"caret\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"dropdownMenu1\"&gt; &lt;li role=\"presentation\" class=\"active\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;活动下拉菜单&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"divider\"&gt;&lt;/li&gt; &lt;li role=\"presentation\" class=\"disabled\"&gt;&lt;a role=\"menuitem\" tabindex=\"-1\" href=\"#\"&gt;禁用下拉菜单项&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 导航都有一个基类.nav 基础样式Bootstrap框架中制作导航条主要通过“.nav”样式。默认的“.nav”样式不提供默认的导航样式，必须附加另外一个样式才会有效，比如“nav-tabs”、“nav-pills”之类。1234567&lt;ul class=\"nav nav-tabs\"&gt; &lt;li&gt;&lt;a href=\"##\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 标签形tab导航标签形导航是通过“nav-tabs”样式来实现。在制作标签形导航时需要在原导航“nav”上追加此类名，1234567&lt;ul class=\"nav nav-tabs\"&gt; &lt;li&gt;&lt;a href=\"##\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;4&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;5&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 胶囊形导航标签形导航是通过“nav-pills”样式来实现。在制作标签形导航时需要在原导航“nav”上追加此类名，1234567&lt;ul class=\"nav nav-pills\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"##\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;Sass&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"##\"&gt;Responsive&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 垂直堆叠的导航制作垂直堆叠导航只需要在“nav-*”的基础上添加一个“nav-stacked”1234567&lt;ul class=\"nav nav-pills nav-stacked\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"##\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;Sass&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"##\"&gt;Responsive&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; 自适应导航在“nav-*”的基础上添加一个“nav-justified”1234567&lt;ul class=\"nav nav-tabs nav-justified\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"##\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;Sass&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;Responsive&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 自适应导航实现原理1实现原理并不难，列表（&lt;ul&gt;）上设置宽度为“100%”，然后每个菜单项(&lt;li&gt;)设置了“display:table-cell”，让列表项以模拟表格单元格的形式显示： 面包屑式导航添加一个类breadcrumb12345&lt;ol class=\"breadcrumb\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;我的书&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;《图解CSS3》&lt;/li&gt;&lt;/ol&gt; 导航条基础导航条第一步：首先在制作导航的列表()基础上添加类名“navbar-nav”第二步：在列表外部添加一个容器（div），并且使用类名“navbar”和“navbar-default”导航条的颜色都是通过“.navbar-default”来进行控制123456789&lt;div class=\"navbar navbar-default\" role=\"navigation\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"##\"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;系列教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 添加标题,二级菜单,状态通过“navbar-header”和“navbar-brand”来实现，12345678910111213141516171819202122232425262728293031323334添加标题 .navbar-header .navbar-brand &lt;div class=\"navbar navbar-default\" role=\"navigation\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a href=\"##\" class=\"navbar-brand\"&gt;小猪网&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"##\"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;系列教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;二级菜单和状态通过.dropdown data-toggle=\"dropdown\" dropdown-menu disabled 来实现 &lt;div class=\"navbar navbar-default\" role=\"navigation\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a href=\"##\" class=\"navbar-brand\"&gt;小猪网&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"##\"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"##\" data-toggle=\"dropdown\" class=\"dropdown-toggle\"&gt;系列教程&lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"##\"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"##\"&gt;PHP&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 带表单的导航条在navbar容器中放置一个带有navbar-form类名的表单通过navbar-left”让表单左浮动，更好实现对齐。在Bootstrap框架中，还提供了“navbar-right”样式，让元素在导航条靠右对齐。12345678910111213141516171819202122232425&lt;div class=\"navbar navbar-default\" role=\"navigation\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a href=\"##\" class=\"navbar-brand\"&gt;小猪网&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"##\"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"dropdown\"&gt; &lt;a href=\"##\" data-toggle=\"dropdown\" class=\"dropdown-toggle\"&gt;系列教程&lt;span class=\"caret\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\"&gt; &lt;li&gt;&lt;a href=\"##\"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"##\"&gt;PHP&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;form action=\"##\" class=\"navbar-form navbar-left\" rol=\"search\"&gt; &lt;div class=\"form-group\"&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"请输入关键词\" /&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-default\"&gt;搜索&lt;/button&gt; &lt;/form&gt;&lt;/div&gt; 按钮,文本,链接1、导航条中的按钮navbar-btn2、导航条中的文本navbar-text3、导航条中的普通链接navbar-link需要和navbar-brand、navbar-nav配合起来使用12345678910&lt;div class=\"navbar navbar-default\" role=\"navigation\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a href=\"##\" class=\"navbar-brand\"&gt;慕课网&lt;/a&gt; &lt;/div&gt; &lt;div class=\"nav navbar-nav\"&gt; &lt;a href=\"##\" class=\"navbar-text\"&gt;Navbar Text&lt;/a&gt; &lt;a href=\"##\" class=\"navbar-text\"&gt;Navbar Text&lt;/a&gt; &lt;a href=\"##\" class=\"navbar-text\"&gt;Navbar Text&lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 固定导航条 .navbar-fixed-top：导航条固定在浏览器窗口顶部 .navbar-fixed-bottom：导航条固定在浏览器窗口底部只需要在制作导航条最外部容器navbar上追加对应的类名即可实现原理,定位为fixed,top和bottom为0.固定导航条默认高度是50px 为了避免固定导航条遮盖内容,我们一般设置padding-top和padding-bottom的值为70px123456789101112&lt;div class=\"navbar navbar-default navbar-fixed-top\" role=\"navigation\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a href=\"##\" class=\"navbar-brand\"&gt;劳柏明&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"##\"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;系列教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 响应式导航条1、保证在窄屏时需要折叠的内容必须包裹在带一个div内，并且为这个div加入collapse、navbar-collapse两个类名。最后为这个div添加一个class类名或者id名。2,保证在窄屏时要显示的图标样式(固定写法)123456&lt;button class=\"navbar-toggle\" type=\"button\" data-toggle=\"collapse\"&gt; &lt;span class=\"sr-only\"&gt;Toggle Navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt;&lt;/button&gt; 3、并为button添加data-target=”.类名/#id名”，究竞是类名还是id名呢？由需要折叠的div来决定1234567891011121314151617181920212223&lt;div class=\"navbar navbar-default\" role=\"navigation\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;!-- .navbar-toggle样式用于toggle收缩的内容，即nav-collapse collapse样式所在元素 --&gt; &lt;button class=\"navbar-toggle\" type=\"button\" data-toggle=\"collapse\" data-target=\".navbar-responsive-collapse\"&gt; &lt;span class=\"sr-only\"&gt;Toggle Navigation&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;span class=\"icon-bar\"&gt;&lt;/span&gt; &lt;/button&gt; &lt;!-- 确保无论是宽屏还是窄屏，navbar-brand都显示 --&gt; &lt;a href=\"##\" class=\"navbar-brand\"&gt;我是大大标签&lt;/a&gt; &lt;/div&gt; &lt;!-- 屏幕宽度小于768px时，div.navbar-responsive-collapse容器里的内容都会隐藏，显示icon-bar图标，当点击icon-bar图标时，再展开。屏幕大于768px时，默认显示。 --&gt; &lt;div class=\"collapse navbar-collapse navbar-responsive-collapse\"&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"##\"&gt;网站首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;系列教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;名师介绍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;成功案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"##\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 反色导航条将navbar-deafult类名换成navbar-inverse。12345678910&lt;div class=\"navbar navbar-inverse\" role=\"navigation\"&gt; &lt;div class=\"navbar-header\"&gt; &lt;a href=\"##\" class=\"navbar-brand\"&gt;劳柏明&lt;/a&gt; &lt;/div&gt; &lt;ul class=\"nav navbar-nav\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;教程&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;关于我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 分页导航在ul标签上加入.pagination 使用ul&gt;li&gt;a这样结构当前状态页码会高亮显示，而且不能点击。而最后一页是禁用状态，也不能点击。有一个基类.pagination大小设置“pagination-lg”让分页导航变大“pagination-sm”让分页导航变小123456789&lt;ul class=\"pagination pagination\"&gt; &lt;li&gt;&lt;a href=\"#\"&gt;&amp;laquo;第一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;11&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;12&lt;/a&gt;&lt;/li&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#\"&gt;13&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;14&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;15&lt;/a&gt;&lt;/li&gt; &lt;li class=\"disabled\"&gt;&lt;a href=\"#\"&gt;最后一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 翻页代码翻页分页导航和带页码的分页导航类似,为ul标签加入pager类previous：让“上一步”按钮居左next：让“下一步”按钮居右只需要在li标签上添加对应类名即可如果在li标签上添加了disabled类名的时候，分页按钮处于禁用状态，但同样不能禁止其点击功能。你可以通过js来处理，或将a标签换成span标签。12345&lt;!--左右对齐--&gt;&lt;ul class=\"pager\"&gt; &lt;li class=\"previous\"&gt;&lt;a href=\"#\"&gt;&amp;laquo;上一页&lt;/a&gt;&lt;/li&gt; &lt;li class=\"next\"&gt;&lt;a href=\"#\"&gt;下一页&amp;raquo;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 标签以“.label”样式来实现高亮显示。有一个基类.labellabel-deafult:默认标签，深灰色label-primary：主要标签，深蓝色label-success：成功标签，绿色label-info：信息标签，浅蓝色label-warning：警告标签，橙色label-danger：错误标签，红色123456&lt;span class=\"label label-default\"&gt;默认标签&lt;/span&gt;&lt;span class=\"label label-primary\"&gt;主要标签&lt;/span&gt;&lt;span class=\"label label-success\"&gt;成功标签&lt;/span&gt;&lt;span class=\"label label-info\"&gt;信息标签&lt;/span&gt;&lt;span class=\"label label-warning\"&gt;警告标签&lt;/span&gt;&lt;span class=\"label label-danger\"&gt;错误标签&lt;/span&gt; 徽章使用“badge”样式来实现。可以配合其他样式一起使用1&lt;span class=\"badge\"&gt;42&lt;/span&gt; 缩略图通过“thumbnail”样式配合bootstrap的网格系统来实现。1234567891011121314151617181920212223242526下面的结构表示的是在宽屏幕（可视区域大于768px）的时候，一行显示四个缩略图在窄屏（可视区域小于768px）的时候，一行只显示两个缩略图：&lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 col-md-3\"&gt; &lt;a href=\"#\" class=\"thumbnail\"&gt; 放图片 &lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-md-3\"&gt; &lt;a href=\"#\" class=\"thumbnail\"&gt; 放图片 &lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-md-3\"&gt; &lt;a href=\"#\" class=\"thumbnail\"&gt; 放图片 &lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-xs-6 col-md-3\"&gt; &lt;a href=\"#\" class=\"thumbnail\"&gt; 放图片 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 缩略图添加标题,内容,按钮还可以让缩略图配合标题、描述内容，按钮等,在仅有缩略图的基础上，添加了一个div名为“caption“的容器，在这个容器中放置其他内容，比如说标题，文本描述，按钮等123456789101112131415&lt;div class=\"row\"&gt; &lt;div class=\"col-xs-6 col-md-3\"&gt; &lt;a href=\"#\" class=\"thumbnail\"&gt; 放图片 &lt;/a&gt; &lt;div class=\"caption\"&gt; &lt;h3&gt;Bootstrap框架系列教程&lt;/h3&gt; &lt;p&gt;Bootstrap框架是一个优秀的前端框，就算您是一位后端程序员或者你是一位不懂设计的前端人员，你也能依赖于Bootstrap制作做优美的网站...&lt;/p&gt; &lt;p&gt; &lt;a href=\"##\" class=\"btn btn-primary\"&gt;开始学习&lt;/a&gt; &lt;a href=\"##\" class=\"btn btn-info\"&gt;正在学习&lt;/a&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 警示框用来和用户进行交流,展示各种各样的提示信息,Bootstrap框架通过“alert“样式来实现警示框效果,都有一个基类.alert1、成功警示框：告诉用用户操作成功，在“alert”样式基础上追加“alert-success”样式，具体呈现的是背景、边框和文本都是绿色；2、信息警示框：给用户提供提示信息，在“alert”样式基础上追加“alert-info”样式，具体呈现的是背景、边框和文本都是浅蓝色；3、警告警示框：提示用户小心操作（提供警告信息），在“alert”样式基础上追加“alert-warning”样式，具体呈现的是背景、边框、文本都是浅黄色4、错误警示框：提示用户操作错误，在“alert”样式基础上追加“alert-danger”样式，具体呈现的是背景、边框和文本都是浅红色。1234&lt;div class=\"alert alert-success\" role=\"alert\"&gt;劳柏明！&lt;/div&gt;&lt;div class=\"alert alert-info\" role=\"alert\"&gt;劳柏明！&lt;/div&gt;&lt;div class=\"alert alert-warning\" role=\"alert\"&gt;劳柏明！&lt;/div&gt;&lt;div class=\"alert alert-danger\" role=\"alert\"&gt;劳柏明！&lt;/div&gt; 可关闭的警示框1、需要在基本警示框“alert”的基础上添加“alert-dismissable”样式。2、在button标签中加入class=”close”类，实现警示框关闭按钮的样式。3、要确保关闭按钮元素上设置了自定义属性：“data-dismiss=”alert””12345678910111213141516&lt;div class=\"alert alert-success alert-dismissable\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\" data-dismiss=\"alert\"&gt;&amp;times;&lt;/button&gt; 劳柏明！&lt;/div&gt;&lt;div class=\"alert alert-info alert-dismissable\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\" data-dismiss=\"alert\"&gt;&amp;times;&lt;/button&gt; 劳柏明&lt;/div&gt;&lt;div class=\"alert alert-warning alert-dismissable\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\" data-dismiss=\"alert\"&gt;&amp;times;&lt;/button&gt; 劳柏明，劳柏明&lt;/div&gt;&lt;div class=\"alert alert-danger alert-dismissable\" role=\"alert\"&gt; &lt;button class=\"close\" type=\"button\" data-dismiss=\"alert\"&gt;&amp;times;&lt;/button&gt; 劳柏明，劳柏明&lt;/div&gt; 警示框链接通过给警示框加的链接添加一个名为“alert-link”的类名12345&lt;div class=\"alert alert-success\" role=\"alert\"&gt; &lt;strong&gt; &lt;/strong&gt; 点链接有福利 &lt;a href=\"#\" class=\"alert-link\"&gt;进来吧&lt;/a&gt;&lt;/div&gt; 进度条他提供了两个容器，外容器使用“progress”样式，子容器使用“progress-bar”样式。其中progress用来设置进度条的容器样式，而progress-bar用于限制进度条的进度。子容器都有一个基类.progress-bar,父容器都有一个基类.progress 基本进度条123456789101112131、role属性作用：告诉搜索引擎这个div的作用是进度条。2、aria-valuenow=\"40\"属性作用：当前进度条的进度为40%。3、aria-valuemin=\"0\"属性作用：进度条的最小值为0%。4、aria-valuemax=\"100\"属性作用：进度条的最大值为100%。&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar\" style=\"width:40%;\" role=\"progressbar\" aria-valuenow=\"40\" aria-valuemin=\"0\" aria-valuemax=\"100\"&gt; &lt;span class=\"sr-only\"&gt;40% Complete&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; 彩色进度条progress-bar-info：表示信息进度条，进度条颜色为蓝色 progress-bar-success：表示成功进度条，进度条颜色为绿色 progress-bar-warning：表示警告进度条，进度条颜色为黄色 progress-bar-danger：表示错误进度条，进度条颜色为红色123456789101112&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width:40%\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-info\" style=\"width:60%\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-warning\" style=\"width:80%\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-danger\" style=\"width:50%\"&gt;&lt;/div&gt;&lt;/div&gt; 条纹进度条条纹进度条只需要在进度条的容器“progress”基础上增加类名“progress-striped”123456789101112&lt;div class=\"progress progress-striped\"&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width:40%\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"progress progress-striped\"&gt; &lt;div class=\"progress-bar progress-bar-info\" style=\"width:60%\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"progress progress-striped\"&gt; &lt;div class=\"progress-bar progress-bar-warning\" style=\"width:80%\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"progress progress-striped\"&gt; &lt;div class=\"progress-bar progress-bar-danger\" style=\"width:50%\"&gt;&lt;/div&gt;&lt;/div&gt; 动态条纹进度条在进度条“progress progress-striped”两个类的基础上再加入“active”类名其实现原理主要通过CSS3的animation来完成。首先通过@keyframes创建了一个progress-bar-stripes的动画，这个动画主要做了一件事，就是改变背景图像的位置，也就是background-position的值。123456789101112&lt;div class=\"progress progress-striped active\"&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width:40%\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"progress progress-striped active\"&gt; &lt;div class=\"progress-bar progress-bar-info\" style=\"width:60%\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"progress progress-striped active\"&gt; &lt;div class=\"progress-bar progress-bar-warning\" style=\"width:80%\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=\"progress progress-striped active\"&gt; &lt;div class=\"progress-bar progress-bar-danger\" style=\"width:50%\"&gt;&lt;/div&gt;&lt;/div&gt; 层叠进度条仅需要在“progress”容器中添加对应的进度条，同样要注意，层叠的进度条之和不能大于100%123456789101112131415161718192021&lt;h5&gt;正常层叠进度条&lt;/h5&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width:20%\"&gt;&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-info\" style=\"width:10%\"&gt;&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-warning\" style=\"width:30%\"&gt;&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-danger\" style=\"width:15%\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;h5&gt;不良效果层叠进度条&lt;/h5&gt; &lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width:20%\"&gt;&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-info\" style=\"width:40%\"&gt;&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-warning\" style=\"width:30%\"&gt;&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-danger\" style=\"width:45%\"&gt;&lt;/div&gt;&lt;/div&gt; &lt;h5&gt;层叠条纹进度条&lt;/h5&gt;&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-success\" style=\"width:20%\"&gt;&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-info\" style=\"width:20%\"&gt;&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-warning\" style=\"width:30%\"&gt;&lt;/div&gt; &lt;div class=\"progress-bar progress-bar-danger\" style=\"width:15%\"&gt;&lt;/div&gt;&lt;/div&gt; Label进度条有很多时候是需要在进度条中直接用相关的数值向用户传递完成的进度值,只需要在进度条中添加你需要的值,在0%的时候是没有颜色的123456&lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-success\" role=\"progressbar\" aria-valuenow=\"20\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width:20%\"&gt;20%&lt;/div&gt; &lt;/div&gt; &lt;div class=\"progress\"&gt; &lt;div class=\"progress-bar progress-bar-info\" role=\"progressbar\" aria-valuenow=\"70\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width:70%\"&gt;70%&lt;/div&gt;&lt;/div&gt; 媒体标签左边居左（或居右），内容居右（或居左）排列 把这样的效果称为媒体对象。 默认媒体对象媒体对像的容器：常使用“media”类名表示，用来容纳媒体对象的所有内容媒体对像的对象：常使用“media-object”表示,就是媒体对象中的对象，常常是图片媒体对象的主体：常使用“media-body”表示，就是媒体对像中的主体内容，可以是任何元素，常常是图片侧边内容媒体对象的标题：常使用“media-heading”表示，就是用来描述对象的一个标题，此部分可选pull-left”或者“pull-right”来控制媒体对象中的对象浮动方式123456789&lt;div class=\"media\"&gt; &lt;a class=\"pull-left\" href=\"#\"&gt; &lt;img class=\"media-object src=\"...\" alt=\"...\"&gt; &lt;/a&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;123456&lt;/h4&gt; &lt;div&gt;劳柏明柏明&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 媒体对象嵌套只需要将另一个媒体对象结构放置在媒体对象的主体内“media-body123456789101112131415161718192021222324252627&lt;div class=\"media\"&gt; &lt;a class=\"pull-left\" href=\"#\"&gt; &lt;img class=\"media-object\" src=\"http://a.disquscdn.com/uploads/users/3740/2069/avatar92.jpg?1406972031\" alt=\"...\"&gt; &lt;/a&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;&lt;/h4&gt; &lt;div&gt;&lt;/div&gt; &lt;div class=\"media\"&gt; &lt;a class=\"pull-left\" href=\"#\"&gt; &lt;img class=\"media-object\" src=\"http://tp2.sinaimg.cn/3306361973/50/22875318196/0\" alt=\"...\"&gt; &lt;/a&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;&lt;/h4&gt; &lt;div&gt;&lt;/div&gt; &lt;div class=\"media\"&gt; &lt;a class=\"pull-left\" href=\"#\"&gt; &lt;img class=\"media-object\" src=\"http://tp4.sinaimg.cn/1167075935/50/22838101204/1\" alt=\"...\"&gt; &lt;/a&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;&lt;/h4&gt; &lt;div&gt;....&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 媒体对象列表在写结构的时候可以使用ul，并且在ul上添加类名“media-list”，而在li上使用“media”12345678910111213&lt;ul class=\"media-list\"&gt; &lt;li class=\"media\"&gt; &lt;a class=\"pull-left\" href=\"#\"&gt; &lt;img class=\"media-object\" src=\" \" alt=\"...\"&gt; &lt;/a&gt; &lt;div class=\"media-body\"&gt; &lt;h4 class=\"media-heading\"&gt;Media Header&lt;/h4&gt; &lt;div&gt;…&lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li class=\"media\"&gt;…&lt;/li&gt; &lt;li class=\"media\"&gt;…&lt;/li&gt;&lt;/ul&gt; 列表组可以用来制作列表清单、垂直导航等效果，也可以配合其他的组件制作出更漂亮的组件。 基础列表组list-group：列表组容器，常用的是ul元素，当然也可以是ol或者div元素list-group-item：列表项，常用的是li元素，当然也可以是div元素1234567&lt;ul class=\"list-group\"&gt; &lt;li class=\"list-group-item\"&gt;carrot&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;carrot&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;carrot&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;carrot&lt;/li&gt; &lt;li class=\"list-group-item\"&gt;carrot&lt;/li&gt;&lt;/ul&gt; 自定义列表组list-group-item-heading：用来定义列表项头部样式list-group-item-text：用来定义列表项主要内容12345678910&lt;div class=\"list-group\"&gt; &lt;a href=\"##\" class=\"list-group-item\"&gt; &lt;h4 class=\"list-group-item-heading\"&gt;&lt;/h4&gt; &lt;p class=\"list-group-item-text\"&gt;...&lt;/p&gt; &lt;/a&gt; &lt;a href=\"##\" class=\"list-group-item\"&gt; &lt;h4 class=\"list-group-item-heading\"&gt;&lt;/h4&gt; &lt;p class=\"list-group-item-text\"&gt;...&lt;/p&gt; &lt;/a&gt;&lt;/div&gt; 多彩列表组list-group-item-success：成功，背景色绿色list-group-item-info：信息，背景色蓝色list-group-item-warning：警告，背景色为黄色list-group-item-danger：错误，背景色为红色1234567&lt;div class=\"list-group\"&gt; &lt;a href=\"##\" class=\"list-group-item active\"&gt;&lt;span class=\"badge\"&gt;5902&lt;/span&gt;&lt;/a&gt; &lt;a href=\"##\" class=\"list-group-item list-group-item-success\"&gt;&lt;span class=\"badge\"&gt;15902&lt;/span&gt;&lt;/a&gt; &lt;a href=\"##\" class=\"list-group-item list-group-item-info\"&gt;&lt;span class=\"badge\"&gt;59020&lt;/span&gt;&lt;/a&gt; &lt;a href=\"##\" class=\"list-group-item list-group-item-warning\"&gt;&lt;span class=\"badge\"&gt;0&lt;/span&gt;Sass中国&lt;/a&gt; &lt;a href=\"##\" class=\"list-group-item list-group-item-danger\"&gt;&lt;span class=\"badge\"&gt;10&lt;/span&gt;&lt;/a&gt;&lt;/div&gt; 面板主要作用就是用来处理一些其他组件无法完成的功能。有一个基类.panel 基础面板就是一个div容器运用了“panel”样式，产生一个具有边框的文本显示块。由于“panel”不控制主题颜色，所以在“panel”的基础上增加一个控制颜色的主题“panel-default”，另外在里面添加了一个“div.panel-body”来放置面板主体内容123&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-body\"&gt;我是一个基础面板，带有默认主题样式风格&lt;/div&gt;&lt;/div&gt; 有头有尾的面板panel-heading：用来设置面板头部样式panel-footer：用来设置面板尾部样式12345&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt;…&lt;/div&gt; &lt;div class=\"panel-footer\"&gt;&lt;/div&gt;&lt;/div&gt; 彩色面板panel-primary：重点蓝 panel-success：成功绿 panel-info:信息蓝 panel-warning：警告黄 panel-danger：危险红 12345678910&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt;…&lt;/div&gt; &lt;div class=\"panel-footer\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"panel panel-primary\"&gt;…&lt;/div&gt;&lt;div class=\"panel panel-success\"&gt;…&lt;/div&gt;&lt;div class=\"panel panel-info\"&gt;…&lt;/div&gt;&lt;div class=\"panel panel-warning\"&gt;…&lt;/div&gt;&lt;div class=\"panel panel-danger\"&gt;…&lt;/div&gt; 面板嵌套表格在使用面板的时候，都会在panel-body放置需要的内容，可能是图片、表格或者列表等。1234567在实际应用运中，你或许希望表格和面板边缘不需要有任何的间距。但由于panel-body设置了一个padding：15px的值，为了实现这样的效果。我们在实际使用的时候需要把table提取到panel-body外面&lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt;&lt;/div&gt; &lt;div class=\"panel-body\"&gt;…&lt;/div&gt; &lt;table class=\"table table-bordered\"&gt;…&lt;/table&gt; &lt;div class=\"panel-footer\"&gt;&lt;/div&gt;&lt;/div&gt; 导入JavaScript插件Bootstrap的JavaScript插件可以单独导入到页面中，也可以一次性导入到页面中。因为在Bootstrap中的JavaScript插件都是依赖于jQuery库，所以不论是单独导入还一次性导入之前必须先导入jQuery库。动画过渡（Transitions）:对应的插件文件“transition.js”模态弹窗（Modal）:对应的插件文件“modal.js”下拉菜单（Dropdown）：对应的插件文件“dropdown.js”滚动侦测（Scrollspy）：对应的插件文件“scrollspy.js”选项卡（Tab）：对应的插件文件“tab.js”提示框（Tooltips）：对应的插件文件“tooltop.js”弹出框（Popover）：对应的插件文件“popover.js”警告框（Alert）：对应的插件文件“alert.js”按钮（Buttons）：对应的插件文件“button.js”折叠/手风琴（Collapse）：对应的插件文件“collapse.js”图片轮播Carousel：对应的插件文件“carousel.js”自动定位浮标Affix：对应的插件文件“affix.js” 动画过渡默认情况之下，Bootstrap框架中以下组件使用了过渡动画效果模态弹出窗（Modal）的滑动和渐变效果；选项卡（Tab）的渐变效果；警告框（Alert）的渐变效果；图片轮播（Carousel）的滑动效果。 js插件模态弹出框在 Bootstrap 框架中把模态弹出框统一称为 Modal，分别运用了“modal”、“modal-dialog”和“modal-content”样式，而弹出窗真正的内容都放置在“modal-content”中，其主要又包括三个部分： 弹出框头部，一般使用“modal-header”表示，主要包括标题和关闭按钮 弹出框主体，一般使用“modal-body”表示，弹出框的主要内容 弹出框脚部，一般使用“modal-footer”表示，主要放置操操作按钮 1234567891011121314151617&lt;div class=\"modal\" id=\"mymodal-data\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"mySmallModalLabel\" aria-hidden=\"true\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt;&lt;span class=\"sr-only\"&gt;Close&lt;/span&gt;&lt;/button&gt; &lt;h4 class=\"modal-title\"&gt;模态弹出窗标题&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;p&gt;模态弹出窗主体内容&lt;/p&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"&gt;关闭&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 模态弹出框原理模态弹出框”有以下几个特点： 1、模态弹出窗是固定在浏览器中的。 2、单击右侧全屏按钮，在全屏状态下，模态弹出窗宽度是自适应的，而且modal-dialog水平居中。 3、当浏览器视窗大于768px时，模态弹出窗的宽度为600px。 蒙版样式在Bootstrap框架中为模态弹出窗也添加了一个这样的蒙层样式“modal-backdrop”给其添加了一个过渡动画，从fade到in，把opacity值从0变成了0.5。Bootstrap框架还为模态弹出窗提供了不同尺寸，一个是大尺寸样式“modal-lg”，另一个是小尺寸样式“modal-sm”1234567891011121314151617181920&lt;button class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\".bs-example-modal-lg\"&gt;大的模态弹出窗&lt;/button&gt;&lt;div class=\"modal fade bs-example-modal-lg\" tabindex=\"-1\" role=\"dialog\" aria-labelledby=\"myLargeModalLabel\" aria-hidden=\"true\"&gt; &lt;div class=\"modal-dialog modal-lg\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\"&gt;&lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt;&lt;span class=\"sr-only\"&gt;Close&lt;/span&gt;&lt;/button&gt; &lt;h4 class=\"modal-title\"&gt;模态弹出窗标题&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;p&gt;模态弹出窗主体内容&lt;/p&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"&gt;关闭&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\"&gt;保存&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 触发2种方法模态弹出窗声明，只需要自定义两个必要的属性：data-toggle和data-target fade 让其淡入方法一:1、data-toggle必须设置为modal(toggle中文翻译过来就是触发器)； 2、data-target可以设置为CSS的选择符，也可以设置为模态弹出窗的ID值，一般情况设置为模态弹出窗的ID值，因为ID值是唯一的值。 方法二：触发模态弹出窗也可以是一个链接元素，那么可以使用链接元素自带的href属性替代data-target属性， 123456789101112131415161718192021&lt;!-- 触发模态弹出窗的元素 方法一 --&gt;&lt;button type=\"button\" data-toggle=\"modal\" data-target=\"#mymodal\" class=\"btn btn-primary\"&gt;点击我会弹出模态弹出窗&lt;/button&gt;&lt;!-- 模态弹出窗 --&gt;&lt;div class=\"modal fade\" id=\"mymodal\"&gt; &lt;div class=\"modal-dialog\"&gt; &lt;div class=\"modal-content\"&gt; &lt;!-- 模态弹出窗内容 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;-----------------------------------------------&lt;!-- 触发模态弹出窗的元素 方法二 --&gt;&lt;a data-toggle=\"modal\" href=\"#mymodal\" class=\" btn btn-primary\" &gt;点击我会弹出模态弹出窗&lt;/a&gt;&lt;!-- 模态弹出窗 --&gt;&lt;div class=\"modal fade\" id=\"mymodal\" &gt; &lt;div class=\"modal-dialog\" &gt; &lt;div class=\"modal-content\" &gt; &lt;!-- 模态弹出窗内容 --&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 动画效果可通过给“.modal”增加类名“fade”为模态弹出框增加一个过渡动画效果 data用法具体介绍1.data-toggle：必须设置为 modal，用来控制模态窗的显示； 2.data-target：用于指定具体要触发的模态窗是哪一个； 3.data-backdrop：点击背景是否可以关闭模态窗；true, static 4.data-keyboard：按下ESC键，是否可以关闭模态窗。true ,false js控制123456找到显示的那个元素调用modal()方法 $(function()&#123; $(\".btn\").click(function()&#123; $(\"#themodal\").modal(); &#125;); &#125;); js控制参数设置toggle 触发时，反转模态弹出窗的状态。如果模态弹出窗是显示的，则关闭；反之，如果模态弹出窗是关闭的，则显示show 触发时，显示模态弹出窗hide 触发时，关闭模态弹出窗1234567&lt;script&gt; $(function()&#123; $(\".btn\").click(function()&#123; $(\"#mymodal\").modal(\"toggle\"); &#125;); &#125;);&lt;/script&gt; js插件下拉菜单与滚动监视器下拉菜单被点击的菜单项链接或按钮需要添加自定义属性 data-toggle=”dropdown” 实现下拉菜单原理：Dropdown插件加载时，对所有带 有“data-toggle=dropdown”样式的元素绑定了事件，用户单击带有“data-toggle=dropdown”样式的链接或按钮时， 会触发JavaScript事件代码。当用户点击带有“data-toggle=dropdown”样式的链接或按钮时，下拉菜单的父容器（下面的示例是 “li class=”dropdown””）会添加一个open类名，此时下拉菜单显示；再次单击时，JavaScript会删除刚添加的open类 名，此时下拉菜单将隐藏。12345678&lt;li class=\"dropdown\"&gt; &lt;a href=\"##\" data-toggle=\"dropdown\" class=\"dropdown-toggle\" role=\"button\" id=\"tutorial\"&gt;教程&lt;b class=\"caret\"&gt;&lt;/b&gt;&lt;/a&gt; &lt;ul class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"tutorial\"&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"##\"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"##\"&gt;HTML5&lt;/a&gt;&lt;/li&gt; &lt;li role=\"presentation\"&gt;&lt;a href=\"##\"&gt;Sass&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/li&gt; js触发使用JavaScript调用dropdown()方法后，单击激活按钮，会弹出下拉菜单，再次单击的时候会收起下拉菜单。123$(function()&#123; $(\".dropdown-toggle\").dropdown();&#125;) 滚动监视器设计一个带有下拉菜单的导航条。分别为导航条和下拉菜单项定义一个锚点链接，锚点分别为“#blog”,“html”,“#css”,“#sass”,“#js”,“php”,“#about”。同时为导航条定义一个id值“navbar-menu”（id名称可自由定义），方便滚动监控。 计监控对象。这里将监控对象内容都放置在一个div名为scrollspy（这个类名可自由定义）的容器中，其中放了多个子内容框。每个子内容框有一个标题，而且每个标题的ID值与导航菜单项中的锚点链接名相对应，并且注意加入“data-target=”#navbar-menu””属性（这个属性值要与前面的nav标签的id名称保持一致）123456789101112131415161718192021222324&lt;nav id=\"navbar-menu\" class=\"navbar navbar-default navbar-static\" role=\"navigation\"&gt; …&lt;/nav&gt;data-target='与上面导航条的id一致'&lt;div class=\"scrollspy\" data-target=\"#navbar-menu\"&gt; &lt;h4 id=\"blog\"&gt;Blog&lt;/h4&gt; &lt;p&gt;…&lt;/p&gt; &lt;h4 id=\"html\"&gt;Html&lt;/h4&gt; &lt;p&gt;…&lt;/p&gt; &lt;h4 id=\"css\"&gt;CSS&lt;/h4&gt; &lt;p&gt;…&lt;/p&gt; &lt;h4 id=\"sass\"&gt;Sass&lt;/h4&gt; &lt;p&gt;…&lt;/p&gt; &lt;h4 id=\"js\"&gt;JavaScript&lt;/h4&gt; &lt;p&gt;…&lt;/p&gt; &lt;p&gt;…&lt;/p&gt; &lt;h4 id=\"php\"&gt;PHP&lt;/h4&gt; &lt;p&gt;…&lt;/p&gt; &lt;p&gt;…&lt;/p&gt; &lt;h4 id=\"about\"&gt;About&lt;/h4&gt; &lt;p&gt;…&lt;/p&gt; &lt;p&gt;…&lt;/p&gt;&lt;/div&gt; 属性触发为监控对象设置被监控的data属性：data-spy=”scroll”，指定监控的导航条：data-target=”#navbar-menu”。同时定义监控过程中滚动条偏移位置data-offset=”60”123&lt;div class=\"scrollspy\" data-spy=\"scroll\" data-target=\"#navbar-menu\" data-offset=\"60\"&gt; …&lt;/div&gt; js触发找到对应的div调用scrollspy(参数设置目标nav的id)123456789101112&lt;nav id=\"navbar-menu\" class=\"navbar navbar-default navbar-static\" role=\"navigation\"&gt; …&lt;/nav&gt;&lt;div class=\"scrollspy\" id=\"scrollspy\"&gt; …&lt;/div&gt;$(function()&#123; $(\"#scrollspy\").scrollspy(&#123; target: \"#navbar-menu\" &#125;);&#125;) 选项卡基本实现一个选项卡主要包括两个部分，其一是菜单项，其二是内容面板。选项卡中链接的锚点要与对应的面板内容容器的ID相匹配。通过a标签href实现12345678910111213141516&lt;!-- 选项卡组件（菜单项nav-tabs）--&gt;&lt;ul id=\"myTab\" class=\"nav nav-tabs\" role=\"tablist\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#bulletin\" role=\"tab\"&gt;公告&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#rule\" role=\"tab\"&gt;规则&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#forum\" role=\"tab\"&gt;论坛&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#security\" role=\"tab\"&gt;安全&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#welfare\" role=\"tab\"&gt;公益&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 选项卡面板 --&gt;&lt;div id=\"myTabContent\" class=\"tab-content\"&gt; &lt;div class=\"tab-pane fade in active\" id=\"bulletin\"&gt;公告内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"rule\"&gt;规则内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"forum\"&gt;论坛内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"security\"&gt;安全内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"welfare\"&gt;公益内容面板&lt;/div&gt;&lt;/div&gt; 触发切换效果1、选项卡导航链接中要设置 data-toggle=”tab”2、并且设置 data-target=”对应内容面板的选择符(一般是ID)”;3.面板内容统一放在 tab-content 容器中，而且每个内容面板 tab-pane 都需要设置一个独立的选择符（最好是ID）与选项卡中的 data-target 或 href 的值匹配。12345678910111213141516&lt;!-- 选项卡组件（菜单项nav-tabs）--&gt;&lt;ul id=\"myTab\" class=\"nav nav-tabs\" role=\"tablist\"&gt; &lt;li class=\"active\"&gt;&lt;a href=\"#bulletin\" role=\"tab\" data-toggle=\"tab\"&gt;公告&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#rule\" role=\"tab\" data-toggle=\"tab\"&gt;规则&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#forum\" role=\"tab\" data-toggle=\"tab\"&gt;论坛&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#security\" role=\"tab\" data-toggle=\"tab\"&gt;安全&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#welfare\" role=\"tab\" data-toggle=\"tab\"&gt;公益&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;!-- 选项卡面板 --&gt;&lt;div id=\"myTabContent\" class=\"tab-content\"&gt; &lt;div class=\"tab-pane fade in active\" id=\"bulletin\"&gt;公告内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"rule\"&gt;规则内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"forum\"&gt;论坛内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"security\"&gt;安全内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"welfare\"&gt;公益内容面板&lt;/div&gt;&lt;/div&gt; fade效果为了让面板的隐藏与显示在切换的过程效果更流畅，可以在面板中添加类名 fade，让其产生渐入的效果。在添加 fade 样式时，最初的默认显示的内容面板一定要记得加上 in 类名，不然其内容用户无法看到。12345678&lt;!-- 选项卡面板 --&gt;&lt;div id=\"myTabContent\" class=\"tab-content\"&gt; &lt;div class=\"tab-pane fade in active\" id=\"bulletin\"&gt;公告内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"rule\"&gt;规则内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"forum\"&gt;论坛内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"security\"&gt;安全内容面板&lt;/div&gt; &lt;div class=\"tab-pane fade\" id=\"welfare\"&gt;公益内容面板&lt;/div&gt;&lt;/div&gt; js触发在每个链接的单击事件中调用tab(“show”)方法，显示对应的标签面板内容123456$(function()&#123; $(\"#myTab a\").click(function(e)&#123; e.preventDefault(); $(this).tab(\"show\"); &#125;);&#125;) 提示框结构在Bootstrap框架中的提示框，结构非常简单，常常使用的是按钮button标签或者链接a标签来制作。不管是使用按钮还是链接来制作提示框，他们都有一个共性：通过 title 属性的值来定义提示信息(也可以使用自定义属性 data-original-title 来设置提示信息) 通过 data-placement=”?” 自定义属性来控制提示信息框的位置，根据四种不同的位置，data-placement具有四个值：top、right、bottom和left，分别表示提示框出现的位置在顶部、右边、底部和左边。 还有一个最重要的参数不可缺少，data-toggle=”tooltip”。 1234567&lt;button type=\"button\" class=\"btnbtn-default\" data-toggle=\"tooltip\" data-placement=\"left\" data-original-title=\"提示框居左\"&gt; 提示框居左&lt;/button&gt; js触发提示框找到需要提示元素调用tooltip()方法123456$(function()&#123; $('#myTooltip').tooltip(&#123; title:\"我是一个提示框，我在顶部出现\", placement:'top' &#125;);&#125;) 弹出框结构弹出框Popover和提示框tooltip相比，就多了一个content内容，123456789&lt;button type=\"button\" class=\"btn btn-default\" data-container=\"body\" data-placement=\"bottom\" data-toggle=\"popover\" data-original-title=\"Bootstrap弹出框标题\" data-content=\"Bootstrap弹出框的内容\" &gt; 猛击我吧&lt;/button&gt; js触发找到需要提示元素调用popover()方法12345678910&lt;button type=\"button\" class=\"btn btn-default\" data-toggle=\"popover\" data-placement=\"bottom\" title=\"提示框居左\" data-content=\"我是弹出框的内容\" data-trigger=\"hover\" data-dalay=\"600\"&gt; 猛击我吧 &lt;/button&gt; js插件手风琴结构手风琴最关键的部分，就是每个标题对应有一个内容，在Bootstrap框架中将这两个部分组合起来称为一个panel页板12345678910&lt;div class=\"panel-group\" id=\"accordion\"&gt; &lt;div class=\"panel panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4 class=\"panel-title\"&gt;&lt;a data-toggle=\"collapse\" data-parent=\"#accordion\" href=\"#collapseOne\"&gt;标题一&lt;/a&gt;&lt;/h4&gt; &lt;/div&gt; &lt;div id=\"collapseOne\" class=\"panel-collapse collapse in\"&gt; &lt;div class=\"panel-body\"&gt;标题一对应的内容&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 触发方法触发手风琴可以通过自定义的 data-toggle 属性来触发。其中data-toggle值设置为 collapse，data-target=”#折叠区标识符”。 设计一个面板组合，里面有三个折叠区12345&lt;div class=\"panel-group\" id=\"myAccordion\"&gt; &lt;div class=\"panel panel-accordion panel-default\"&gt;&lt;/div&gt; &lt;div class=\"panel panel-accordion panel-default\"&gt;&lt;/div&gt; &lt;div class=\"panel panel-accordion panel-default\"&gt;&lt;/div&gt;&lt;/div&gt; 给面板添加内容，每个面板包括两个部分，第一个是面板标题 panel-heading，并且在这里面添加标题 panel-title。第二个部分是面板内容，也就是折叠区，使用 panel-collapse 样式12345678&lt;div class=\"panel panel-accordion panel-default\"&gt; &lt;div class=\"panel-heading\"&gt; &lt;h4 class=\"panel-title\"&gt;标题一&lt;/h4&gt; &lt;/div&gt; &lt;div class=\"panel-collapse\"&gt; &lt;div class=\"panel-body\"&gt;折叠区内容...&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; js插件图片轮播结构设计轮播图片的容器。在 Bootstrap 框架中采用 carousel 样式，并且给这个容器定义一个 ID 值，方便后面采用 data 属性来声明触发。1&lt;div id=\"slidershow\" class=\"carousel\"&gt;&lt;/div&gt; 设计轮播图片计数器。在容器 div.carousel 的内部添加轮播图片计算器，采用 carousel-indicators 样式，其主要功能是显示当前图片的播放顺序(有几张图片就放置几个li)1234567891011&lt;div id=\"slidershow\" class=\"carousel\"&gt;&lt;!-- 设置图片轮播的顺序 --&gt; &lt;ol class=\"carousel-indicators\"&gt; &lt;li class=\"active\"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; ... &lt;/ol&gt;&lt;/div&gt; 设计轮播图片播放区。轮播图整个效果中，播放区是最关键的一个区域，这个区域主要用来放置需要轮播的图片。这个区域使用 carousel-inner 样式来控制，而且其同样放置在 carousel 容器内，并且通过 item 容器来放置每张轮播的图片：1234567891011121314151617181920212223242526272829&lt;!-- 设置轮播图片 --&gt; &lt;div class=\"carousel-inner\"&gt; &lt;div class=\"item active\"&gt; &lt;a href=\"##\"&gt;&lt;img src=\"http://images3.c-ctrip.com/rk/201407/ll580x145.jpg\" alt=\"\"&gt;&lt;/a&gt; &lt;!-- 图片对应标题和描述内容 --&gt; &lt;div class=\"carousel-caption\"&gt; &lt;h3&gt;图片标题&lt;/h3&gt; &lt;p&gt;描述内容...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"##\"&gt;&lt;img src=\"http://images3.c-ctrip.com/dj/201408/zj/zj_580145.jpg\" alt=\"\"&gt;&lt;/a&gt; &lt;!-- 图片对应标题和描述内容 --&gt; &lt;div class=\"carousel-caption\"&gt; &lt;h3&gt;图片标题&lt;/h3&gt; &lt;p&gt;描述内容...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; … &lt;div class=\"item\"&gt; &lt;a href=\"##\"&gt;&lt;img src=\"http://images3.c-ctrip.com/dj/201408/zqgq_580145.jpg\" alt=\"\"&gt;&lt;/a&gt; &lt;!-- 图片对应标题和描述内容 --&gt; &lt;div class=\"carousel-caption\"&gt; &lt;h3&gt;图片标题&lt;/h3&gt; &lt;p&gt;描述内容...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 设计轮播图片控制器。很多时候轮播图片还具有一个向前播放和向后播放的控制器。在 Carousel 中通过 carousel-control 样式配合 left 和 right 来实现。其中left表示向前播放，right表示向后播放。其同样放在carousel容器内 1234567&lt;!-- 设置轮播图片控制器 --&gt; &lt;a class=\"left carousel-control\" href=\"\" &gt; &lt;span class=\"glyphicon glyphicon-chevron-left\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class=\"right carousel-control\" href=\"\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-right\"&gt;&lt;/span&gt; &lt;/a&gt; 触发方法data-ride 属性：取值 carousel，并且将其定义在 carousel 上。data-target 属性：取值 carousel 定义的 ID 名或者其他样式识别符，如前面示例所示，取值为“#slidershow”，并且将其定义在轮播图计数器的每个 li 上。data-slide 属性：取值包括 prev，next，prev表示向后滚动，next 表示向前滚动。该属性值同样定义在轮播图控制器的 a 链接上，同时设置控制器 href 值为容器 carousel 的 ID 名或其他样式识别符。data-slide-to 属性：用来传递某个帧的下标，比如 data-slide-to=”2”，可以直接跳转到这个指定的帧（下标从0开始计），同样定义在轮播图计数器的每个 li 上。在这里需要注意可以为 #slidershow 层添加 slide 样式，使用图片与图片切换效果有平滑感1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=\"slidershow\" class=\"carousel slide\" data-ride=\"carousel\"&gt; &lt;!-- 设置图片轮播的顺序 --&gt; &lt;ol class=\"carousel-indicators\"&gt; &lt;li class=\"active\" data-target=\"#slidershow\" data-slide-to=\"0\"&gt;1&lt;/li&gt; &lt;li data-target=\"#slidershow\" data-slide-to=\"1\"&gt;2&lt;/li&gt; &lt;li data-target=\"#slidershow\" data-slide-to=\"2\"&gt;3&lt;/li&gt; &lt;/ol&gt; &lt;!-- 设置轮播图片 --&gt; &lt;div class=\"carousel-inner\"&gt; &lt;div class=\"item active\"&gt; &lt;a href=\"##\"&gt;&lt;img src=\"http://images3.c-ctrip.com/rk/201407/ll580x145.jpg\" alt=\"\"&gt;&lt;/a&gt; &lt;div class=\"carousel-caption\"&gt; &lt;h3&gt;图片标题1&lt;/h3&gt; &lt;p&gt;描述内容1...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"##\"&gt;&lt;img src=\"http://images3.c-ctrip.com/dj/201408/zj/zj_580145.jpg\" alt=\"\"&gt;&lt;/a&gt; &lt;div class=\"carousel-caption\"&gt; &lt;h3&gt;图片标题2&lt;/h3&gt; &lt;p&gt;描述内容2...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"item\"&gt; &lt;a href=\"##\"&gt;&lt;img src=\"http://images3.c-ctrip.com/dj/201408/zqgq_580145.jpg\" alt=\"\"&gt;&lt;/a&gt; &lt;div class=\"carousel-caption\"&gt; &lt;h3&gt;图片标题3&lt;/h3&gt; &lt;p&gt;描述内容3...&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;a class=\"left carousel-control \" href=\"#slidershow\" role=\"button\" data-slide=\"prev\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-left\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;a class=\"right carousel-control\" href=\"#slidershow\" role=\"button\" data-slide=\"next\"&gt; &lt;span class=\"glyphicon glyphicon-chevron-right\"&gt;&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; data其他参数data-interval 5000 幻灯片轮换的等待时间（毫秒）。如果为false,轮播将不会自动开始循环 data-pause默认鼠标悬停留在幻灯片区域即停止播放，离开即开始播放 data-wrap 轮播是否持续循环123&lt;div id=\"slidershow\" class=\"carousel\" data-ride=\"carousel\" data-wrap=\"false\" data-interval=\"1000\"&gt; ......&lt;/div&gt; js插件Affix其主要功能就是通过插件给某个元素（需要固定的元素）添加或删除 affix 类名，实现元素在浏览器窗口中固定（元素带有 affix 类名固定）和不固定（元素不带有 affix 类名）的效果 触发方法ata-offset-top 用来设置元素距离顶部的距离。比如 90，表示元素距离顶部 90px，当用户从顶部向下拖动滚动条，当滚动的距离大于 90px 时，affix 元素不再滚动，就会固定在浏览器窗口顶部。data-offset-bottom 刚好与 data-offset-top 相反。data-spy：取值 affix，表示元素固定不变的。1&lt;div data-spy=\"affix\" data-offset=\"90\"&gt;affix元素&lt;/div&gt; 总结当你看到最后面一句话的时候,恭喜你,你肯定没有从头看到尾.不过没关系,以后那个不懂就查那个就好啦,终于总结完了,简直开心的不要不要的.再也不用担心我的Bootstarp咯,后面是利用Bootstarp进行一个简单的网页布局.学习原地址:[慕课网]http://www.imooc.com/course/list?c=bootstrap","tags":[{"name":"框架学习","slug":"框架学习","permalink":"//carrot.me/tags/框架学习/"}]},{"title":"less学习之旅","date":"2016-04-01T12:44:00.000Z","path":"2016/04/01/less学习之旅/","text":"让css像js那样,方便我们写样式 介绍ess 是一门 CSS 预处理语言，使用了类似CSS的语法，为CSS赋予了动态语言的特征。它扩展了 CSS 语言，增加了变量、Mixin(混合)、嵌套、函数和运算等特性，使 CSS 更易维护和扩展。此外，Less 可以运行在 Node 或浏览器端。用类似js的语法写css官网:http://www.lesscss.cn/ 使用方法客户端123link rel=\"stylesheet/less\" href=\"less/less.less\"&gt;&lt;!--用于编译LESS的--&gt;&lt;script type=\"text/javascript\" src=\"js/less.min.js\"&gt;&lt;/script&gt; 预编译12345在代码编辑器中，按照LESS的语法规则写好LESS文件；使用编译工具把.less文件编译成.css文件；把编译后的css文件引入到页面即可。 变量12345// LESS中定义变量@color:red;h1&#123; color: @color;&#125; 嵌套在一个选择器中嵌套另一个选择器来实现继承，这样很大程度上减少了代码量，并且代码看起来更加清晰。&amp;表示同级,没有则是后代12345678div&#123; h1&#123; color:red; &#125; &amp;.float &#123; float: left; &#125; &#125; 运算运算提供了加、减、乘、除操作，其他复杂的运算交给函数；通常我们可以做属性值和颜色的运算，这样就可以实现属性值之间的复杂关系。1234567891011@w:500px;div&#123; h1&#123; width: @w - 100; &#125;&#125;h1&#123; width: @w; border: 1px solid #000;&#125; 混合混合可以将一个定义好的class A轻松的引入到class B中，从而简单的实现class B 继承class A的所有属性。我们还可以带参数的调用，就像使用函数一样。可以有默认值，也可以没有默认值，没有的话，在调用的时候必须传参，有默认值的时候就可以不用传递参数；1234567891011.border-radius (@radius:5px) &#123; border-radius: @radius; -moz-border-radius: @radius; -webkit-border-radius: @radius;&#125;#header &#123; .border-radius(4px);&#125;.button &#123; .border-radius(6px); &#125; 函数LESS中的函数 - 映射了JavaScript函数代码,比如12345678saturate(@color, 10%); // 饱和度增加 10%desaturate(@color, 10%); // 饱和度降低 10%lighten(@color, 10%); // 亮度增加 10%darken(@color, 10%); // 亮度降低 10%fadein(@color, 10%); // 透明度增加 10%fadeout(@color, 10%); // 透明度降低 10%fade(@color, 50%); // 设定透明度为 50%spin(@color, 10); // 色相值增加 10 123456用法@base: #f04615;.class &#123; color: saturate(@base, 5%); background-color: lighten(spin(@base, 8), 25%);&#125; 匹配类似js中的if else判断，只有匹配成功才能起作用12345678910111213141516171819.mixin (dark, @color) &#123; color: darken(@color, 10%);&#125;.mixin (light, @color) &#123; color: lighten(@color, 10%);&#125;@_匹配所有.mixin (@_, @color) &#123; display: block;&#125;输出@switch: light;.class &#123; .mixin(@switch, #888);&#125;.class &#123; color: #a2a2a2; display: block;&#125; 导入1@import \"less.less\"; // 注意：less文件扩展名可选 注释123// 不会被编译器编译的注释/**/是可以被编译器编译的注释~’ ’ 表示的是禁止被编译 作用域首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止.123456789101112@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125;#footer &#123; color: @var; // red &#125;","tags":[{"name":"less","slug":"less","permalink":"//carrot.me/tags/less/"}]},{"title":"移动web学习之模仿京东M站","date":"2016-03-10T12:15:00.000Z","path":"2016/03/10/mobile-移动web开发/","text":"移动端的web网页好久没更新了,因为又去学习新的东西啦.学习完才能够更新顺便复习一下嘛.最近学什么呢,就是大家手上的手机啦,对于移动web来说,虽然很多人都是用APP的,但是也有很大一部分人是用web网页去浏览的.虽然这一部分的难度并不是很大,但是也是很重要,所以我也花了一点时间去学习,然后模仿了一下京东M站,当然知识简单的模仿啦.不过已经基本袭击了一些很基本的逻辑,这里说一下,我用的是原生js和原生CSS布局,没有用现在比较火的框架,当然啦,移动端比较火的框架后面我也会写上总结,不过能用好原生的话,想信去学习任何一门框架也是很快上手的.布局方面就不多做介绍了,主要过程分为布局和js代码实现css布局主要的重点就是,所有元素的宽高都是不能写死的,除了最外层的盒子,里面所有的宽度都是由百分比来完成.这也是移动web的核心把.里面内容会随着屏幕宽度的变化而变化js主要分为两个,一个是轮播图,一个是分类选项卡因为移动端所有基本不用考虑兼容性的问题,所以所有动画都是用css3去完成的.轮播的原理主要是让ul动起来,通过c3的过渡动画和形变属性来让ul走起来,因为是移动端,所以我们不用左右点击,取而带之的是手指的滑动,所以我们需要用移动端的事情去出来,用到了touchstart,touchmove,touchend3个事件去实现我们拖拽图片的功能,具逻辑看代码分类选项卡的功能基本和轮播图差不多,就是多了一个点击功能,移动端我们不用click事件,而是tap事件,但是js不支持这个事件,我们通过自己封装的方法来实现tap事件.当然也可以拖动,具体逻辑看代码 轮播图的实现功能123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166window.onload = function () &#123; changeColor(); bannerMove();&#125;/* * 顶部改变颜色 * */function changeColor() &#123; //找到顶部的节点 var header_c = document.querySelector('.header_c') //找到轮播图banner var banner = document.querySelector('#banner'); //轮播图的高 var bannerH = banner.offsetHeight; //记录透明度 var opt = 0; //监听滚动 window.onscroll = function () &#123; //获取滚动高度 var scrollT = document.body.scrollTop || document.documentElement.scrollTop; //判断滚动高度与轮播图高度关系 if (scrollT &lt; bannerH) &#123; //滚动高度小于轮播图高度 透明度为一个比例值 opt = scrollT / bannerH * 0.85; &#125; else &#123; //滚动高度大于轮播图高度 透明度为0.85 opt = 0.85; &#125; //改变顶部的背景颜色 header_c.style.background = 'rgba(210,30,85,' + opt + ')'; &#125;&#125;/* * 轮播图动起来 * */function bannerMove() &#123;// 找到轮播图banner var banner = document.querySelector('#banner');// 轮播图里面的ul var oUl = banner.getElementsByTagName('ul')[0];// 轮播图里面的ol var oOl = banner.getElementsByTagName('ol')[0]; //轮播里面ol的li小圆点 var oLi = oOl.children;// 轮播图索引 var index = 1;// 定时器 var timer = null;// 轮播图一张图片宽度 var bannerW = banner.offsetWidth;// 设置定时器 timer = setInterval(timerMove, 1000); //定时器匿名函数具体执行的方法都放里面 function timerMove() &#123; //索引++; index++; //调用过渡动画 oUlTransition(); //调用让ul动起来 每次移动-index*一个banner宽度 oUlTranslateX(-index * bannerW); &#125;// 让ul动起来的方法 var oUlTranslateX = function (x) &#123; oUl.style.transform = 'translateX(' + x + 'px)'; //兼容写法 oUl.style.webkitTransform = 'translateX(' + x + 'px)'; &#125; //ul动起来的过渡动画 var oUlTransition = function () &#123; oUl.style.transition = 'all 0.2s ease'; //兼容写法 oUl.style.webkitTransition = 'all 0.2s ease'; &#125; //每一次轮播图过渡动画结束方法 mjd.transitionEnd(oUl, function (e) &#123; // 判断索引的越界问题 if (index &gt;= 9) &#123; index = 1 &#125; else if (index &lt;= 0) &#123; index = 8; &#125; // 每一次结束都清除上一次的过渡动画 removeOulTransition() ; // 再次让ul移动 oUlTranslateX(-index * bannerW); //每次动画结束让小圆动动气 oLiMove(); &#125;);// 清除过渡动画方法 var removeOulTransition = function () &#123; oUl.style.transition = 'none'; //兼容写法 oUl.style.webkitTransition = 'none'; &#125;// 小圆点动起来的方法 var oLiMove = function () &#123; // 控制小圆点的索引 var OliIndex = index; // 判断小圆点越界问题 if (index &gt;= 9) &#123; OliIndex = 1 &#125; else if (index &lt;= 0) &#123; OliIndex = 8; &#125; // 排他清除所有小圆点类名 for (var i = 0; i &lt; oLi.length; i++) &#123; var obj = oLi[i]; obj.className = ''; &#125; // 当前的小圆点添加类名 oLi[OliIndex - 1].className = 'active'; &#125; //触摸的X位置 var startX = 0; //移动后X位置 var endX = 0; //移动后与移动前的差值 var disX = 0;// 触摸让轮播图停下来,并记录触摸的位置 oUl.addEventListener('touchstart', function (e) &#123; //关闭定时器 clearInterval(timer) //记录触摸X位置 startX = e.touches[0].clientX; &#125;) //滑动让轮播图动起来 oUl.addEventListener('touchmove', function (e) &#123; //阻止默认事件 e.preventDefault(); //记录移动X位置 endX = e.touches[0].clientX; //求移动后与移动前的差值 disX = startX - endX; //清除轮播图的过渡效果 removeOulTransition(); //滑动让轮播图动起来 oUlTranslateX(-index * bannerW - disX); &#125;); //离开屏幕方法 oUl.addEventListener('touchend', function (e) &#123; //判断拖动图片的距离是否大于一个图片1/3宽度 是的话根据移动方向让index改变 //并且已经拖动过了 if (Math.abs(disX) &gt; bannerW / 3 &amp;&amp; endX != 0) &#123; if (disX &gt; 0) &#123; index++; &#125; else &#123; index--; &#125; &#125; //添加过渡动画 oUlTransition(); //让ul动起来 oUlTranslateX(-index * bannerW); //指针动起来 oLiMove(); //初始化数据 startX = 0; endX = 0; disX = 0; //重新开启定时器 timer = setInterval(timerMove, 1000); &#125;)&#125; tap事件和上下拉动功能1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var box=document.querySelector('.box'); var ul=box.getElementsByTagName('ul')[0]; function addTransition() &#123; ul.style.transition='all 0.2s ease'; &#125; function removeTransiton() &#123; ul.style.transition='none'; &#125; function translateY(y) &#123; ul.style.transform='translateY('+y+'px)'; &#125; var ulH=ul.offsetHeight,boxH=box.offsetHeight; var startY=0,endY=0,disY=0,curY=0,maxY=0,minY=-(ulH-boxH),buff=150; ul.addEventListener('touchstart',function (e) &#123; startY=e.touches[0].clientY; &#125;); ul.addEventListener('touchmove',function (e) &#123; e.preventDefault(); endY=e.touches[0].clientY; disY=startY-endY; if((curY-disY)&lt;(maxY+buff)&amp;&amp;(curY-disY)&gt;(minY-buff))&#123; removeTransiton() translateY(curY-disY); &#125;else&#123; &#125; &#125;); ul.addEventListener('touchend',function (e) &#123; if((curY-disY)&gt;maxY)&#123; curY=maxY; &#125; else if((curY-disY)&lt;minY)&#123; curY=minY; &#125; else&#123; curY=curY-disY; &#125; addTransition(); translateY(curY); &#125;); for (var i = 0; i &lt; ul.children.length; i++) &#123; var oLi = ul.children[i]; oLi.index=i; &#125; mjd.tap(ul,function (e) &#123; var li=e.target.parentNode; var liH=li.offsetHeight; var count=Math.abs(Math.floor(minY/liH)); console.log(count); if(-liH*li.index&gt;minY&amp;&amp;li.index&lt;=count)&#123; addTransition(); translateY(-liH*li.index); curY=-liH*li.index; &#125; else&#123; translateY(minY); curY=minY; &#125; for (var i = 0; i &lt; ul.children.length; i++) &#123; var oLi = ul.children[i]; oLi.className=''; &#125; li.className='active'; &#125;) tap事件封装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 封装移动端tap方法* 条件,必须存在touchstart和touchend事件 * 两者的时间&lt;250 * 没有滑动* */mjd.tap=function (obj,callBack) &#123; // 判断传入的obj是否是对象 假如不是对象就结束程序 if(typeof obj!='object') return ; //开始触摸的时间 var startTime=0; //离开屏幕的时间 var endTime=0; //两者时间差 var disT=0; //记录是否滑动了 var isMove=false; //触摸事件 obj.addEventListener('touchstart',function (e) &#123; //求出触摸的时间 startTime=Date.now(); &#125;); //不能滑动 obj.addEventListener('touchemove',function (e) &#123; //滑动改变标志 isMove=true; &#125;) //离开屏幕 obj.addEventListener('touchend',function (e) &#123; //求出离开屏幕的时间 endTime=Date.now(); //求出时间差 disT=endTime-startTime; //根据tap事件的要求进行判断 if(disT&lt;250&amp;&amp;!isMove)&#123; //执行tap事件的操作 callBack&amp;&amp;callBack(e); &#125;else&#123; //不满足条件 console.log('不满足tap时间的条件'); &#125; //初始化数据 startTime=0; endTime=0; disT=0; isMove=false; &#125;)&#125;; 效果图如下 拖动图片","tags":[{"name":"移动web","slug":"移动web","permalink":"//carrot.me/tags/移动web/"}]},{"title":"Ajax学习之跨域和缓存","date":"2016-02-12T12:36:00.000Z","path":"2016/02/12/Ajax-跨域和缓存/","text":"跨域的原理和缓存的认识 跨域(jsonP)原理1.src可以拿到非当前域的数据 2.script的src的本质就是将导入文件中的内容拷贝到当前script标签中 3.如果src返回的数据符合 函数名称(参数); 格式, 那么就可以实现跨域 cookie:会话跟踪技术, 用于存储网页上的一些信息, 注意点: 1.存储大小限制4K左右 2.每个网页存储个数有限制/每个网站存储的个数也有限制（200个左右） 3.默认情况下cookie存储的内容是一次性的(一次会话结束就释放了) 4.我们可以通过expires=time;格式来指定过期时间, 只要没有超过过期时间一直都在 5.cookie是不可以跨浏览器的(在IE中保存的cookie, 不可以在火狐中使用) 6.cookie是不可以跨域的(跨域名) 7.我们在设置cookie的时候一次只能设置一个, 不能批量设置, 只能一条一条的添加 sessionStorage123456789101112131415161718192021222324252627$(function () &#123; var oInput = $(\"input\"); var oBtns = $(\"button\"); // 存储 oBtns.eq(0).click(function () &#123; window.sessionStorage.setItem(\"name\", oInput.val()); window.sessionStorage.setItem(\"age\", \"18\"); window.sessionStorage.setItem(\"gender\", \"male\"); window.sessionStorage.setItem(\"class\", \"初三三班\"); &#125;); // 获取 oBtns.eq(1).click(function () &#123; alert(window.sessionStorage.getItem(\"name\")); &#125;); // 更新 oBtns.eq(2).click(function () &#123; window.sessionStorage.setItem(\"name\", oInput.val()); &#125;); // 删除 oBtns.eq(3).click(function () &#123; window.sessionStorage.removeItem(\"name\"); &#125;); // 清空 oBtns.eq(4).click(function () &#123; window.sessionStorage.clear(); &#125;);&#125;); localStorage和sessionStorage用法一模一样 1234567891011121314151617181920212223242526$(function () &#123; var oInput = $(\"input\"); var oBtns = $(\"button\");// 存储 oBtns.eq(0).click(function () &#123; window.localStorage.setItem(\"name\", oInput.val()); window.localStorage.setItem(\"age\", \"18\"); window.localStorage.setItem(\"gender\", \"male\"); window.localStorage.setItem(\"class\", \"初三三班\"); &#125;); // 获取 oBtns.eq(1).click(function () &#123; alert(window.localStorage.getItem(\"name\")); &#125;); // 更新 oBtns.eq(2).click(function () &#123; window.localStorage.setItem(\"name\", oInput.val()); &#125;); // 删除 oBtns.eq(3).click(function () &#123; window.localStorage.removeItem(\"name\"); &#125;); // 清空 oBtns.eq(4).click(function () &#123; window.localStorage.clear(); &#125;); &#125;); 应用缓存处理12345678910111213CACHE MANIFEST#指定需要缓存的文件(会缓存到本地)CACHE://需要缓存的地址#在此标题下列出的文件需要与服务器的连接，且不会被缓存NETWORK://不会被缓存的地址#当找不到资源a的时候就用资源b来替代, 并且会缓存资源b到本地FALLBACK:a.css b.css 哈希1234567window.onload = function () &#123; // 设置哈希 window.location.hash = \"3\";// 获取哈希// alert(window.location.hash);表现形式会加在url地址上?#3 &#125; # 简单的跨域运用. 通过指定接口参数获取数据，我们要做的是传入对应的参数，然后拿到参数进行不同的设置 代码如下 123456789101112131415161718192021222324252627282930&lt;script&gt; /* https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=ab&amp;cb=jQuery11020672211218553074_1491468814655 * */ var oInput=document.querySelector('input'); var oUl=document.querySelector('#oUl'); var url='https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su'; oInput.onkeyup=function () &#123; jsonP(&#123; 'url':url, 'cbName':'cb', 'data':&#123; 'wd':oInput.value &#125;, 'success':function (data) &#123; oUl.innerHTML = \"\"; var arr=data.s; for (var i = 0; i &lt; arr.length; i++) &#123; var obj = arr[i]; var oLi=document.createElement('li'); oLi.innerHTML=obj; oUl.appendChild(oLi); &#125; &#125; &#125;) &#125;&lt;/script&gt;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"//carrot.me/tags/Ajax/"}]},{"title":"Ajax学习之评论功能","date":"2016-02-11T14:15:00.000Z","path":"2016/02/11/Ajax-评论功能/","text":"通过后台获取数据,操作数据.这是一个评论功能,通过用户的评论把数据保存到后台,然后可以向后台请求数据把数据展示到页面给用户看.这个功能主要就是如何运用后台给的接口然后我们传入指定接口参数去操作数据. 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226 &lt;script&gt; // weibo.php?act=acc&amp;id=12 顶某一条数据\\ // weibo.php?act=del&amp;id=12 删除一条数据 // weibo.php?act=get_page_count 获取页数 // weibo.php?act=get&amp;page=1 获取一页数据 //weibo.php?act=add&amp;content=xxx 添加一条 // 返回：[&#123;id: ID, content: \"内容\", time: 时间戳, acc: 顶次数, ref: 踩次数&#125;, &#123;...&#125;, ...] /* 获取DOM节点 * */ window.onload = function () &#123; //输入框 var inputText = document.getElementById('tijiaoText'); //获取提交按钮 var oBtn = document.getElementById('btn_send'); //评论区 var oList = document.getElementById('messList'); //页数 var oPage = document.getElementById('page'); //url地址 var url = \"weibo.php\"; //页数 var pageNum = 1; //创建评论区内容的方法 function createDom(data) &#123; //创建节点 var div = document.createElement('div'); div.setAttribute('class', 'reply'); div.innerHTML = ' &lt;p class=\"replyContent\"&gt;' + data.content + '&lt;/p&gt;' + ' &lt;p class=\"operation\"&gt;&lt;span class=\"replyTime\"&gt;' + getTime(data.time) + '&lt;/span&gt;' + '&lt;span class=\"handle\"&gt;' + ' &lt;a href=\"javascript:;\" class=\"top\"&gt;' + data.acc + '&lt;/a&gt;' + '&lt;a href=\"javascript:;\" class=\"down_icon\"&gt;' + data.ref + '&lt;/a&gt;' + '&lt;a href=\"javascript:;\" class=\"cut\"&gt;删除&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;'; return div; &#125; //获取时间的方法 function getTime(time) &#123; //数据库时间单位是秒 转换成毫秒 var date = new Date(time * 1000); //用数据保存 var arr = [ date.getFullYear() + '-', (date.getMonth() + 1) + '-', date.getDate() + ' ', date.getHours() + ':', date.getMinutes() + ':', date.getSeconds() ]; //转换成字符串 var str = arr.join(''); return str; &#125;;// 点击评论功能 oBtn.onclick = function () &#123; var content = inputText.value; myAjax(&#123; 'type': 'get', 'url': url, 'data': &#123; 'act': 'add', 'content': content &#125;, 'timeout': 1000, 'success': function (data) &#123; //转换格式 var dataText = data.responseText; var obj = eval('(' + dataText + ')'); //添加内容 默认踩和点 obj.content = content; obj.acc = 0; obj.ref = 0; //创建评论区 var div = createDom(obj); btnGood(div, obj); btnDel(div, obj); btnBad(div, obj); //长度不超过6个; if (oList.children.length == 6) &#123; oList.removeChild(oList.children[5]); &#125; //判断是否是第一次 if (oList.length == 0) &#123; oList.appendChild(div); &#125; else &#123; oList.insertBefore(div, oList.firstChild); &#125; &#125;, 'error': function (code) &#123; &#125; &#125;) &#125;; //获取数据功能 // weibo.php?act=get&amp;page=1 获取一页数据 getData(); function getData() &#123; myAjax(&#123; 'type': 'get', 'url': url, 'data': &#123; 'act': 'get', 'page': pageNum &#125;, 'success': function (data) &#123; //转换格式 var dataText = data.responseText; var arr = eval('(' + dataText + ')'); //清空 oList.innerHTML = ''; //更加获取数据创建节点 for (var i = 0; i &lt; arr.length; i++) &#123; var obj = arr[i]; var div = createDom(obj); btnGood(div, obj); btnDel(div, obj); btnBad(div, obj); oList.appendChild(div); &#125; &#125;, 'error': function (code) &#123; &#125; &#125;) &#125; //赞功能 weibo.php?act=acc&amp;id=12 function btnGood(dom, data) &#123; var good = dom.getElementsByClassName('top')[0]; good.onclick = function () &#123; myAjax(&#123; 'type': 'get', 'url': url, 'data': &#123; 'act': 'acc', 'id': data['id'] &#125;, 'success': function (data) &#123; &#125;, 'error': function (code) &#123; &#125; &#125;); good.innerHTML = parseInt(good.innerHTML) + 1; &#125;; &#125; //踩功能 function btnBad(dom, data) &#123; var bad = dom.getElementsByClassName('down_icon')[0]; bad.onclick = function () &#123; myAjax(&#123; 'type': 'get', 'url': url, 'data': &#123; 'act': 'ref', 'id': data['id'] &#125;, 'success': function (data) &#123; &#125;, 'error': function (code) &#123; &#125; &#125;); bad.innerHTML = parseInt(bad.innerHTML) + 1; &#125;; &#125; //删除 function btnDel(dom, data) &#123; var del = dom.getElementsByClassName('cut')[0]; del.onclick = function () &#123; myAjax(&#123; 'type': 'get', 'url': url, 'data': &#123; 'act': 'del', 'id': data['id'] &#125;, 'success': function (data) &#123; &#125;, 'error': function (code) &#123; &#125; &#125;); dom.parentNode.removeChild(dom); &#125;; &#125;; //获取页数 weibo.php?act=get_page_count 获取页数 getPage(); function getPage() &#123; myAjax(&#123; 'type': 'get', 'url': url, 'data': &#123; 'act': 'get_page_count', &#125;, 'success': function (data) &#123; var obj = eval('(' + data.responseText + ')'); //根据页数创建页码 for (var i = 0; i &lt; obj['count']; i++) &#123; var oA = document.createElement('a'); oPage.appendChild(oA); oA.innerHTML = i + 1; oPage.children[pageNum - 1].setAttribute(\"class\", \"active\"); oA.onclick = function () &#123; pageNum = this.innerHTML; getData(); for (var i = 0, len = oPage.children.length; i &lt; len; i++) &#123; oPage.children[i].setAttribute(\"class\", \"\"); &#125; oPage.children[pageNum - 1].setAttribute(\"class\", \"active\"); &#125; &#125; &#125; &#125;) &#125; &#125; &lt;/script&gt;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"//carrot.me/tags/Ajax/"}]},{"title":"Ajax学习之原生js封装","date":"2016-02-10T12:36:00.000Z","path":"2016/02/10/Ajax-原生js封装/","text":"通过自定义封装Ajax的请求过程Ajax异步编程,可以通过不刷新页面的情况下向后台请求数据,这一部分虽然代码不多,但是重点是和后台打交道,我们需要懂一点后台的代码,而且我们工作重点是学会如何处理后台返回来的数据.这一部分是我需要加强的.因为没有后台,所以只能简单自己上网找一些接口或者数据库之类的代码,先看看原生js封装,这个是模仿jquery.,而且把jsonP也封装了.这样就很方便我们去操作后台返回来的数据,顺便封装了一些Ajax会用到的缓存方法,比如cookie. 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//设置cookiefunction setCookie(key,value,day) &#123; //没有过期时间 if(arguments.length==2)&#123; document.cookie = key+'='+value+'; '; &#125;else if(arguments.length==3)&#123; var date=new Date(); date.setDate(date.getDate()+day); document.cookie = key+\"=\"+value+\"; \"+ \"expires=\"+date+\";\"; &#125;&#125;//获取cookiefunction getCookie(key) &#123; var arr=document.cookie.split('; '); for (var i = 0; i &lt; arr.length; i++) &#123; var res=arr[i].split('='); if(res[0]==key)&#123; return res[1]; &#125; &#125;&#125;//删除cookiefunction removeCookie(key) &#123; setCookie(key, \"\", -1);&#125;//jsonP格式 (url,data,success,cbName)function jsonP(option) &#123; var temp=document.querySelector('#javascript'); if(temp)&#123; document.body.removeChild(temp); &#125; //随机名字 var name=('carrot'+Math.random()).replace('.',''); //全局函数 window[name]=option.success; option.data[option.cbName]= name; var str=jsonData(option.data); var oScript=document.createElement('script'); oScript.setAttribute('id','javascript'); oScript.src=option.url+'?'+str; document.body.appendChild(oScript);&#125;//把数据转换成对应格式function jsonData(data) &#123; //添加一个随机因子 data.t=Math.random(); //定义一个数组 var arr=[]; //通过for in 循环把数据放进数组 for(var key in data)&#123; arr.push(key+'='+encodeURI(data[key])); &#125; //数组变字符串通过&amp;连接 var str=arr.join('&amp;'); return str;&#125;// type,url,data,timeout,success,errorfunction myAjax(option) &#123; //没有传入地址直接结束 if(!option.url)&#123; return ; &#125; option.type = option.type || \"get\"; option.data = option.data || null; option.timeout = option.timeout || 0; var xhr=null; //兼容IE写法 window.XMLHttpRequest?xhr=new XMLHttpRequest():xhr=new ActiveXObject('Microsoft.XMLHTTP'); //把数据转换拼接形式 var str=jsonData(option.data); //判断请求方式 if(option.type.toLowerCase()=='get')&#123; //get请求 xhr.open('get',option.url+'?'+str,true); xhr.send(); &#125;else&#123; //post请求 xhr.open(option.type.toLowerCase(),option.url,true); //设置请求头 在open和send中间 xhr.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); //发送 xhr.send(str); &#125; xhr.onreadystatechange=function () &#123; if(xhr.readyState==4)&#123; //关闭定时器 clearTimeout(timer); if(xhr.status&gt;=200&amp;&amp;xhr.status&lt;300||xhr.status==304)&#123; //成功回调 option.success(xhr.responseText); &#125;else &#123; //失败回调 option.error(xhr.status); &#125; &#125; &#125;; //超时中断传送 if(option.timeout)&#123; var timer = setTimeout(function () &#123; // 如果请求超时了, 那么应该中断请求 xhr.abort(); &#125;, option.timeout); &#125;&#125;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"//carrot.me/tags/Ajax/"}]},{"title":"canvas学习之笨鸟飞游戏","date":"2016-02-09T10:11:00.000Z","path":"2016/02/09/canvas-笨鸟飞/","text":"在手机端很火的游戏哦,简单的实现这个游戏效果这个游戏代码也挺多,当初写这个游戏花了很长时间,不过可以通过这个游戏让自己的逻辑思维更加好,而且对面向对象更加深入了.这里用到了jquery一个小库,专门用了定义类名,方便我们实现面向对象,类似java那种用类名形式 整体思路笨鸟设计思路一: 游戏js 初始化帧数 设置一个run的游戏入口 里面开个定时器执行 游戏开始的函数 还需要游戏暂停 游戏结束函数 二:帧率js 初始化 总帧数 开始时间 开始帧数 真实帧数 里面定义一个方法计算真实帧数(帧数统计函数) 该函数让总帧数每帧都递增 记录当前时间 只有当前时间-开始时间&gt;1S的时候 才开始计算真实帧率 计算方法是 总帧数-开始的帧数 最后别忘了更新开始时间和开始帧数 开始时间=当前时间 开始帧数等于当前总帧数 然后在Game js 文件初始化里面 实例化该帧率对象 顺便获取上下文绘图 传入ID获得 然后在游戏开始函数把帧数和时间 绘制到画布上 利用实例化对象执行帧数统计函数 当然有画布肯定需要清屏 把真实帧数和总帧数绘制到画布上 三:加载本地数据 LoadSourceTools 初始化 一个对象用来保存所有的加载出来的图片 ,定义一个方法用来加载本地图片 利用AJAX 创建请求对象 监听状态码 onreadystatechang 判断状态码 请求对象.readyState==4 请求对象.status==200 表示请求成功 定义一个变量记录加载图片数量 获取请求的数据 请求对象.responseText 把获得数据转换为json格式 JSON.parse 建立一个图片数组接收json数据里面的.images 遍历数组创建图片对象 src 索引 在每一张图片加载完后 记录图片的个数++ 拿到数据里面的对应的名字 然后给用来保存图片的对象动态添加名字把image传入到该对象中 通过一个回调函数来获得该对象 ,图片数组的长度,图片的个数 最后请求对象通过.open(‘get’,数据名称) 获得数据 请求对象.send(null) get方法可以不写字符串 最后在游戏js 初始化中 实例化加载本地数据对象 调用该方法 获取里面的图片 四:绘制背景 并且运动 初始化所需要的数据 图片资源 x坐标 y坐标 图片宽高 速度用来移动 总格数,当前页面显示的个数 定义3个方法 一个用来渲染 一个用来让图片移动 一个停止 渲染方法 需要画2倍的个数 因为需要无限循坏 通过drawImage画 具体参数为 当前图片 x坐标+对应i*宽度, y坐标 图片宽高 更新方法 让x坐标按照指定的速度递减 当走过一个一个屏幕也就是总个数*图片宽是后,要让x坐标回到原点 达到无限循环效果 停止方法就是让速度变为0 在游戏js 的游戏运入口放法里面实话对应的对象 通过之前指定的图片名称 在初始化里面判断所有图片是否加载 完成,加载完成就调用run方法 然后在游戏运行方法里面执行对应的渲染和移动方法 第五步 绘制管道 初始化所需要的数据,图片资源 一个控制管道口方向的变量 图片宽度 图片的高度 x坐标 画布最右侧 y坐标口向下为0 口向上为画布高度-(地板+图片高度) 速度 定义三个3个方法 和绘制背景一样 不同的是 更新的时候当坐标x小于图片的宽时候就 移除管道 在游戏js 入口定义一个数据把实例化对象装起来 每100帧绘制一个管道 调用 渲染和移动方法 六步 小鸟的自由落体 x坐标 画布1/3 y坐标100 宽图片宽 高图片高 翅膀状态 对应图片的三个状态 用012表示 翅膀煽动的频率 小鸟下落时当前的总帧数 下落速度 下落速度有个公式 0.0010.59.8*Math.pow(帧数差,2) 在游戏js 初始化实例化小鸟对象 在游戏运行调用移动和渲染方法 七步 小鸟自由落体加旋转 初始化一个旋转角度 在渲染方法里面先把坐标位移到图片中心再旋转 在移动方法里面角度+1 八步 点击让小鸟飞 初始化一个小鸟状态,记录小鸟当前的状态,0为自由落体,1为点击向上飞 再定义一个空气阻力, 这个空气阻力用来判断假如用户不点击 会把小鸟状态转换为自由落体 飞到画布顶端判断不让飞出顶端 定义一个点击方法 用来改变小鸟的状态 改变角度,头向上,每次点击初始化空气阻力 九步 碰撞检测 初始化一个变量用来记录小鸟是否死亡 小鸟死亡的状态 碰到地板和管道 都调用gameOver函数 小鸟本身和管道和小鸟关系 小鸟本身控制 碰到地板游戏结束 调用gameOver函数 管道和小鸟 碰到游戏结束 具体关系用图表示 十步 鸟死亡特效加游戏结束 鸟方法 初始化一个变量记录鸟是否死亡 一个动画索引 在渲染方法判断鸟是否死亡 定义死亡图片宽高 定义一个列和行用来截取图片位置 把图片绘制到 对应小鸟死亡的位置上 把游戏结束的图片绘制到画布上 return 结束函数 在移动方法让动画索引递增,当动画索引等于列*行的时候就结束游戏 return 结束程序 代码如下 游戏具体文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128(function ()&#123; window.Game=Class.extend(&#123; init:function (option)&#123; //备份指针 var self=this; //初始化数据 option=option||&#123;&#125;; //游戏帧率 this.FPS=option.FPS||50; //上下文的id this.id=option.id; //获取id this.canvas=document.getElementById(this.id); //获取上下文 this.context= this.canvas.getContext(\"2d\"); //实例化帧率工具对象 this.frame=new FrameTools(); //实例化加载本地资源工具对象 this.loadImage=new LoadSourceTools(); //调用加载数据方法 第一个参数 数据 第二个回调 获得具体信息 this.loadImage.loadImage('r.json',function (imgObj,imgLength,index)&#123; //判断所有图片是否加载完成 总个数==索引 if(imgLength==index)&#123; //执行run函数 self.allImage=imgObj; self.run(); &#125; &#125;) //记录游戏是否结束 this.isGameOver=false; &#125;, //游戏运行入口 run:function ()&#123; //备份指针 var self=this; self.timer=setInterval(function ()&#123; //游戏运行函数 self.gameLoop(); &#125;,1000/self.FPS); //1000/self.FPS 时间 该帧率一秒内的时间 //初始化背景图片 //创建地板图片 this.floor=new Background(&#123; img:self.allImage['diban'], y:self.canvas.height-48, width:48, height:48, speed:10 &#125;); //创建树木 this.tree=new Background(&#123; img:self.allImage['shu'], y:self.canvas.height-48-216, width:300, height:216, speed:10 &#125;) //创建房子 this.house=new Background(&#123; img:self.allImage['fangzi'], y:self.canvas.height-48-300, width:300, height:256, speed:10, &#125;) //创建管道数组 里面放管道对象 this.pipeArr=[new Pipe()]; //创建小鸟对象 this.bird=new StupidBird(&#123; width:85, height:60, &#125;) &#125;, //游戏运行 gameLoop:function ()&#123; //清屏 this.context.clearRect(0,0,this.canvas.width,this.canvas.height); //执行计算真实帧率的方法 this.frame.countFrame(); //把真实帧率和总帧率绘制到画布上 this.context.fillText('FPS/'+this.frame.realFrame,15,15); //真实帧率 this.context.fillText('劳柏明/'+this.frame.sumFrame,15,30); //总帧率 // 调用房子的绘制和移动方法 this.house.move(); this.house.render(); // //调用树木的绘制和移动方法 this.tree.move(); this.tree.render(); //调用地板的绘制和移动方法 this.floor.move(); this.floor.render(); //每隔100帧就往管道数组添加管道 总帧率%5==0 修改频率可以减少管道与管道之间的间隙 if(this.frame.sumFrame%80==0)&#123; this.pipeArr.push(new Pipe()); &#125; //循环遍历数组 让里面的管道渲染和移动 for(var i=0;i&lt;this.pipeArr.length;i++)&#123; //先更新再渲染 this.pipeArr[i].move(); this.pipeArr[i].render(); &#125; //调用小鸟的渲染和下移动方法 this.bird.move(); this.bird.render(); &#125;, //死亡或按暂停了 pause:function ()&#123; clearInterval(this.timer); &#125;, //游戏结束 gameOver:function ()&#123; //让有运动的物体停止 //全部调用pause函数 this.house.pause(); this.tree.pause(); this.floor.pause(); this.pipeArr.forEach(function (item , index) &#123; item.pause(); &#125;); //小鸟死亡 this.bird.die = true; //记录游戏结束 this.isGameOver = true; //让按钮出现 begin.style.display='block'; &#125; &#125;)&#125;)(); 帧率计算123456789101112131415161718192021222324252627282930(function ()&#123; window.FrameTools=Class.extend(&#123; init:function ()&#123; //定义总帧数 this.sumFrame=0; //开始时间 this.beginTime=new Date(); //开始的帧数 this.beginFrame=0; //真实帧数 this.realFrame=0; &#125;, //计算真实帧数的函数 countFrame:function ()&#123; //总帧数每调用函数一次就加一次 this.sumFrame++; //当前时间 this.curTime=new Date(); //满足当前时间减去开始时间大于一秒才去计算真实帧数 if(this.curTime- this.beginTime&gt;1000)&#123; //真实帧率=总帧率-开始的帧率 this.realFrame=this.sumFrame-this.beginFrame; //更新开始帧率 this.beginFrame=this.sumFrame; //更是开始时间 this.beginTime=this.curTime; &#125; &#125; &#125;)&#125;)(); 加载数据12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152(function () &#123; window.LoadSourceTools = Class.extend(&#123; init: function () &#123; //所有图片对象 this.allImageObj = &#123;&#125;; &#125;, //加载图片方法 第一个参数数据 第二个回调函数 用来获取具体信息 loadImage: function (url, callBack) &#123; //保存指针 var self=this; //创建请求对象 var xhr = new XMLHttpRequest(); ////监听状态码 xhr.onreadystatechange=function ()&#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; //请求成功 var countImage = 0;//计算图片的个数 //获取响应数据 var responseData = xhr.responseText; var jsonData = JSON.parse(responseData); //建立一个图片数组从说数据中拿出图片 var imageArr = jsonData.images; //遍历图片数组 for (var i = 0; i &lt; imageArr.length; i++) &#123; //创建图片对象 var img=new Image(); //图片的src img.src=imageArr[i].src; //记录索引 img.index=i; //图片加载完后 img.onload=function ()&#123; //图片个数每次+1 countImage++; //拿到数据里面的对应图片名字 var imgName=imageArr[this.index].name; //通过动态特性给对象添加属性,把图片给这个属性 self.allImageObj[imgName]=this; //回调函数用来把数据拿出来 整一个图片对象 图片数组长度 每一张图片对应的索引 callBack(self.allImageObj,imageArr.length,countImage); &#125; &#125; &#125; &#125; &#125;; //open 和 send xhr.open('GET',url);//get 方式 url数据地址 xhr.send(null); &#125; &#125;)&#125;)(); 背景图片1234567891011121314151617181920212223242526272829303132333435363738394041(function ()&#123; window.Background=Class.extend(&#123; init:function (option)&#123; //图片 this.img=option.img; //x坐标 默认在0开始 this.x=0; //y坐标,根据具体位置来定 this.y=option.y; //图片的宽 this.width=option.width, //图片的高 this.height=option.height; //图片移动速度 this.speed=option.speed; //一个画布容纳的个数 画布的宽除图片的宽 this.count=parseInt(game.canvas.width/this.width)+1; &#125;, //渲染 render:function ()&#123; //循环 画2个画布宽的动画 for(var i=0;i&lt;2*this.count;i++)&#123; //参数 第一个图片 第二个每个图片的X轴坐标 第三个y坐标不变 第四五个图片的宽高 game.context.drawImage(this.img,this.x+i*this.width,this.y,this.width,this.height); &#125; &#125;, //移动 move:function ()&#123; //让x轴坐标移动 this.x-=this.speed; //当x轴移动到超过一个屏幕的距离时候 让x轴回到原点 if(this.x&lt;-this.count*this.width)&#123; this.x=0; &#125; &#125;, //停止 pause:function ()&#123; this.speed=0; &#125; &#125;)&#125;)(); 管道123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657(function ()&#123; window.Pipe=Class.extend(&#123; init:function ()&#123; //管道随机方向 0 代表口向下 1代表口向上 this.dir= _.random(0,1); //图片的宽 this.width=148; //图片的高 因为管道的高不定 所以弄一个随机值 this.height= _.random(80,game.canvas.height*0.5); //x坐标 this.x=game.canvas.width; //y坐标 根据口的方向决定 this.y=this.dir==0?0:game.canvas.height-48-this.height; //速度 this.speed=20; &#125;, render:function ()&#123; //备份指针 var self=this; //管道口向下 if(this.dir==0)&#123; //第一个参数图片 第二个截取图片x坐标 第三个图片Y坐标 三四个截图的宽高 五六放的位置 七八,图片的宽高 game.context.drawImage(game.allImage['pipe1'],0,1664-this.height,this.width,this.height,this.x,this.y,this.width,this.height); &#125;else if(this.dir==1)&#123; game.context.drawImage(game.allImage['pipe0'],0,0,this.width,this.height,this.x,this.y,this.width,this.height); &#125; &#125;, move:function ()&#123; //x坐标递减 this.x-=this.speed ; //判断条件 x坐标&lt;-自身宽 意思就是画布左侧 if(this.x&lt;-this.width)&#123; //game定义一个数组 移除该管道对象 game.pipeArr= _.without(game.pipeArr,this); &#125; //判断小鸟和管道之间的碰撞,先x坐标 管道的头和尾 if((game.bird.x&lt;this.x+this.width)&amp;&amp;(game.bird.x&gt;this.x-game.bird.width))&#123; //判断口的方向 口向下 if(this.dir==0)&#123; if(game.bird.y&lt;this.height)&#123; //游戏结束 game.gameOver(); &#125; &#125;else if(this.dir==1)&#123; if(game.bird.y&gt;this.y-game.bird.height)&#123; //游戏结束 game.gameOver(); &#125; &#125; &#125; &#125;, pause:function ()&#123; //速度停止 this.speed=0; &#125; &#125;)&#125;)(); 小鸟123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141(function ()&#123; window.StupidBird=Class.extend(&#123; init:function (option)&#123; //x坐标 this.x=game.canvas.width*0.5; //y坐标 this.y=100; //小鸟的宽 this.width=option.width; //小鸟的高 this.height=option.height; //小鸟图片的状态 对应图片3种状态 this.BirdState=0; //小鸟振动频率 this.BirdFrequency=5; //小鸟下落的帧数 this.BirdFrame=game.frame.sumFrame; //下落的速度 this.speedY=0; //旋转角度 this.rotateDeg=0; //小鸟的状态 0自由落体 1向上飞 this.state=0; //空气阻力,作用更换小鸟的状态 this.nowel=1; //添加点击事件 this.addClick(); //记录小鸟是否死亡 this.die=false; //记录小鸟的动画索引 this.animationIndex=0; &#125;, render:function ()&#123; //备份指针 var self=this; //小鸟死亡画死亡特效 if(this.die)&#123; //死亡图片的宽高 和游戏结束的宽高 var dieW=325,dieH=138,gameW=626,gameH=144; // 0 1 2 3 4 列 控制x坐标 var row= this.animationIndex%5; // 行 控制y坐标 var line=parseInt(this.animationIndex/5); //死亡特效 game.context.drawImage(game.allImage['blood'],row*dieW,line*dieH,dieW,dieH,self.x-100,self.y,dieW,dieH); //画游戏结束图标 game.context.drawImage(game.allImage['gameover'],(game.canvas.width - 626) * 0.5 , (game.canvas.height - 144) * 0.5 ); //画游戏开始图标 game.context.drawImage(game.allImage['gamebegin'],(game.canvas.width - 337) * 0.5 , (game.canvas.height - 75) * 0.3 ); //game.context.drawImage(game.allImage['carrot'],500,0); //结束程序 return; &#125; //保存 game.context.save(); //移动图片坐标 game.context.translate(self.x +self.width * 0.5, self.y + self.height*0.5); //旋转图片 game.context.rotate(self.rotateDeg/180*Math.PI); //还原图片坐标 要不坐标会叠加一起图片 game.context.translate(-(this.x +this.width * 0.5), -(this.y + this.height*0.5 ) ); //绘制小鸟 game.context.drawImage(game.allImage['bird'],self.BirdState*self.width,0,self.width,self.height,this.x,this.y,self.width,self.height); //还原状态 game.context.restore(); &#125;, move:function ()&#123; //死亡特效动画 if(this.die)&#123; //动画索引++ this.animationIndex++; //根据图片决定 if(this.animationIndex==30)&#123; //游戏停止 game.pause(); &#125; //结束程序; return ; &#125; //碰到地板 结束游戏 if(this.y&gt;=game.canvas.height-48-this.height)&#123; game.gameOver(); return ; &#125; //判断下落的帧数对频率去模 if(game.frame.sumFrame%this.BirdFrequency==0)&#123; this.BirdState++; //0 1 2 3个状态循环 if(this.BirdState==2)&#123; this.BirdState=0; &#125; &#125; //小鸟自由落体 if(this.state==0)&#123; this.speedY=0.001*0.5*9.8*Math.pow(game.frame.sumFrame-this.BirdFrame,2); //角度递增 this.rotateDeg+=1; //小鸟向上飞 &#125;else if(this.state==1)&#123; //空气阻力递增 this.nowel++; //让小鸟状态改变的条件 this.speedY=-15+this.nowel; //用户不点击时候 if(this.speedY&gt;0)&#123; //小鸟自由落体 this.state=0; //更新当前的下落的帧数 this.BirdFrame=game.frame.sumFrame; &#125; &#125; //y坐标递增 小鸟自由落体 this.y+=this.speedY; //小鸟到达画布顶端 if(this.y&lt;0)&#123; this.x-=1; this.y=0; &#125; &#125;, addClick:function ()&#123; //备份指针 var self=this; //点击整一个画布 game.canvas.addEventListener('mousedown',function ()&#123; //改变小鸟的状态 self.state=1; //改变角度,头朝上 self.rotateDeg=-25; //初始化空气阻力 self.nowel=1; &#125;) &#125;, &#125;)&#125;)(); 碰撞检测 游戏截图","tags":[{"name":"canvas","slug":"canvas","permalink":"//carrot.me/tags/canvas/"}]},{"title":"canvas学习之konva框架旋转中心","date":"2016-02-08T12:36:00.000Z","path":"2016/02/08/canvas-knova应用二/","text":"konva框架的学习与应用 整体思路利用面向对象思想 创建一个专门用来画小球的构造函数 里面定义一个绘制的方法 在onload里面创建 这个构造函数的实例化对象 并且作相应的设定 最后拿到数组里面的小球对象进行运动 关键点 框架的运用 舞台的创建 画布的创建 各种数组的创建 顺序 舞台&gt;画布&gt;组 把对象放入对应的组 把组放入对应的画布 把画布放入舞台 计算各个小球的位置 也就是圆心 通过三角函数可以求得各个对象在内圆和外圆所在的位置,并且不会脱离内圆和外圆 实现类似8大行星绕着运动效果 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255&lt;script&gt; window.onload=function ()&#123; var stage=new Konva.Stage(&#123; width:window.innerWidth, height:window.innerHeight, container:container &#125;); var layer = new Konva.Layer(&#123;&#125;); stage.add(layer); //圆心 var x0=stage.width()*0.5; var y0=stage.height()*0.5; var outR=300; var insideR=150; var group=new Konva.Group(&#123; x:0, y:0 &#125;); layer.add(group); var outArc=new Konva.Circle(&#123; x:x0, y:y0, radius:outR, stroke:\"#ccc\", strokeWidth:5, dash:[7, 3] &#125;); var insideArc=new Konva.Circle(&#123; x:x0, y:y0, radius:insideR, stroke:\"#ccc\", strokeWidth:5, dash:[7, 3] &#125;); group.add(outArc); group.add(insideArc); var RingArc=new CenterCircle(&#123; x:x0, y:y0, RingOutR:75, RingInR:65, RingFill:'#ccc', opacity:0.8, centerFill:'red', textColor:'white', text:'劳柏明' &#125;); RingArc.Render(layer); layer.draw(); //创建动画层 var animationLayer=new Konva.Layer(&#123; &#125;); stage.add(animationLayer); //内层动画 var inGroup=new Konva.Group(&#123; x:x0, y:y0 &#125;) animationLayer.add(inGroup); //外层动画 var outGroup=new Konva.Group(&#123; x:x0, y:y0 &#125;); animationLayer.add(outGroup); //内层动画成员 var zhang = new CenterCircle(&#123; x:insideR * Math.cos(60 * Math.PI/180), y:insideR * Math.sin(60 * Math.PI/180), RingOutR:60, RingInR:50, RingFill:'#ccc', opacity:0.6, centerFill:'wheat', textColor:'black', text:'张雨霖' &#125;); var xu = new CenterCircle(&#123; x:insideR * Math.cos(-60 * Math.PI/180), y:insideR * Math.sin(-60 * Math.PI/180), RingOutR:70, RingInR:60, RingFill:'#ccc', opacity:0.8, centerFill:'blue', textColor:'black', text:'徐展艺' &#125;); var chen = new CenterCircle(&#123; x:insideR * Math.cos(160 * Math.PI/180), y:insideR * Math.sin(160 * Math.PI/180), RingOutR:50, RingInR:40, RingFill:'#ccc', opacity:0.4, centerFill:'pink', textColor:'black', text:'陈金波', &#125;); //放到内层动画 zhang.Render(inGroup); xu.Render(inGroup); chen.Render(inGroup); //创建外层动画成员 var ceng = new CenterCircle(&#123; x:outR * Math.cos(130 * Math.PI/180), y:outR * Math.sin(130 * Math.PI/180), RingOutR:90, RingInR:80, RingFill:'#ccc', opacity:0.4, centerFill:'purple', textColor:'white', text:'曾基锟' &#125;); var luo = new CenterCircle(&#123; x:outR * Math.cos(-135 * Math.PI/180), y:outR * Math.sin(-135 * Math.PI/180), RingOutR:80, RingInR:70, RingFill:'#ccc', opacity:0.4, centerFill:'green', textColor:'white', text:'罗伟星' &#125;); var lv = new CenterCircle(&#123; x:outR * Math.cos(0 * Math.PI/180), y:outR * Math.sin(0 * Math.PI/180), RingOutR:70, RingInR:60, RingFill:'#ccc', opacity:0.4, centerFill:'gold', textColor:'white', text:'吕德福' &#125;); //外层成员 放到外层动画 ceng.Render(outGroup); luo.Render(outGroup); lv.Render(outGroup); animationLayer.draw(); var inRot =30; var outRot=60; var animation=new Konva.Animation(function (frame) &#123; //上一帧到当前帧的时间差 ms --&gt;s var timeDiff = frame.timeDiff /1000;//距离上一帧的时间差 //一帧转多少度 var inRotDeg = timeDiff * inRot; var outRotDeg = timeDiff * outRot; //8.1 内层动画运动 inGroup.rotate(inRotDeg); inGroup.getChildren().each(function (obj, index) &#123; obj.rotate(inRotDeg); &#125;); //8.2 外层动画运动 outGroup.rotate(outRotDeg); outGroup.getChildren().each(function (obj, index) &#123; obj.rotate(-outRotDeg); &#125;); &#125;, animationLayer); //9.开启动画 animation.start(); //10.事件处理 animationLayer.on('mousemove', function () &#123;// rotateAnglePerSecond = 20; animation.stop(); &#125;); animationLayer.on('mouseout',function () &#123;// rotateAnglePerSecond = 60; animation.start(); &#125;) &#125;;function CenterCircle(option)&#123; this._init(option);&#125; CenterCircle.prototype=&#123; constructor:CenterCircle, _init:function (option)&#123; var option=option||&#123;&#125;; this.x=option.x; this.y=option.y; this.RingOutR=option.RingOutR ;//外环的半径 this.RingInR=option.RingInR; //内环的半径 this.RingFill=option.RingFill;//圆环颜色 this.opacity=option.opacity;//透明度 this.radius=this.RingInR ;//内圆半径 this.centerFill=option.centerFill; //内圆颜色 this.textColor=option.textColor; //文字颜色 this.text=option.text;//文字内容// this.size=option.size||18; //字体大小 &#125;, Render:function (layer)&#123; this.group=new Konva.Group(&#123; x:this.x, y:this.y &#125;); layer.add(this.group); //画圆环 var RingR=new Konva.Ring(&#123; innerRadius:this.RingInR, outerRadius:this.RingOutR, fill:this.RingFill, opacity:this.opacity &#125;); //放进总数组 this.group.add(RingR); //画圆 var centerArc=new Konva.Circle(&#123; radius:this.radius, fill:this.centerFill &#125;) this.group.add(centerArc); //画文字 var text=new Konva.Text(&#123; x:-25, y:-10, width:2*this.innerRadius, text:this.text, fill:this.textColor, fontSize:18, align:'center' &#125;); this.group.add(text); &#125; &#125;&lt;/script&gt;","tags":[{"name":"canvas","slug":"canvas","permalink":"//carrot.me/tags/canvas/"}]},{"title":"canvas学习之konva框架饼状图","date":"2016-02-07T15:36:00.000Z","path":"2016/02/07/canvas-knova应用一/","text":"konva框架的学习与应用这是一个关于canvas框架,功能也很强大,而且定义非常具有艺术感觉,舞台,演员. 整体思路定义一些常量,数据 ,扇形半径,圆的半径, 舞台的搭建 创建一个画扇形的构造函数,该构造函数通过传入数据根并且据数据来进行画扇形和具体数据 在该构造函数可以定义三个组用来保存不同东西,扇形一个组 数字文字描述一个组 矩形区域也一个组 在该构造函数定义个绘制的函数 通过传入画布把里面定义的组放入画布中 通过扇形组进行遍历 定义一个变量来记录动画的所代表具体扇形,利用递归的方法让每一个扇形都由0到指定的角度 当最后一个扇形结束动画的时候结束递归就可以了 关键点 扇形的绘制 确定一个起点, 根据起来画扇形 每画一个扇形更新起点 文字的绘制 通过三角函数来确定位置 进行微调文字达到效果 通过一个变量来记录动画队列,注意结束递归. 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237&lt;script&gt; window.onload=function ()&#123; //舞台 var stage=new Konva.Stage(&#123; width:window.innerWidth, height:window.innerHeight, container:'container' &#125;); //画布层 var layer = new Konva.Layer(&#123;&#125;); //把画布层放入舞台 stage.add(layer); var data=[ &#123;name:'广州',value:0.25,color:'red'&#125;, &#123;name:'深圳',value:0.15,color:'yellow'&#125;, &#123;name:'珠海',value:0.15,color:'blue'&#125;, &#123;name:'东莞',value:0.2,color:'green'&#125;, &#123;name:'中山',value:0.1,color:'black'&#125;, &#123;name:'江门',value:0.15,color:'pink'&#125; ]; //圆的中心 var x0=stage.width()/2; var y0=stage.height()/2; //外圆半径 var outR=180; //扇形半径 var insideR=160; //创建画扇形的对象 var sector=new DrawSector(&#123; x:x0, //圆心x y:y0, //圆心y outArc:outR,//外圆半径 outStroke:'#ccc', //外圆颜色 outStrokeWidth:5,//外圆宽度 insideArc:insideR,//扇形的半径 dataArr:data//数据数组 &#125;); sector.Render(layer); layer.draw(); stage.on('contentClick',function ()&#123; if(sector.flag) //防止多次点击 sector.move(); &#125;) &#125;; function DrawSector(option)&#123; this._init(option); &#125; DrawSector.prototype=&#123; constructor:DrawSector, _init:function (option)&#123; var option=option||&#123;&#125;; //坐标X this.x=option.x; //坐标y this.y=option.y; //外圆半径 this.outArc=option.outArc; //扇形半径 this.insideArc=option.insideArc; //外圆颜色 this.outStroke=option.outStroke; //外圆宽度 this.outStrokeWidth=option.outStrokeWidth; //数据数组 this.dataArr=option.dataArr; //动画索引 this.animationIndex=0; //标记 this.flag=true; &#125;, Render:function (layer)&#123; //保存this; var self=this; //总数组 this.group=new Konva.Group(&#123; x:0, y:0 &#125;); //把总数组放入画布层 layer.add(this.group); //画外圆 前面变量名字固定写法 后面同理,不能更改 var ourCircle=new Konva.Circle(&#123; x:this.x, y:this.y, radius:this.outArc, stroke:this.outStroke, strokeWidth:this.outStrokeWidth &#125;); //把圆放到数组中 this.group.add(ourCircle); //2.扇形组 this.wedgeGroup = new Konva.Group(&#123;&#125;); this.group.add(this.wedgeGroup); //3.区域组 this.areaGroup = new Konva.Group(&#123;&#125;); this.group.add(this.areaGroup); //4.文字组 this.textGroup = new Konva.Group(&#123;&#125;); this.group.add(this.textGroup); //开始的角度 12点开始画 var beginDeg=-90; this.dataArr.forEach(function (obj,index)&#123; //循环遍历数组画扇形 wedge画扇形方法 var sector=new Konva.Wedge(&#123; //圆心 x: self.x, y:self.y, //半径 radius:self.insideArc, //填充颜色 fill:obj.color, //扇形角度 angle:obj.value * 360, //开始角度 旋转角度 rotation:beginDeg &#125;); //放入扇形数组中 self.wedgeGroup.add(sector); //文字角度 开始角度+扇形角度一半 var textDeg=beginDeg+obj.value*360*0.5; //文字的左上角x起点 var disX=self.x+Math.cos(textDeg*Math.PI/180)*(self.insideArc+40); //文字的左上角y起点 var disY=self.y+Math.sin(textDeg*Math.PI/180)*(self.insideArc+40); //文字内容 var context=obj.name+obj.value*100+'%'; //画文字 var text=new Konva.Text(&#123; x:disX, y:disY, text:context, fill:obj.color, fontSize:20, fontFamily:'微软雅黑', align:'center' &#125;) //文字微调处理 if (textDeg &gt; 90 &amp;&amp; textDeg &lt; 270)&#123; text.x(disX - text.width()); &#125; if (index==2)&#123; text.x(disX - text.width()+40); &#125; if (index==5)&#123; text.x(disX - text.width()+30); text.y(disY - text.height()); &#125; //把文字放入文字数组中 self.textGroup.add(text); //画矩形区域 var areaX = self.x + self.outArc + 200; //垂直间隔 var areaY = self.y + 30 * index; //固定宽高 var areaWidth = 60; var areaHeight = 20; var rect = new Konva.Rect(&#123; x:areaX, y:areaY, width:areaWidth, height:areaHeight, fill:obj.color &#125;); self.areaGroup.add(rect); //画矩形的文字 var textX = areaX + 100; var textY = areaY ; var textR=new Konva.Text(&#123; x:textX, y:textY, text:obj.name, fill:obj.color, fontSize:20, fontFamily:'微软雅黑', align:'center' &#125;); self.textGroup.add(textR); //更新旋转角度 放最后 beginDeg+=obj.value * 360; &#125;) &#125;, //点击执行的方法 move:function ()&#123; //保存this var self=this; self.flag=false; //拿到所有扇形 var Wedge=this.wedgeGroup.getChildren(); //让所有的扇形的角度都为零 默认this.animationIndex==0 if(this.animationIndex==0)&#123; //遍历所有扇形拿出角度变为零 Wedge.each(function (obj,index)&#123; //这样设置值 obj.angle(0); &#125;) &#125; //每个扇形数据的索引 var WedgeArr=Wedge[this.animationIndex]; WedgeArr.to(&#123; //角度由0到指定的度数 angle:self.dataArr[self.animationIndex].value * 360, //延迟时间 duration:self.dataArr[self.animationIndex].value, //相当于回调动画 结束后执行 onFinish:function () &#123; //让动画索引增加 self.animationIndex++; if (self.animationIndex &gt;= self.dataArr.length)&#123; self.animationIndex = 0; self.flag=true; return; &#125; //递归调用 self.move(); &#125; &#125;) &#125; &#125;&lt;/script&gt;","tags":[{"name":"canvas","slug":"canvas","permalink":"//carrot.me/tags/canvas/"}]},{"title":"canvas学习之图片效果","date":"2016-02-06T13:36:00.000Z","path":"2016/02/06/canvas-红包图片效果/","text":"很好玩的图片效果一个很好玩的图片效果.特效也很绚丽 整体思路获取canvas的上下文,让画布,图片,盒子三者相互适应,没有做屏幕的适配. 定义一些常量 剪辑区域的半径 剪辑区域数据 定义一个初始化函数,打开网页就执行,图片就会模糊,并且剪辑区域显示 所以在初始化化函数可以定义一个函数 用来绘制画布的函数 在画布函数中把图片放入画布中,然后在该函数定义一个函数用来画剪辑区域的函数 这样三者的关系就能很好的联系一起. 最好点击显示 执行一个显示函数 里面也是执行绘制画布的函数 又可以复用了 随机定义一个随机函数就让整个画布重新初始化 关键点,几个函数之间的关系,方便复用 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;script&gt;//获得画布以及上下文var canvas = document.getElementById('canvas');var context = canvas.getContext('2d');//创建图片var image = new Image();image.src = 'fengjing.jpg';//画布的大小var canvasWidth = image.width;var canvasHeight = image.height;//画布的大小canvas.width = canvasWidth;canvas.height = canvasHeight;//div的宽高$('#blur-div').css('width',canvas.width +'px');$('#blur-div').css('height',canvas.height +'px');//图片的宽高$('#blur-image').css('width',image.width +'px');$('#blur-image').css('height',image.height +'px');//剪辑区域的半径var radius = canvas.width/20;//剪辑的区域数据初始化var clippingRegion = &#123;x:0,y:0,r:0&#125;;var flag=true;image.onload = function () &#123; //初始化画布 initCanvas();&#125;//初始化画布方法function initCanvas() &#123; //重新初始化剪辑区域的数据 clippingRegion=&#123; x: Math.random() * (canvas.width - 2 * radius) + radius, y: Math.random() * (canvasHeight - 2 * radius) + radius, r: radius &#125;; //每次点击都初始化 clippingRegion.r=0; //添加图片到画布 var timer=setInterval(function ()&#123; clippingRegion.r+=5; if(clippingRegion.r&gt;radius)&#123; clearInterval(timer); clippingRegion.r=radius; &#125;; draw(image, clippingRegion); &#125;,30)&#125;//设置剪辑区域方法function setClippingRegion(clippingRegion) &#123; //开始路径 context.beginPath(); //画剪辑区域的圆 context.arc(clippingRegion.x, clippingRegion.y, clippingRegion.r, 0, 2 * Math.PI); //剪辑方法 当前显示,其他消失 context.clip();&#125;//添加图片到画布方法function draw(image, clippingRegion) &#123; //清空画布 context.clearRect(0, 0, canvas.width, canvas.height); //保存状态 context.save(); //设置剪辑区域 setClippingRegion(clippingRegion); //添加图片到画布 context.drawImage(image, 0, 0); //恢复状态 context.restore();&#125;//展示图片的函数function show() &#123; //动画 if(!flag) return; flag=false; var timer=setInterval(function ()&#123; //让剪辑区域的半径足以覆盖图像 慢慢加上去 clippingRegion.r += 20; //停止动画 if(clippingRegion.r&gt;1.2*Math.max(canvas.width,canvas.height))&#123; clearInterval(timer); flag=true; &#125; //再次调用覆盖图像 draw(image, clippingRegion); &#125;,30)&#125;//随机位置的函数function random() &#123; //重新初始化画布 if(flag) initCanvas();&#125;&lt;/script&gt;","tags":[{"name":"canvas","slug":"canvas","permalink":"//carrot.me/tags/canvas/"}]},{"title":"canvas学习之倒计时效果","date":"2016-02-05T12:36:00.000Z","path":"2016/02/05/canvas-倒计时效果/","text":"炫酷的倒计时效果个人非常喜欢的一个倒计时效果. 整体思路先定义一些常量 比如小球的半径 固定的坐标位置 颜色, 重点是一个2维数组用来记录数字的阵列 获取时间,在定时器执行绘制和更新的函数 绘制函数 需要获取当前的时间 ,所以定义一个专门用来获取当前时间的函数即可 在绘制函数中获取当前时间具体时 分 秒在对应的阵列把数字画上去,通过双重for循环遍历拿到点阵数据 判断是否为一,为一就画一个圆,这样就可以显示具体的时间在点阵上 更新函数用来获取当前时间和下一次的时间 做一个判断 当两个时间不相等的时候 就添加小球 所以创建一个添加小球的方法 用一个数组把小球放进去 在绘制时间时候同时把小球也一同绘制,不同的是,彩色小球会运动 所以定义一个让小球运动的函数,里面进行运动的函数,并且判断何时清除小球, 关键点,时间与点阵的如何绘制成对应的数字 何时需要添加小球 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280var WINDOW_WIDTH=1280;var WINDOW_HEIGHT=786;var RADIUS=8;//小球半径var MARGIN_TOP=60;var MARGIN_LEFT=30;var curTimeSec=0;var balls=[];var colors=['#33B5e5','#0099cc','#aa66cc','#9933cc','#99cc00','#669900','#ffbb33','#ff8800','#ff4444','#cc0000',];//点阵数据 控制数字显示位置var digit = [ [ [0,0,1,1,1,0,0], [0,1,1,0,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,0,1,1,0], [0,0,1,1,1,0,0] ],//0 [ [0,0,0,1,1,0,0], [0,1,1,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [1,1,1,1,1,1,1] ],//1 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,0,0,1,1], [1,1,1,1,1,1,1] ],//2 [ [1,1,1,1,1,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,1,1,1,0,0], [0,0,0,0,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//3 [ [0,0,0,0,1,1,0], [0,0,0,1,1,1,0], [0,0,1,1,1,1,0], [0,1,1,0,1,1,0], [1,1,0,0,1,1,0], [1,1,1,1,1,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,1,1] ],//4 [ [1,1,1,1,1,1,1], [1,1,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,1,1,1,0], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//5 [ [0,0,0,0,1,1,0], [0,0,1,1,0,0,0], [0,1,1,0,0,0,0], [1,1,0,0,0,0,0], [1,1,0,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//6 [ [1,1,1,1,1,1,1], [1,1,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,0,0,1,1,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0], [0,0,1,1,0,0,0] ],//7 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,1,1,0] ],//8 [ [0,1,1,1,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,1,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,0,1,1], [0,0,0,0,1,1,0], [0,0,0,1,1,0,0], [0,1,1,0,0,0,0] ],//9 [ [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0] ]//: ];window.onload=function ()&#123; var canvas=document.getElementById('canvas'); var context=canvas.getContext('2d'); canvas.width=WINDOW_WIDTH; canvas.height=WINDOW_HEIGHT; curTimeSec=getTimeSec(); setInterval(function ()&#123; render(context); update(); &#125;,50)&#125;function update()&#123; var nextTimeSec=getTimeSec(); var nextHours=parseInt(nextTimeSec/3600); var nextMin=parseInt((nextTimeSec-nextHours*3600)/60); var nextSec=nextTimeSec%60; var curHours=parseInt(curTimeSec/3600); var curMinutes=parseInt((curTimeSec-curHours*3600)/60); var curSeconds=curTimeSec%60; if(nextTimeSec!=curTimeSec)&#123; if(parseInt(curHours/10)!=parseInt(nextHours/10))&#123; addBalls(MARGIN_LEFT+0,MARGIN_TOP,parseInt(curHours/10)); &#125; if(parseInt(curHours%10)!=parseInt(nextHours%10))&#123; addBalls(MARGIN_LEFT+15*(RADIUS+1),MARGIN_TOP,parseInt(curHours%10)); &#125; if(parseInt(curMinutes/10)!=parseInt(nextMin/10))&#123; addBalls(MARGIN_LEFT+45*(RADIUS+1),MARGIN_TOP,parseInt(curMinutes/10)); &#125; if(parseInt(curMinutes%10)!=parseInt(nextMin%10))&#123; addBalls(MARGIN_LEFT+60*(RADIUS+1),MARGIN_TOP,parseInt(curMinutes%10)); &#125; if(parseInt(curSeconds/10)!=parseInt(nextSec/10))&#123; addBalls(MARGIN_LEFT+90*(RADIUS+1),MARGIN_TOP,parseInt(curSeconds/10)); &#125; if(parseInt(curSeconds%10)!=parseInt(nextSec%10))&#123; addBalls(MARGIN_LEFT+108*(RADIUS+1),MARGIN_TOP,parseInt(curSeconds%10)); &#125; curTimeSec=nextTimeSec; &#125; updateBalls();&#125;function updateBalls()&#123; for(var i=0;i&lt;balls.length;i++)&#123; balls[i].x+= balls[i].vx; balls[i].y+= balls[i].vy; balls[i].vy+= balls[i].g; if(balls[i].y&gt;=WINDOW_HEIGHT-RADIUS)&#123; balls[i].y=WINDOW_HEIGHT-RADIUS ; balls[i].vy=-balls[i].vy*0.75; &#125; &#125; var cnt=0; for(var i=0;i&lt;balls.length;i++)&#123; if(balls[i].x+RADIUS&gt;0&amp;&amp;balls[i].x-RADIUS&lt;WINDOW_WIDTH)&#123; balls[cnt++]=balls[i]; &#125; &#125; while(balls.length&gt;cnt)&#123; balls.pop(); &#125;&#125;function addBalls(x,y,num)&#123; for(var i=0;i&lt;digit[num].length;i++)&#123; for(var j=0;j&lt;digit[num][i].length;j++)&#123; if(digit[num][i][j]==1)&#123; //添加彩色小球 var aBall=&#123; x:x+j*2*(RADIUS+1)+(RADIUS+1), y:y+i*2*(RADIUS+1)+(RADIUS+1), g:1.5+Math.random(), vx:Math.pow(-1,Math.ceil(Math.random()*1000))*4, vy:-5, color:colors[Math.floor(Math.random()*colors.length)] &#125; balls.push(aBall); console.log(balls.length); &#125; &#125; &#125;&#125;function getTimeSec()&#123; var nowTime=new Date(); var ret=nowTime.getHours()*3600+nowTime.getMinutes()*60+nowTime.getSeconds(); return ret;&#125;function render(cxt)&#123; //刷新画布 cxt.clearRect(0,0,WINDOW_WIDTH,WINDOW_HEIGHT); var hours=parseInt(curTimeSec/3600); var minutes=parseInt((curTimeSec-hours*3600)/60); var seconds=curTimeSec%60; //前面2个参数,位置 第三个,绘制哪一个数字 小时的十位 个位 : 分钟 秒.. renderDigit(MARGIN_LEFT,MARGIN_TOP,parseInt(hours/10),cxt); renderDigit(MARGIN_LEFT+15*(RADIUS+1),MARGIN_TOP,parseInt(hours%10),cxt); renderDigit(MARGIN_LEFT+30*(RADIUS+1),MARGIN_TOP,10,cxt); renderDigit(MARGIN_LEFT+45*(RADIUS+1),MARGIN_TOP,parseInt(minutes/10),cxt); renderDigit(MARGIN_LEFT+60*(RADIUS+1),MARGIN_TOP,parseInt(minutes%10),cxt); renderDigit(MARGIN_LEFT+75*(RADIUS+1),MARGIN_TOP,10,cxt); renderDigit(MARGIN_LEFT+90*(RADIUS+1),MARGIN_TOP,parseInt(seconds/10),cxt); renderDigit(MARGIN_LEFT+108*(RADIUS+1),MARGIN_TOP,parseInt(seconds%10),cxt); for(var i=0;i&lt;balls.length;i++)&#123; cxt.fillStyle=balls[i].color; cxt.beginPath(); cxt.arc(balls[i].x,balls[i].y,RADIUS,0,2*Math.PI,true); cxt.fill(); &#125; &#125;function renderDigit(x,y,num,cxt)&#123; cxt.fillStyle='rgb(0,102,153)'; for(var i=0;i&lt;digit[num].length;i++) for(var j=0;j&lt;digit[num][i].length;j++) if(digit[num][i][j]==1)&#123; //画小球 cxt.beginPath(); cxt.arc(x+j*2*(RADIUS+1)+(RADIUS+1),y+i*2*(RADIUS+1)+(RADIUS+1),RADIUS,0,2*Math.PI); cxt.closePath(); cxt.fill(); &#125;&#125;","tags":[{"name":"canvas","slug":"canvas","permalink":"//carrot.me/tags/canvas/"}]},{"title":"canvas学习之放大镜效果","date":"2016-02-04T12:36:00.000Z","path":"2016/02/04/canvas-放大镜效果/","text":"一个很厉害的放大镜效果哦!!!放大镜效果感觉还不错,整体思路如下 ①利用canvas的离屏效果实现,主要创建2个canvas画布,一个画布用来显示当前画布尺寸的图片,另一个画布则是一张足够大的图片②计算两者比例 获取需要截取图片的大小 然后根据相对应的坐标把截取出来的画布画入 显示当前图片的画布即可③当前画布与大图片画布两者之间比例计算 截图大图片的位置和放入当前图片位置的计算 鼠标点击等操作获取坐标值来计算这些数据 代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;script&gt; var canvas=document.getElementById('canvas'); var offCanvas=document.getElementById('offCanvas'); var cxt=canvas.getContext('2d'); var offContext=offCanvas.getContext('2d'); var flag=false; var image=new Image(); var scale;window.onload=function ()&#123; canvas.width=1366; canvas.height=786; image.src='300.jpg'; image.onload=function ()&#123; offCanvas.width=image.width; offCanvas.height=image.height; scale=offCanvas.width/canvas.width; cxt.drawImage(image,0,0,canvas.width,canvas.height); offContext.drawImage(image,0,0) &#125;&#125; function canvasXY(x,y)&#123; var box=canvas.getBoundingClientRect(); return &#123;x:x-box.left,y:y-box.top&#125;; &#125; canvas.onmousedown=function (e) &#123; e.preventDefault(); flag = true; var point = canvasXY(e.clientX, e.clientY); drawCanvas(flag, point); canvas.onmousemove = function (e) &#123; e.preventDefault(); var point = canvasXY(e.clientX, e.clientY); drawCanvas(flag, point); &#125; canvas.onmouseup = function () &#123; e.preventDefault(); canvas.onmousemove = canvas.onmouseup = null; flag = false; drawCanvas(flag); &#125; &#125;; canvas.onmouseout=function (e)&#123; e.preventDefault(); flag=false; drawCanvas(flag); &#125;function drawCanvas(flag,point)&#123; cxt.clearRect(0,0,canvas.width,canvas.height); cxt.drawImage(image,0,0,canvas.width,canvas.height); if(flag) drawMagnifier(point);&#125; function drawMagnifier(point)&#123; var CX= point.x*scale; var CY= point.y*scale; var mr=100; var sx=CX-mr; var sy=CY-mr; var dx=point.x-mr; var dy=point.y-mr; cxt.save(); cxt.strokeStyle='blue'; cxt.lineWidth=10; cxt.beginPath(); cxt.arc(point.x,point.y,mr,0,2*Math.PI); cxt.stroke() cxt.clip(); cxt.drawImage(offCanvas,sx,sy,2*mr,2*mr,dx,dy,2*mr,2*mr); cxt.restore(); &#125;&lt;/script&gt;","tags":[{"name":"canvas","slug":"canvas","permalink":"//carrot.me/tags/canvas/"}]},{"title":"canvas学习之绘制时钟","date":"2016-02-03T12:36:00.000Z","path":"2016/02/03/canvas-绘制时钟/","text":"给前端工程师提供天马行空的想象力发挥的地方canvas属于H5标签,这是一个强大的标签,给我们前端工程师提供一个发挥想象力的空间.而且可以制作各种炫酷东西,可以处理图片,可以制作游戏,所以我是非常喜欢这个标签,并且花了不少精力去做各种好玩的东西!!这是一个时钟的绘制,具体原理如下 ①通过循环把时钟的12个数字绘制到画布上,每一个时钟有60个长方形东西,根据不同的角度绘制到画布上,关键点是要把画布中心移到中心点,默认在左上角.②定义三个函数分别用来控制时,分,秒指针的转动,三者之间具体的转换可以百度啦.不过也可以像公式一样背一下,不过前提是理解.③开个定时器每隔一秒就获取对应的时分秒,传入对应的函数中,即可让时分秒指针转动. 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105var canvas=document.getElementById('canvas');var context=canvas.getContext('2d');var width=canvas.width;var height=canvas.height;var r=width/2;var rem=width/200;function DrawClock()&#123; //移动坐标到这个点 context.save(); context.translate(r,r) ; context.beginPath(); context.lineWidth=10*rem; context.arc(0,0,r-context.lineWidth/2,0,2*Math.PI,false); context.stroke(); var hour=[3,4,5,6,7,8,9,10,11,12,1,2]; for(var i=0;i&lt;hour.length;i++)&#123; var rad=2*Math.PI/12*i; var x=Math.cos(rad)*(r-45*rem); var y=Math.sin(rad)*(r-45*rem); context.font=18*rem+ \"px 微软雅黑\"; context.textAlign='center'; context.textBaseline='middle'; context.fillText(''+hour[i]+'',x,y); &#125; for(var i=0;i&lt;60;i++)&#123; var arcRad=2*Math.PI/60*i; var xArc=Math.cos(arcRad)*(r-20*rem); var yArc=Math.sin(arcRad)*(r-20*rem); context.beginPath(); if(i%5==0)&#123; context.arc(xArc,yArc,4*rem,0,2*Math.PI,false); context.fillStyle='black'; &#125;else&#123; context.fillStyle='#ccc'; context.arc(xArc,yArc,2*rem,0,2*Math.PI,false); &#125; context.fill(); &#125;&#125;function drawHour(hour,min)&#123; context.save(); context.beginPath(); var rad=2*Math.PI/12*hour; var mRad=2*Math.PI/12/60*min; context.rotate(rad+mRad); context.moveTo(0,10*rem); context.lineTo(0,-r/2); context.lineCap='round'; context.lineWidth=8*rem; context.stroke(); context.restore();&#125;function drawMin(min,sec)&#123; context.save(); context.beginPath(); var rad=2*Math.PI/60*min; var sRad=2*Math.PI/60/60*sec; context.rotate(rad+sRad); context.moveTo(0,10*rem); context.lineTo(0,-r+30*rem); context.lineCap='round'; context.lineWidth=4*rem; context.stroke(); context.restore();&#125;function drawSec(sec)&#123; context.save(); context.beginPath(); var rad=2*Math.PI/60*sec; context.fillStyle='red' context.rotate(rad); context.moveTo(-2*rem,20*rem); context.lineTo(2*rem,20*rem); context.lineTo(1,-r+50*rem); context.lineTo(1,-r+18*rem); context.lineWidth=2*rem; context.fill(); context.restore();&#125;function drawDot()&#123; context.beginPath(); context.arc(0,0,3*rem,0,2*Math.PI); context.fillStyle='white'; context.fill();&#125;function move()&#123; context.clearRect(0,0,width,height); var myDate = new Date(); var second = myDate.getSeconds(); var minute = myDate.getMinutes(); var hour = myDate.getHours(); DrawClock(); drawHour(hour,minute); drawMin(minute,second); drawSec(second); drawDot(); context.restore();&#125;move();setInterval(move,100);","tags":[{"name":"canvas","slug":"canvas","permalink":"//carrot.me/tags/canvas/"}]},{"title":"js设计模式之命名空间模式","date":"2016-02-02T10:36:00.000Z","path":"2016/02/02/js-命名空间模式/","text":"设计模式之命名空间模式核心过程 把所有的方法和变量都用一个对象保存 代码如下 123456789101112131415161718192021&lt;script&gt; var SHARE=&#123;&#125;; SHARE.namespace=function (str)&#123; if(str==undefined)&#123; throw '不能为空' &#125; var arrStr=str.split('.') if(arrStr[0]=='SHARE')&#123; arrStr.splice(0,1); &#125; var parent=SHARE; for(var i=0;i&lt;arrStr.length;i++)&#123; if(parent[arrStr[i]]==undefined)&#123; parent[arrStr[i]]=&#123;&#125;; //成为对象 &#125; parent=parent[arrStr[i]]; //更新父节点 &#125; &#125; SHARE.namespace('SHARE.A.B.C.D.E') console.log(SHARE);&lt;/script&gt;","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"//carrot.me/tags/js设计模式/"}]},{"title":"js设计模式之备忘模式","date":"2016-02-01T10:36:00.000Z","path":"2016/02/01/js-备忘模式/","text":"设计模式之备忘模式核心过程 提供一个函数,创建一个静态变量用来记录传入的数据 然后判断,第一次为保存,后面直接从这个变量返回 提高效率 代码如下 1234567891011121314151617&lt;script&gt; function getString(str)&#123; if(getString.cache[str]!=undefined)&#123; console.log('我是从缓存获得的数据'); return getString.cache[str]; &#125; var result=str+''; getString.cache[str]=result; console.log('我是第一次创建的数据'); return result; &#125; getString.cache=&#123;&#125;; console.log(getString('我是一个数据')); console.log(getString('我是一个数据')); //我是第一次创建的数据 我是一个数据 // 我是从缓存获得的数据 我是一个数据&lt;/script&gt;","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"//carrot.me/tags/js设计模式/"}]},{"title":"js设计模式之观察者模式","date":"2016-01-30T10:36:00.000Z","path":"2016/01/30/js-观察者模式/","text":"设计模式之观察者模式核心过程 提供一个对象 例如叫发布者 Publisher 在这个对象里面添加方法 具体方法是注册观察者 删除观察者,调用观察者方法 提供一个函数 该函数用来让一个对象成为发布者 然后根据需求创建观察者,发布者 可以创建多个观察者,发布者,并且观察者也能成为发布者 代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script&gt; //成为发布者具有功能 var Publisher=&#123; //注册观察者功能 addUser:function (fn,type)&#123; if(typeof fn!='function')&#123; throw '请放入一个函数' &#125; if(this.user[type]==undefined)&#123; this.user[type]=[]; &#125; this.user[type].push(fn); // &#125;, //删除观察者功能 removeUser:function (fn,type)&#123; this.state(type,fn); &#125;, //合并 state:function (type,fn)&#123; for(var i=0;i&lt;this.user[type].length;i++)&#123; if(fn==undefined)&#123; this.user[type][i](); &#125;else&#123; this.user[type].splice(i,1); &#125; &#125; &#125; &#125; //成为发布者 function MakePublisher(obj)&#123; for(var i in Publisher)&#123; if(Publisher.hasOwnProperty(i)&amp;&amp;typeof Publisher[i]=='function')&#123; obj[i]=Publisher[i]; &#125; &#125; obj.user=&#123;&#125;; &#125; //发布者 var rose=&#123; eat:function ()&#123; console.log(\"我饿啦--rose\"); this.state('eat'); &#125; &#125; MakePublisher(rose); //观察者 var tom=&#123; tom_eat:function ()&#123; console.log(\"我陪你一起啊,rose--tom\"); &#125; &#125; //注册观察者 第一个参数者观察者所做出反应 第二个指需要观察哪一个方法 rose.addUser(tom.tom_eat,'eat') rose.eat(); //我饿啦--rose // 我陪你一起啊,rose--tom rose.removeUser(tom.tom_eat,'eat'); rose.eat(); //我饿啦--rose tom 没有做出回应&lt;/script&gt;","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"//carrot.me/tags/js设计模式/"}]},{"title":"js设计模式之单利模式","date":"2016-01-29T10:36:00.000Z","path":"2016/01/29/js-单利模式/","text":"设计模式之单利模式核心过程 第一步:提供一个构造函数; 第二步:提供一个私有变量 var instance; 第三步:使用惰性函数 返回 instance; 第四步:继承 新的构造函数原型=旧的构造函数原型(this.proto) 因为不是所有浏览器都兼容 所以直接等于this 第五步:修正新的构造函数的构造器 第六步: 私有变量(instance)=new 新的构造函数 第七步:通过私有变量设置属性和方法: 第八步:把私有变量返回 代码如下 12345678910111213141516171819202122232425&lt;script&gt; function Person()&#123; var instance; Person=function ()&#123; return instance; &#125; Person.prototype=this; Person.prototype.constructor=Person; instance=new Person(); instance.name='小明'; instance.age=20; return instance; &#125; Person.prototype.hi='hi'; var p1=new Person(); var p2=new Person(); Person.prototype.des='描述'; console.log(p1 == p2);//true console.log(p1.constructor == Person);//true console.log(p1.hi);//hi console.log(p2.hi);//hi console.log(p1.des);//描述 console.log(p2.des);//描述&lt;/script&gt;","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"//carrot.me/tags/js设计模式/"}]},{"title":"js设计模式之工厂模式","date":"2016-01-28T04:36:00.000Z","path":"2016/01/28/js-工厂模式/","text":"设计模式之工厂模式核心过程01提供父构造函数 02设置父构造函数的原型对象（属性|方法） 目的是共享 03为父构造函数提供一个静态工厂方法（每次要生产产品就调用这个方法） (001接收产品的类型 002判断是否支持生产该类型的产品 003设置原型继承，获得原型对象上面的方法 004生产该类型的一个产品（创建对象） 005返回对象) 04定制合作伙伴（创建子构造函数） 05调用父构造函数的工厂函数来创建对象 代码如下","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"//carrot.me/tags/js设计模式/"}]},{"title":"js面向对象之Object的静态成员","date":"2016-01-27T12:36:00.000Z","path":"2016/01/27/js-Object的静态成员/","text":"关于Object静态成员的具体介绍 静态成员：01 Object.apply 借用其他对象的方法 用法：对象.方法.apply(this绑定的对象,[参数1，参数2]) 02 Object.arguments 函数内部的一个隐藏参数，这个隐藏参数用来接收实参的。 它本身是一个类似于数组的结构，但是不是数组。它可以像数组一样通过下标来操作数据 03 Object.assign 作用:拷贝对象的属性，多个对象。 04 Object.bind 该方法的作用同call|apply差不多。 05 Object.call 借用其他对象的方法 用法：对象.方法.call(this绑定的对象,参数1，参数2); 06 Object.caller 指向调用当前函数的函数 07 Object.create 创建对象，设置原型对象。 08 Object.getOwnPropertyDescriptor 作用：获得某个实例属性的描述信息（对象） 描述对象： 001 是否可以配置 configurable 如果是true该属性可以被删除，且configurable可以被设置为false 如果是false该属性不可以被删除，且configurable不可以再被设置为true 002 是否可以枚举 enumerable 如果是true,那么在使用for..in循环遍历对象的时候可以列举出来，否则不可以列举 003 是否可以重写 writable 修改这个属性的值 004 具体的值 value 09 Object.getOwnPropertyDescriptors 作用：多个属性的描述信息（对象） 10 Object.defineProperty 设置对象中某个属性的描述信息（对象） 11 Object.getOwnPropertyNames 返回对象中所有实例属性的名称数组 关于是否可以枚举 不论是否可以被枚举都会返回 12 Object.keys 返回对象中所有实例属性的名称数组 只返回可以被枚举的属性 13 Object.getPrototypeOf 获得某个对象的原型对象 14 Object.preventExtensions 作用：禁止扩展对象 不能添加任何的属性和方法 15 Object.seal 作用：密封（封闭）对象 特征：不能够扩展对象，也不能删除对象的属性 16 Object.freeze 作用：冻结对象 特征：不能够扩展对象，也不能删除对象的属性，不能修改","tags":[{"name":"js面向对象","slug":"js面向对象","permalink":"//carrot.me/tags/js面向对象/"}]},{"title":"js面向对象之原型链总结","date":"2016-01-27T10:36:00.000Z","path":"2016/01/27/js-原型链总结/","text":"原型链还是比较重要,单独拿出来总结!① 构造函数作为函数的时候原型默认指向一个空的对象Object {}; 构造函数.prototype为Object{}; 注意点:除了Function作为构造函数之外 它默认指向一个空函数 只有构造函数有.prototype!!对象没有 比如 var o={}; o.prototype==undefined;② 构造函数的原型对象有一个constructor 构造器属性 默认该构造器都是它的构造函数 该属性默认仅仅在原型对象中才有③ 构造函数的原型对象也是一个对象,它也有他的原型对象 构造函数.prototype.proto 所有对象访问原型都是通过.proto 并且都会指向Object的原型(包括Function) 除了Object作为构造函数除外 Object.prototype.proto = null④ 构造函数作为对象的时候 构造函数.proto 都会指向空函数 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt; /* ①①①①①①①①①①①①①①①①①①① * */ /*var o=&#123;&#125;; function Person()&#123;&#125; function Object()&#123;&#125; console.log(o.prototype);//undefined console.log(Function.prototype);//空函数 console.log(Person.prototype );//Object &#123;&#125; console.log(Object.prototype );//Object &#123;&#125;*/ /* * ②②②②②②②②②②②②② * */ /*function Person()&#123;&#125; console.log(Person.prototype.constructor);// function Person()&#123;&#125; function Object()&#123;&#125; console.log(Object.prototype.constructor); // function Object()&#123;&#125; /!* function Function()&#123;&#125; console.log(Function.prototype.constructor); // function Function()&#123;&#125;*!/*/ /* * ③③③③③③③③③③③③③③ * * */ /* function Person()&#123;&#125; console.log(Person.prototype.__proto__);//Object function Object()&#123;&#125; console.log(Object.prototype.__proto__) ;//null;*/ /* function Function()&#123;&#125; console.log(Function.prototype.__proto__);//Object*/ /* * ④④④④④④④④④④④④④④ * * */ /* function Person()&#123;&#125; console.log(Person.__proto__);//空函数 function Object()&#123;&#125; console.log(Object.__proto__);//空函数*/ /*function Function()&#123;&#125; console.log(Function.__proto__);//空函数*/&lt;/script&gt;","tags":[{"name":"js面向对象","slug":"js面向对象","permalink":"//carrot.me/tags/js面向对象/"}]},{"title":"js面向对象总结三","date":"2016-01-27T09:36:00.000Z","path":"2016/01/27/js-面向对象总结三/","text":"太多啦啦啦啦啦,再分一个吧!!!私有变量和函数 定义在构造函数内部而被this对象的变量,在外部无法访问到的变量和函数 公有变量和方法 对外暴露接口,可以通过构造函数对象创建的对象访问的属性和方法 js中有严格模式和非严格模式两种运行环境 严格模式关键字 关键字 “use strict”; 实现严格模式:只需要在脚本代码中添加上上述关键字即可。 关键字具体说明 1234567(1) 注意区分大小写，必须全部都是小写的(2) 注意空格，整个字符串总共10个字符(3) 单引号和双引号无所谓，但是需要有双引号(4) 必须写在作用域的最顶部，注意其位置(5) 可以加分号，也可以不加，但是必须是一个字符串# 严格模式使用注意 ① 所有的变量必须使用var 关键字声明② 不能使用delete关键字删除全局变量 ,以前默认删除失败,严格模式下直接报错③ 在对象中不允许有同名的属性④ 函数的参数必须唯一(不能出现同名的参数)⑤ arguments对象的行为不同,在非严格模式下修改形参的值会反映到arguments中,而严格模式下则相对独立⑥ 禁用了argument.callee和caller函数,他们一个引用函数本身,一个引用调用函数⑦ 不能在if语句中声明函数⑧ 禁止使用eval和arguments作为标识符⑨ 修正this的值,在严格模式下,函数this的值始终是指定的值,无论指定的是什么值。10 禁用了with语句11 去掉了JavaScript中的八进制字面量(以0开头的八进制字面量是无效的语法)12345678**作用范围**① 函数的顶部(只对当前的函数有效)② script标签的顶部,只对当前的标签有效,对页面中其他的script无效**函数的几种调用方式** 01 普通函数调用 内部的this指向全局对象window 02 构造函数调用 内部的this指向新创建的对象 03 对象的方法调用 内部的this指向调用的对象本身 04 通过call 或者是apply方式调用(函数上下文),this指向的是当前的上下文对象 123456789101112# 作用域**作用域**变量其作用的范围就是它的作用域**块级作用域**说明：JavaScript中没有块级作用域**词法作用域** 词法作用域:在代码写好的那一刻,变量的作用域就已经确定的 动态作用域:变量的作用域由执行时的环境所决定 说明:在js中不是动态作用域,当调用的时候,是往上查找的,不会到其他函数的作用域中去查找 1234567891011121314151617181920212223242526**在JavaScript中唯一能够产生作用域的东西是函数****词法作用域的规则**`① 在函数内部允许访问外部的变量``② 只有函数可以限定作用域``③ 作用域规则首先使用提升规则分析``④ 如果当前作用域中有该变量,则不考虑外部作用域的同名变量`# 变量和函数提升**JS中的代码执行分为两个步骤**`① 预解析` JavaScript在预解析阶段,会对使用var关键字声明的变量和function声明的代码块进行提升操作,提升到当前作用域的顶端`② 执行`**代码提升的几种情况****01 函数提升** func(); function func() { console.log(&quot;测试的函数&quot;); } 12**02 变量提升** console.log(a); //打印出来的结果为undefined var a = 10; //var a; //注意:只会对变量的声明进行提升 //console.log(a); //a = 10 12**03 函数同名情况提升** func01(); //打印last function func01() { console.log(“first”); } func01(); //打印last function func01() { console.log(&quot;last&quot;); } //模拟提升后的情况 function func01() { console.log(&quot;first&quot;); } function func01() { console.log(&quot;last&quot;); } func01(); func01(); 123说明：`预处理的时候，同名的函数都会进行提升，但是后面的会覆盖掉前面的`**04 变量名和函数同名的情况** console.log(a); //打印function function a() { console.log(&quot;我是一个函数&quot;); } var a = 20; console.log(a); //打印20 //变量和函数提升后的结果 错误 // function a() {// console.log(“我是一个函数”);// }// var a ;// console.log(a);// a = 20;// console.log(a); //变量和函数提升后的结果 正确 function a() { console.log(&quot;我是一个函数&quot;); } console.log(a); var a = 20; console.log(a); `` 总结:如果出现变量和函数同名的情况,则在进行提升的时候,只会提升函数到当前作用域顶端而忽略变量的提升操作` 作用域链作用域链 01 在js中函数可以创建作用域 02 函数中又可以创建函数(即又可以开辟新的作用域) 03 函数内部的作用域可以访问外部的作用域 04 如果有多个函数嵌套,那么就会构成一个链式的访问结构,也就是作用域链 05 注意:函数内部的作用域可以访问外部的作用域,但是外部的作用域却不能访问内部的作用域 作用域注意点和变量搜索原则注意点 01 在获取值和设置值的时候都是访问变量 02 并非在函数内部写了变量,这个变量就属于当前函数,而是必须使用var 关键字声明的变量才属于当前函数 03 函数在声明的时候,里面的代码并不会执行,只有在函数调用的时候才会执行 04 声明函数时候的函数名,其实也是一个变量名,可以通过这个变量名来进行设置和赋值 05 注意:在变量内部使用var 关键字声明一个变量并不会把同名的全局变量覆盖掉 变量搜索原则 01 在使用变量的时候,首先在自己的作用域中查找 02 如果找到了就直接使用,如果没有找到,那么就到上一级作用域中去查找 03 重复上面的步骤,直到0级作用域,如果还是找不到那么就返回undefined(报错) 闭包简单说明 闭:关闭,封闭 包:包住,包裹 闭包:通过某种方式实现的一个封闭的、包裹的对外不公开的结构|空间 闭包的原理:变量的访问原则(即上一级的作用域无法访问下一级的作用域),其实函数本身就是闭包。 闭包要解决的问题 提供一种间接的方式能够访问到函数内部的数据（变量） 实现思路 01 我们需要能够在函数外部访问函数内部的变量，正常情况无法访问； 02 在函数内部如果新创建函数，那么安装作用域链的原则，这个新创建的内部函数能够访问到函数中的这些变量。 03 我们如果能够操作函数中新创建的函数，那么就能够操作函数中的变量（如访问和设置等） 04 如果要能够操作函数中新创建的函数，那么需要在函数中把新创建的函数返回。 05 调用函数，接收并得到其返回值（是一个函数） 06 调用返回值（函数），通过函数传参的方式来设置函数中的变量。 07 调用返回值（函数），通过在函数内部再次return的方式来访问函数中的变量。 闭包的基本模式 在函数内部创建函数(内部函数),在这个内部函数中,可以操作外部函数中的变量 01 在函数(外部)中创建函数(内部函数),在该函数(内部函数)中操作外部函数中的变量 02 在外部函数中,把内部函数作为返回值返回 03 调用外部函数,并接收其返回值(是一个函数) 04 调用接收到的返回值(内部函数),来间接的操作外部函数中的变量 闭包的作用 最基本的作用:闭包中的变量更安全,只能通过特定的接口来访问 说明: (1)创建一个私有的空间,保护数据,外界如果需要访问数据必须通过函数提供的指定方法 (2)在这些指定的方法中,我们可以设置一些校验的逻辑,以保证对数据访问和设置的安全性 闭包的使用注意进程和线程 进程指的是系统中正在运行的一个应用程序。 线程:一个进程中可以有一个或多个线程,线程是CPU调度的最小单位,是真正执行任务的。 多线程:一个中可能有多条线程,多条线程之间并发的执行多个不同的任务。 单线程:一个进程中只有一条线程,即同一时间只能执行一个操作,只能干一件事情。 javascript是单线程的 js中的线程主要处理三块任务: 01 渲染任务 02 js的代码执行任务 03 js中的事件处理任务(如setTimeOut方法) javascript中代码的执行顺序 01 先把主任务执行完毕(代码任务)02 主任务执行完毕之后再执行次要的任务(包括setTimeOut方法等) 关于setTimeOut函数 函数的作用:一次性定时器(用于延迟执行任务) 参数: 第一个参数:要执行的任务 第二个参数:要延迟执行的时间,时间的单位是毫秒 函数说明： 01 至少在指定的时间后才能够执行回调函数 02 因为要等主任务中的代码执行完毕之后,才回去检查setTimeOut的回调函数。 惰性函数定义 说明： 某个函数直到第一次使用的时候才被正确的定义,并且其具有向后惰性,执行更少的工作。 应用场景: 函数有一些初始化的准备工作要做,且只需要执行一次的情况。 特点: 能够更新自己(函数)的实现。 缺点: 01 当重新定义自身的时候,已经添加到原始函数的任何属性都会丢失。 02 如何函数被赋值给了其他的变量或者是对象方法,那么在使用变量或者是对象方法调用时仍然会执行旧的函数体。 即时函数 定义:在函数定义之后立即执行该函数。 即时函数模式的组成: ① 使用函数表达式来定义函数(匿名函数,注意不能使用函数声明方式) ② 在函数表达式末尾添加一组(),表示立即执行当前函数。 ③ 将整个函数包装在()中,有两种方式 即时函数的作用 01 用来将所有的代码包装到当前的作用域中,并且不会将任何的变量泄露到全局作用域中。 02 js中没有代码块作用域,而函数是js中唯一可以创建作用域的。 03 即时函数就是利用了函数创建作用域这一点,来实现对一些需要封装且不允许外部访问的操作。 即时函数的优点 01 不会产生全局变量,在即时函数内部定义的所有变量都仅仅只是该函数的局部变量,不会造成全局变量污染问题。02 具有更好的封装性,外部无法访问到该函数内部的数据。 命名空间模式 作用: (1)有助于减少程序中所需要的全局变量的数量 (2)并且同时还有助于避免命名冲突或过长的名字前缀。 说明：JavaScript中并没有内置的命名空间 如何实现命名空间 可以为应用程序创建一个全局对象,然后将所有功能都添加到该全局对象中 从而在具有大量函数,对象和其他变量的情况下并不会污染全局范围。 建议 全局命名空间的名称可以随便写,但建议使用项目的名称或者是APP的名称 按照习惯,通过程序员会约定以全部大写的方式来约定全局命名空间。 命名空间模式的缺点 ① 需要输入更多的字符,在每个变量和函数前面都需要附加上前缀,总体上增加了代码的体积。 ② 仅有一个全局实例,意味着代码的任何部分都能够修改当前的实例。 ③ 很长的前缀意味着需要花更长的时间来解析属性(变量|属性访问原则-就近原则) 单例模式的思想 保证一个特定的类只有一个实例。 即当我们第二次创建新对象的时候,得到的应该是和第一次创建的对象一模一样的对象(同一个对象) 其他语言中实现单例模式 在其它有Class的语言中,实现单例模式核心步骤是: 01 在创建对象实例时候判断,该类的实例对象是否已经存在,如果已经存在,那么就直接返回 02 如果不存在,那么就创建一个新的实例对象,并保存起来,下次创建实例对象的时候直接使用。 JavaScript中的单例模式 JavaScript是一门弱类型,动态,基于原型的语言,并没有类,只有对象。 在JavaScript中要实现单例模式有很多种方式。 最简单的方式:使用字面量的方式来创建对象,因为在JavaScript中对象之间永远不可能相等,除非他们是同一个对象。 工厂模式简单说明 工厂模式的目的是用于创建对象,通常在类或者是类的静态方法中实现。 工厂模式的目标 01 用一套方法去创建相似的目标。 02 在编译时不知道具体类型的情况下,为用户提供创建对象的接口 工厂模式实现过程 01 提供一个父构造函数 02 在父构造函数的原型上添加共享的方法 03 在父构造函数身上提供一个静态方法(静态工厂方法) 001 先获取参数(产品类型) 002 判断构造函数是否存在(容错性处理) 003 设置原型链继承:设置子构造函数的原型对象为父构造函数的一个实例对象(目的是为了让子构造函数创建的对象拥有父构造函数上面实例属性和原型属性) 004 使用子构造函数创建实例对象 005 返回新创建的实例对象 04 定义特定的工厂客户(静态方法) 05 通过父构造函数的静态工厂方法来创建产品对象 #观察者模式 观察者模式 观察者模式又名为发布-订阅者模式，它定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 观察者模式的特点（优点） 01 观察者模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案02 观察者模式可以取代对象之间硬性编码的通知机制，一个对象不再是显示的调用另外一个对象的接口，这种模式让两个对象松耦合的联系在一起，它们不需要清楚彼此的实现细节就能够相互通信03 在这种设计模式中，不再是一个对象调用另外一个对象的方法，而是一个对象订阅另一个对象的特定活动并且在状态改变后获得通知","tags":[{"name":"js面向对象","slug":"js面向对象","permalink":"//carrot.me/tags/js面向对象/"}]},{"title":"js面向对象总结二","date":"2016-01-26T04:36:00.000Z","path":"2016/01/26/js-面向对象总结二/","text":"太多啦,再分一个吧!!! hasOwnProperty和in属性操作in关键字 作用：用来检查对象中是否存在某个属性(不区分实例属性和原型属性) 语法：“属性名” in 对象 对象的hasOwnProperty方法 作用：用来检查对象中是否存在指定的属性(只检查实例属性) 语法：对象.hasOwnProperty(“属性名”) 判断某对象中存在且只存在某个原型属性 123function isProperty(obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; (property in obj); &#125; constructor构造器属性说明 使用构造函数创建对象,则 原型对象中的constructor属性指向对应的构造函数 实例对象中的constructor指向对应的构造函数,其中这里的constructor就是从原型中获取的即constructor时实例对象中的原型属性,而非实例属性 继承基本概念继承的概念 继承：即通过一定的方式实现让某个类型A获取另外一个类型B的属性或方法。其中类型A称之为子类型，类型B称之为父类型或超类型。 javaScript中的继承 Object是所有对象的父级|父类型|超类型：js中所有的对象都直接或间接的继承自Object。 继承有两种方式：接口继承和实现继承，在js中只支持实现继承，实现继承主要依赖原型链来完成。 JavaScript中实现继承的几种方式 说明:其他语言中继承通常通过类来实现，js中没有类的概念，js中的继承是某个对象继承另外一个对象，是基于对象的。 原型式继承 原型链继承 经典继承(借用构造函数) 组合继承 原型链继承 实现思想：利用原型（链）让一个对象继承另一个对象的属性和方法 实现本质：重写原型对象 原型链123456① 每个构造函数都有原型对象② 每个对象都有自己的构造函数③ 每个构造函数的原型都是一个对象④ 那么这个构造函数的原型对象也有自己的构造函数⑤ 那么这个构造函数的原型对象的构造函数也有自己的原型对象以上形成一个链式的结构,称之为原型链 原型链中的属性搜索原则1234567 当访问某个对象的成员的时候,会先在自身中查找,如果找到则直接使用 如果在自身中没有找到,则去当前创建当前对象的构造函数的原型对象中查找,如果找到了则直接使用 如果在该原型对象中没有找到,则继续查找原型对象的原型对象(创建该原型对象的构造函数所对应的原型对象),如果找到则直接使用 如果在原型对象的原型对象中也没有找到,则继续向上搜索.... 直到Object的原型对象,若还是没有,则返回undefined(属性)或报错(方法)。**基本写法·代码示例** //01 提供超类型|父类型 function SuperClass() { this.name = &apos;SuperClass的名称&apos;; this.showName = function () { console.log(this.name); } } //02 设置父类型的原型属性和原型方法 SuperClass.prototype.info = &apos;SuperClass的信息&apos;; SuperClass.prototype.showInfo = function () { console.log(this.info); }; //03 提供子类型 function SubClass() { } //04 设置继承(原型对象继承) SubClass.prototype = new SuperClass(); SubClass.prototype.constructor = SubClass; var sub = new SubClass(); console.log(sub.name); //SuperClass的名称 console.log(sub.info); //SuperClass的信息 sub.showInfo(); //SuperClass的信息 sub.showName(); //SuperClass的名称 12345678910111213141516171819202122232425262728# 原型链继承的注意点和问题**注意点** ① 确定原型和实例的关系 instanceof + isPrototypeOf()② 注意重写原型对象的位置，必须先实现原型继承，然后再设置子对象的原型属性和原型方法③ 完成继承之后，不能使用字面量的方式来创建原型[因为会切断原型]**问题**① 父对象的实例属性会转换为子类型原型的原型属性，而如果父类型是实例属性是引用类型则会存在共享问题② 在创建子类型的实例时，不能向父类型的构造函数中传递参数# 经典继承（借用构造函数）&gt;经典继承又称为借用构造函数|伪造继承**基本思想**`在子类型构造函数的内部调用超类型|父类型构造函数``说明：需要借助call|apply方法`代码示例 //01 提供父类型(对象)的构造函数 function SuperType(name) { //02 在构造函数中中设置实例属性,该属性为引用类型 this.family = [‘哥哥’,’姐姐’,’爸爸’,’妈妈’]; //实例属性 this.name = name; }; SuperType.prototype.info = &apos;父类型的原型属性&apos;; //03 提供子类型（对象）的构造函数 function SubType() { //经典继承|借用构造函数|伪造对象继承 //SuperType.call(this); //构造参数传递参数 SuperType.call(this,&apos;张老汉&apos;); }; //04 创建父类型的实例对象,并对内部的实例化属性进行修改 var subDemo1 = new SubType(); var subDemo2 = new SubType(); alert(subDemo1.info); //undefined alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 subDemo1.family.push(&apos;爷爷&apos;,&apos;奶奶&apos;); alert(subDemo1.family); //哥哥,姐姐,爸爸,妈妈,爷爷,奶奶 alert(subDemo2.family); //哥哥,姐姐,爸爸,妈妈 //测试构造函数传递参数 alert(subDemo1.name); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364`点评：能够继承父类型的实例属性,但是无法继承父类型的原型属性和原型方法`**经典继承的优点**① 解决实例对象共享问题，通过调用父对象的构造函数来实现每个子类型（对象）的实例对象均拥有一份父类型实例属性和方法的副本② 可以在调用call方法的时候向构造函数传递参数**经典继承的问题**① 冒充继承的方法无法实现函数的重用② 无法继承父对象的原型属性和原型方法# 组合继承&gt;组合继承|伪经典继承**基本思想**① 使用原型链实现对原型属性和方法的继承② 通过伪造(冒充)构造函数来实现对实例属性的继承代码示例 //01 提供父类型的构造函数 function SuperType(name) &#123; //在构造函数中中设置实例属性,该属性为引用类型 this.family = ['哥哥','姐姐','爸爸','妈妈']; //实例属性 this.name = name; &#125;; //原型方法 SuperType.prototype.showName = function () &#123; console.log(this.name); &#125; //02 提供子类型的构造函数 function SubType(name) &#123; //冒充|伪造 构造参数传递参数 SuperType.call(this,name); &#125;; SubType.prototype = SuperType.prototype; //SubType.prototype = new SuperType();# 基本包装类型`基本类型：字符串 + 数值 + null + undefined + 布尔值`为了便于操作基本类型，ECMAScript提供了三个特殊的引用类型：`Boolean + Number + String`。上述类型和其他的引用类型类似，同时也具备与各自的基本类型相应的特殊行为，每当我们读取一个基本类型的值的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。 var str = '测试字符串'; console.log(str.length); //5 console.log(str.substring(2)); //字符串`思考`：属性和方法本是对象的特征，字符串如何能够拥有length属性以及其他类似subString等方法，内部怎么实现的？基本类型值并不是对象，因此从逻辑上讨论他们不应该有属性和方法。 内部的具体处理 （1）创建String类型的一个实例对象 （2）在实例对象上面读取指定的属性（length）,调用指定的方法（subString） （3）销毁该对象 12345678910111213141516171819202122232425262728293031# isprotoTypeOf和instance**isprotoTypeOf**作用：判断是否是某个实例对象的原型对象`语法:构造函数.protoType.isPrototypeOf(对象)`**instance**作用：用于检查对象是否是某个构造函数(类型)的实例`语法：对象 instance 构造函数``注意：所有的对象都是Object构造函数（类型）的实例`# 静态成员和实例成员**静态成员** 定义在构造函数上面的成员(属性和方法)**实例成员** 定义在实例对象上面的成员(属性和方法)# 对象的拷贝操作**浅拷贝**`如果对象中的属性是引用类型的值,那么存在数据共享问题,修改某个对象会对拷贝的对象产生影响`代码示例 var o = {name:&quot;张三&quot;,car:{number:&quot;2017&quot;,type:&quot;火车&quot;}}; var obj = {}; //obj对象需要拷贝o对象中所有的属性 for (var i in o ){ obj[i] = o[i]; } console.log(obj); o.car.type = &quot;飞船&quot;; console.log(obj); 1234567**深拷贝** 如果对象中的属性是值类型,那么就直接拷贝赋值 如果对象中的属性是引用类型,那么就再次调用拷贝方法,遍历对象代码示例 var o = {name:&quot;张三&quot;,car:{number:&quot;2017&quot;,type:&quot;火车&quot;}}; var obj = {}; function deepCopy(obj,tmp) { tmp = tmp || {}; //如果没有传入,那么就创建一个空的对象 for(var i in obj) { if (obj.hasOwnProperty(i)) //只拷贝实例属性 { //判断是否是引用类型 if ((typeof obj[i]) == &apos;object&apos;) { //重新调用拷贝方法 tmp[i] = Array.isArray(obj[i]) ? [] :{}; deepCopy(obj[i],tmp[i]); }else { //直接拷贝 tmp[i] = obj[i]; } } } } arguments、length和calleearguments参数 说明：在js中的函数中，有两个隐藏的参数分别是this和arguments1234arguments 是一个类似数组的结构,可以通过下标来操作函数的参数,但并非数组类型的。在函数调用的时候,会将函数的所有参数都传入arguments对象中保存,因此我们可以通过操作arguments属性来操作参数形参的数量大于实参的数量,则依次传入,未传入的设置为undefined形参的数量小于实参的数量,则arguments中保存实际的值 length 函数内部的arguments数组拥有length属性,可以通过该属性获取用户调用时传入的实参的个数 函数本身有一个length属性,可以通过该属性来获取形式参数的个数 callee方法 函数内部的arguments对象中,有一个callee方法,该方法指向函数自身,常用于匿名函数的递归调用。 eval 简单说明eval 的基本使用 eval函数用来讲字符串转换为JS的代码,并执行 //说明:使用eval来解析json格式字符串的时候,会将{}解析为代码块,而不是字面量 // 在使用的时候为了避免这种错误,需要在JSO的最外面加上(),如此则会把大括号当做一条语句来解析 var o = eval(&quot;(&quot;+jsonData+&quot;)&quot;); console.log(o); 1234567**eval 注意事项** ① eval函数本身功能强大,但它的特性也为程序带来了很大的不确定性,因此在开发中并不推荐使用。 ② eval函数是动态的执行代码,因此其效率不如直接执行静态脚本高。**eval和Function比较** 相同点:都能够把字符串转换为Javascript的代码 不同点:eval转换为js的代码之后马上就执行,而Function需要先创建函数,调用函数之后才会执行。 ``` Function.prototype原型链关于Function和自定义构造函数的原型对象 Function.prototype 是一个空的函数 自定义构造函数的原型对象是一个空的对象 说明 Function也可以被当做是一个构造函数 通过new Function创建出来的函数,可以认为是Function的实例化对象。 Function的原型对象是一个空的函数,这个空的函数也是一个对象,它的原型对象是Object.prototype。 在JS中,Object的原型对象是所有对象的祖宗。 Function是构造函数,则其原型对象为空的函数 空的函数的原型对象为Object.prototype Function本身也是对象,则其构造函数为:function Function() { [native code] } 是自身 同Object类型 Object本身是构造函数,其原型对象是Object.prototype Object本身也是对象,其构造函数为:function Function() { [native code] Object.prototype01 因为js中所有的对象都继承自Obejct,都可以使用Object对象的原型属性和方法,因此不要轻易的扩展Object.prototype。 02 Object.property中的属性和方法 ① constructor 指向原型相关联的构造函数，为Object ② hasOwnProperty 判断对象中是否拥有某个实例属性(不包括原型链上面的属性) ③ isPrototypeOf 校验某个对象是否是指定对象的原型对象(整条原型链) ④ propertyIsEnumerable 属性是否存在且可枚举(使用for循环可以遍历,即目标属性能否在for循环中显示出来) ⑤ toString() 返回一个描述目标对象的字符串,对象则返回[object object] toString(参数) 参数出可以传入一个用于进制数的参数,该参数的默认值为10(主要针对Number类型有效) ⑥ toLocaleString 同toString,但是会做一些本地化的处理。 ⑦ valueOf() 如果该对象有对应的基本数据类型的值,则返回对应的基本数据类型值,如果没有则返回this本身。 Date对象调用该方法会返回一个时间戳。","tags":[{"name":"js面向对象","slug":"js面向对象","permalink":"//carrot.me/tags/js面向对象/"}]},{"title":"js面向对象总结一","date":"2016-01-25T04:36:00.000Z","path":"2016/01/25/js-面向对象总结一/","text":"因为太枯燥了,直接总结好了,也没特效看!!!!学习面向对象的过程是痛苦的,要理解东西很多,而且很枯燥,但是又不得不学,非常重要,所以面向对象这一部分可是花了好大精力去学习,这一次总结有一部分是自己,也有直接复制人家写的总结,不过目的都是方便自己去回顾 基本类型和复杂类型基本类型（简单数据类型） * string * number * boolean * undefined * null 复杂类型（复杂数据类型） * Object * Array * Date * RegExp * Function * String * Number * Boolean * null * Math 值类型：保存为简单的数据值，赋值只是简单的数据值的复制 引用类型:保存为对象，其本质是指向内存位置的引用(地址)，赋值是对地址的复制 值类型代码示例123456789var num1 = 10;var num2 = num1; //把num1的值复制一份给num2,num1和num2的值相等,除此之外没有任何其他关系console.log(num1,num2); //10,10console.log(num1 == num2); //truenum2 = 20; //修改num2的值为20,不会对num1产生任何的影响console.log(num1,num2); //10,20console.log(num1 == num2); //false 引用类型代码示例123456789101112131415var arr1 = [1,2,3];var arr2 = arr1;console.log(arr1,arr2); //[1,2,3],[1,2,3]console.log(arr1 == arr2); //truevar arr3 = [1,2,3];console.log(arr3); //[1,2,3]console.log(arr1 == arr3,arr2 == arr3); //false,false/** * 代码说明: * arr1和arr2在比较的时候,值相等(都是[1,2,3]),且引用相等(都指向堆中同一块数据),因此arr1和arr2相等 * arr3和arr1以及arr2比较的时候,值相等([1,2,3]),但是引用不相等(arr3指向的是堆中另外一块数据),因此不等 * 总结:引用类型在比较相等的时候,只有值和引用都相等才相等 * */ 02 值类型和引用类型的赋值 赋值操作(=):把当前变量存储的值复制一份给接收的变量 值类型的赋值:把当前变量存储的值(具体的数据)复制一份给接收的变量引用类型的赋值:把当前变量存储的值(具体数据的引用即地址)复制一份给接收的变量 123456789//引用类型使用注意 console.log(arr1,arr2); //[1,2,3],[1,2,3]; console.log(arr1 == arr2); //true arr1.push(4); console.log(arr1,arr2); //[1,2,3,4],[1,2,3,4] /** * 代码说明:因为arr1和arr2内部的引用指向的是同一块数据,所以修改了arr1会对arr2也产生影响 * */ 03 值类型和引用类型作为函数参数处理 形参:占位用的参数,用来接收数据的参数而已 实参:实际传递的参数 — 函数的调用:在函数调用的时候,函数默认会把实参的值赋值给形参 值类型作为参数：在函数内部对形参变量进行修改不会影响到实参的值 引用类型作为参数：在函数内部对形参变量进行修改会影响到实参的值，因为他们的引用指向同一个对象 对象的动态特性在js中可以动态的对对象属性进行增加、修改和删除 代码示例123456789101112131415161718192021222324//01 创建对象var obj = &#123; name:\"刘德华\", age:60&#125;;//02 动态的为对象添加属性obj.height = \"180cm\";console.log(obj.height);//03 动态的为对象添加方法obj.maiMeng = function () &#123; console.log(\"华仔会卖萌噢\");&#125;;obj.maiMeng();//04 修改属性的值:如果设置的属性以前不存在,那么就是添加,如果设置的属性已经存在了,那么就是修改obj.name = \"王宝强\";console.log(obj.name)//05 删除属性delete obj.name;console.log(obj.name); //undefined 访问对象的方法 01 可以使用点语法访问 02 可以使用[]语法访问，注意对象的属性必须是字符串 关键字in和delete的使用01 in关键字 01 判断属性是否存在于对象中，注意所有的key都是字符串 02 for in循环中 遍历对象的 键 代码示例123456789101112var obj = &#123; name:\"张三\", age:18&#125;;for(k in obj)&#123; console.log(k,obj[k]);&#125;//检测obj对象中是否存在name这个属性console.log(\"name\" in obj); 注意：in关键字操作数组的时候检测的是索引值并非数组元素 02 delete关键字 01 删除对象的属性 02 删除未使用var声明的变量 03 返回值为boolean类型，true则 表示是否删除成功 注意12345678910111213141516171819202122232425262728293001 删除的属性如果不存在，返回true02 删除的如果是原型中的属性，返回true 但是删除不成功# 异常异常捕获语句执行的过程为：01 代码正常运行, 如果在try中出现了错误, try 里面出现错误的语句后面的代码都不再执行, 直接跳转到 catch 中02 在catch中处理错误信息03 继续执行后面的代码04 如果 try 中没有出现错误, 那么不走 catch 直接执行后面的代码`捕获异常的优点：`通过try-catch语句进行异常捕获之后，代码将会继续执行，而不会中断。注意：`语法错误异常用try-catch语句无法捕获`，因为在预解析阶段，语法错误会直接检测出来，而不会等到运行的时候才报错。# 函数和对象的创建**定义函数的几种方式**① 函数声明② 函数表达式③ 使用Function类型的构造器创建`代码示例` //01 函数声明 function functionName() { console.log(&apos;以函数声明的方式来定义函数&apos;); } functionName(); //02 函数表达式 var func = function () { console.log(&apos;函数表达式的方式来定义函数&apos;); }; func(); //03 使用Function构造器来创建 var funcName = new Function(); funcName(); //上面的代码等价于 /* function funcName() { } */ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091**关键字new的使用**# 面向对象的三大特性&gt; 面向对象的三大特性:封装、继承、多态**封装** 复用|信息隐蔽** 继承 ** 获取已经存在的对象已有属性和方法的一种方式(获取他人已有财富和资源的一种方式)**多态** 多态表现为: ① 同一操作,作用于不同的对象,会产生不同的解释和行为。 ② 隐藏不同。# 字面量方式创建对象var book1 = &#123; name:\"声名狼藉者的生活\", price:42.00, author:\"福柯\", press:\"北京大学出版社\", read:function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\"); &#125; &#125;;**存在的问题**`[01] 代码复用性差``[02] 如果要创建大量的同类型对象，则需要些大量重复性代码`# 内置构造函数创建对象 var book1 = new Object(); book1.name = \"声名狼藉者的生活\"; book1.price = 42.00; book1.author = \"福柯\"; book1.press = \"北京大学出版社\"; book1.read = function () &#123; console.log(\"我的书名为:声名狼藉者的的生活,作者为福柯....\"); &#125;;**问题**`1 创建的对象无法复用,复用性差``02 如果需要创建多个同类型的对象,如(书籍)则需要写大量重复的代码,代码的冗余度高`# 工厂函数创建对象function createBookNew (name,price,author,press) &#123; var book = new Object(); book.name = name; book.price = price; book.author = author; book.press = press; book.read = function () &#123; console.log(\"我的书名为:\"+book.name+\",作者为\"+book.author+\"....\"); &#125;; return book; &#125;**问题** 对象分类不明确# 自定义构造函数创建对象function CreateBook (name,price,author,press) &#123; this.name = name; this.price = price; this.author = author; this.press = press; this.read = function () &#123; console.log(\"我的书名为:\"+this.name+\",作者为\"+this.author+\"....\"); &#125;; &#125;**构造函数与new关键字**构造函数和普通函数的区别：函数的首字母大写构造函数的作用:用于完成对象的初始化new关键字的作用：用于创建对象（Object类型）**自定义构造函数和简单工厂函数的对比** ① 函数的首字母大写(用于区别构造函数和普通函数)② 创建对象的过程是由new关键字实现③ 在构造函数内部会自动的创建新对象,并赋值给this指针④ 自动返回创建出来的对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071**构造函数的执行过程**`① 使用new关键字创建对象``② 把新创建出来的对象赋值给this``③ 在构造函数内部,使用this为新创建出来的对象设置属性和方法``④ 默认返回新创建的对象(普通函数如果不显示的return则默认返回undefined)。`**构造函数的返回值**01 如果在构造函数中没有显示的return,则默认返回的是新创建出来的对象02 如果在构造函数中显示的return,则依照具体的情况处理 [01] return 的是对象,则直接返回该对象,取而代之本该默认返回的新对象 [02] return 的是null或基本数据类型值,则返回新创建的对象**构造函数方式创建对象存在的问题**`每次创建对象,都会重新创建函数，那么如果创建的对象数量很多,而对象方法内部的实现一模一样,则造成了资源浪费` # 构造函数的使用注意 **构造函数的调用** 01 构造函数可以像普通函数一样不通过new关键字直接调用 02 在使用构造函数创建对象的时候，如果没有传递参数，则（）可以省略 **this** 01 如果使用new 构造函数的方式调用，则this指向内部默认创建出来的空对象 02 如果像调用普通函数一样调用构造函数，则this指向全局对象window(`不要这样使用`) # 原型对象 **原型对象概念** 在构造函数创建出来的时候,系统会默认帮构造函数创建并关联的一个新对象 自定义构造函数的原型对象默认是一个空对象。 **原型对象的作用** 构造函数中的原型对象中的属性和方法可以被使用该构造函数创建出来的对象使用。 即以自定义构造函数方式创建出来的所有对象,自动拥有和共享该构造函数的原型对象中的所有属性和方法。 **如何访问构造函数的原型对象** ① `构造函数.protoType` ② `对象.__proto__（不推荐）` **设置原型对象的属性和方法** ① `利用对象的动态特性来为构造函数的原型对象添加属性和方法` ② `替换原型对象` # 原型对象的使用注意**原型的使用方法**① `利用对象的动态特性给原型添加属性|方法` 如果要添加的方法过多,则有大量重复代码1② `直接替换原型对象` 01 替换前后创建的对象所指向的原型对象不一致02 替换原型对象会切断和之前的原型对象之间的关系12**原型对象的使用注意** ① 访问属性:构造函数创建出来的对象在访问属性的时候,会先在实例内查找,如果没有找到则进一步到对应的原型对象中查找 ② 设置属性: 在使用点语法进行赋值的时候,无法操作到对应的原型对象 如果该属性在对象中已经存在,则修改该属性的值 如果该属性在对象中尚未存在,则新增该属性 ③ 设置原型对象的属性: [01] 设置原型对象的属性,只能通过构造函数.Prototype的方式|替换原型对象的方式设置 [02] 如果原型对象的属性是值类型,那么只能通过Person.prototype.属性的方式修改其值 如果原型对象的属性是引用类型,那么可以通过对象名.引用对象.属性名的方式设置|修改 (1) 使用构造函数创建出来的多个对象的原型对象中的该属性指向的是同一块数据 (2) 某个对象对该原型对象属性进行了修改会影响到其他的对象","tags":[{"name":"js面向对象","slug":"js面向对象","permalink":"//carrot.me/tags/js面向对象/"}]},{"title":"jquery进价之原理分析(入口,节点,样式,属性)","date":"2016-01-24T09:36:00.000Z","path":"2016/01/24/jquery-入口原理分析/","text":"深入jquery的源码,感受作者的编程之美这是一个非常非常难得地方,当初也在考虑要不要深入学习,后来发现,基本每一个网站都会用到jquery,如此热门的框架,身为一个前端工程师怎么能不去深入学习.这一部分学习主要分为3个,一个是入口的学习,另外一个是dom节点的操作,最后一个是各种操作方法.入口原理其实就是一个即时函数,作者自定义个方法叫$或者jquery,通过window暴露出去,整一个入口的原理就是作者会返回一个叫jquery.fn.init的对象给我们调用者,然后设置init需要初始化的数据,这一部分就是入口函数,我们判断用户传入的各种数据,从而得到正确处理.其次是作者通过一个方法来扩展对象和函数本身具有的方法,这样方便了以后的开发人员利用jquery自己去扩展一些好用的方法.整一个入口的大概思路是这样,具体我们看代码吧,其实只要把入口给弄明白了,其他一些常用的方法就是通过原生js进行封装,更加方便我们操作!这一份代码我足足花了1个星期去学习,敲了3遍.注释也是全部地方都上注释了,为了就是让自己彻底弄明白里面的一些原理. 代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632/* 本身是一个即时函数 避免与其他框架的冲突,防止全局变量的污染 window的作用 把里面的数据传递出去 压缩可以节省空间 undefined作用 ie8以下undefined可以被修改 压缩可以节省空间 */(function (window, undefined) &#123; //创建jQuery函数返回 init的实例化对象 var Jquery = function (selector) &#123; return new Jquery.fn.init(selector); &#125;; Jquery.fn = Jquery.prototype = &#123; constructor: Jquery, //初始化 init: function (selector) &#123; //判断 0 false ''空字符串 null NaN undefined; if (!selector) &#123; //直接返回对象 return this; //判断是否是函数 &#125; else if (Jquery.isFunction(selector)) &#123; Jquery.ready(selector); &#125;//判断是否是字符串 else if (Jquery.isString(selector)) &#123; //先去除字符串的空格 Jquery.trim(selector); //字符串两种情况 ①标签片段 ②选择器 //①标签片段 把一级标签作为属性添加到对象中 if (Jquery.isHTML(selector)) &#123; //创建一个dom节点 var div = document.createElement('div'); //设置selector为dom节点的innerHTML div.innerHTML = selector; //拿到dom节点的所有子元素 一级标签 var children = div.children; //通过 [].push.apply(this,children) 把children的一级标签添加到this中 [].push.apply(this, children); //也可以通过for循环遍历 但是代码量增加,所以不用 后面道理一样 //返回对象; return this; //②选择器 把符合要求的选择器作为属性添加到对象中 &#125; else if (document.querySelectorAll(selector)) &#123; //拿到传入selector的dom节点 var nodes = document.querySelectorAll(selector); //通过 [].push.apply(this,nodes) 把nodes的标签添加到this中 [].push.apply(this, nodes); return this; &#125; //判断是否是真数组和伪数组 //先判断是否是对象 并且不是函数 并且不是window对象 //再判断真数组和伪数组 //把真数组或伪数组的数据作为属性添加到对象中 &#125; else if (Jquery.isRealArray(selector)) &#123; //不管真伪都转换为真数组 var newArr = [].slice.call(selector); //通过[].push.apply(this,newArr) 把newArr的元素添加到this中 [].push.apply(this, newArr); //其他情况 把传入的数据作为属性添加到对象中 &#125; else &#123; this[0] = selector; this.length = 1; return this; &#125; &#125;, //版本号 jquery: '1.3.1', //默认选择器取值 selector: '', //默认对象长度 length: 0, //把对象(伪数组,数组)转换为数组 toArray: function () &#123; return [].slice.call(this); &#125;, //获取对应下标的元素 get: function (index) &#123; //判断是否传入参数 如果没有则返回自身 if (arguments.length == 0) &#123; return this.toArray(); &#125; else &#123; //判断下标是否大于等于0 if (index &gt;= 0) &#123; return this[index]; //小于0 &#125; else &#123; return this[this.length + index]; &#125; &#125; &#125;, //获取对应的下标元素 返回的是Jquery对象 eq: function (index) &#123; //判断是否传入参数,如果没有返回自身 if (arguments.length == 0) &#123; return Jquery(); &#125; else &#123; return $(this.get(index)); &#125; &#125;, //第一个元素 first: function () &#123; return this.eq(0); &#125;, //最后一个元素 last: function () &#123; return this.eq(-1); &#125;, //添加 push: [].push, //排序 sort: [].sort, //按照指定下标指定数目删除元素 splice: [].splice, //遍历对象 把遍历到的数据传给回调使用 each: function (fn) &#123; Jquery.each(this, fn); &#125; &#125;; //改变初始化函数的原型为jQuery的原型 Jquery.fn.init.prototype = Jquery.fn; //给函数扩展静态方法和给对象原型扩展实例方法 Jquery.extend = Jquery.fn.extend = function (obj) &#123; for (var key in obj) &#123; this[key] = obj[key]; &#125; &#125;; //给函数添加静态方法 Jquery.extend(&#123; //是否是字符串 isString: function (string) &#123; return typeof string === 'string'; &#125;, //是否是标签片段 isHTML: function (html) &#123; return html.charAt(0) === '&lt;' &amp;&amp; html.charAt(html.length - 1) === '&gt;' &amp;&amp; html.length &gt;= 3; &#125;, //是否是对象 isObject: function (obj) &#123; return typeof obj === 'object'; &#125;, //去除首尾空格 trim: function (string) &#123; // 1.判断当前浏览器是否支持trim方法 if (string.trim) &#123; return string.trim(); &#125; // 2.如果不支持就自己实现 else &#123; return string.replace(/^\\s+|\\s+$/g, ''); &#125; &#125;, //是否是函数 isFunction: function (fn) &#123; return typeof fn === 'function'; &#125;, //是否是window对象 isWindow: function (win) &#123; return typeof win === Window.window; &#125;, //是否是真伪数组 isRealArray: function (arr) &#123; if (!Jquery.isObject(arr) || (Jquery.isFunction(arr)) || (Jquery.isWindow(arr))) &#123; return false; &#125; if ((&#123;&#125;).toString.call(arr) === '[object Array]') &#123; return true; &#125; else if ('length' in arr &amp;&amp; arr.length - 1 in arr) &#123; return true; &#125; else &#123; return false; &#125; &#125;, //监听文档是否加载完毕 ready: function (fn) &#123; //判断文档是否加载完毕 if (document.readyState == 'complete') &#123; fn(); &#125; //判断是否支持addEventListener if (document.addEventListener) &#123; document.addEventListener('DOMContentLoaded', fn); &#125; //如果不支持就通过attachEvent else &#123; document.attachEvent('onreadystatechange', function () &#123; // 为了避免重复执行, 需要判断当前的状态是否已经加载完毕 if (document.readyState == 'complete') &#123; fn(); &#125; &#125;); &#125; &#125;, //遍历对象 把遍历到的数据传给回调使用 each: function (obj, fn) &#123; //判断obj的是否为真伪数组 if (Jquery.isRealArray(obj)) &#123; //for循环遍历 for (var i = 0; len = obj.length, i &lt; len; i++) &#123; //判断fn函数的执行结果是否是false, 如果是false就跳出循环 if (fn.call(obj[i], obj[i], i) == false) &#123; break; &#125; &#125; &#125; else &#123; //对象 for (var key in obj) &#123; if (fn.call(obj[key], obj[key], key) == false) &#123; break; &#125; &#125; &#125; &#125;, //遍历对象 把遍历到的数据传给回调使用 然后把回调的返回值收集起来组成一个新的数组返回 map: function (obj, fn) &#123; //定义一个空数组用来保存遍历到的数据 var res = []; //判断真伪数组 if ('length' in obj) &#123; for (var i = 0; len = obj.length, i &lt; len; i++) &#123; res.push(fn(obj[i], i)); &#125; &#125; else &#123; //对象 for (var key in obj) &#123; res.push(fn(obj[key], key)); &#125; &#125; return res; &#125;, //获取css样式 getStyle: function (dom, value) &#123; return window.getComputedStyle ? window.getComputedStyle(dom)[value] : dom.currentStyle[value]; &#125;, //添加事件的兼容方法 addEvent: function (dom, type, fn) &#123; //传入的dom是一个节点 类型是一个字符串 方法是一个函数才执行后面代码 有一个不满足就结束 if (!dom.nodeType || !Jquery.isString(type) || !Jquery.isFunction(fn)) &#123; return; &#125; // 前面为谷歌,后面为IE; return window.addEventListener ? dom.addEventListener(type, fn) : dom.attachEvent(\"on\" + type, fn); &#125;, //删除事件的兼容方法 removeEvent: function (dom, type, fn) &#123; //传入的dom是一个节点 类型是一个字符串 方法是一个函数才执行后面代码 有一个不满足就结束 if (!dom.nodeType || !Jquery.isString(type) || !Jquery.isFunction(fn)) &#123; return; &#125; // 前面为谷歌,后面为IE; return window.removeEventListener ? dom.removeEventListener(type, fn) : dom.detachEvent(\"on\" + type, fn); &#125;, &#125;); //dom相关方法 Jquery.fn.extend(&#123; //清空所有元素内容 empty: function () &#123; //遍历 this 指对象 this.each(function (obj, key) &#123; //this 指对象里面具体的数据 因为在each方法已经修改了this指向 this.innerHTML = ''; &#125;); return this; &#125;, //删除指定的元素 remove: function () &#123; //遍历 this.each(function (obj, key) &#123; //找到该元素的父节点 var father = obj.parentNode; //用该父节点删掉自己 father.removeChild(obj); &#125;); return this; &#125;, html: function (context) &#123; //判断是否传入参数 if (arguments.length == 0) &#123; //返回第一个元素所有内容 return this[0].innerHTML; &#125; else &#123; //遍历 this.each(function (obj, key) &#123; obj.innerHTML = context; &#125;); return this; &#125; &#125;, text: function (context) &#123; var res = ''; //保存text方法的arguments长度 var len = arguments.length; //遍历 this.each(function (obj, key) &#123; //没有传入参数,拿出所有obj的innerText if (len == 0) &#123; res += obj.innerText; &#125; else &#123; //直接替换 obj.innerText = context; &#125; &#125;) return len == 0 ? res : this; &#125;, //把所有的元素，添加到指定的元素后面 appendTo: function (selector) &#123; //把传入的元素转换成Jquery对象 var Jselector = $(selector); //用来保存要添加的元素 返回该数组 var res = []; //先遍历对象元素 this.each(function (obj, key) &#123; //再遍历指定元素 $.each(Jselector, function (target, index) &#123; //判断是否是第一次 if (index == 0) &#123; //直接添加 target.appendChild(obj); //添加到数组 res.push(obj); &#125; else &#123; //直接克隆添加 var cloneObj = obj.cloneNode(true); //添加 target.appendChild(cloneObj); //添加到数组 res.push(cloneObj); &#125; &#125;) &#125;); //返回Jquery对象 return $(res); &#125;, //把所有的元素，添加到指定的元素最前面 //具体方法和appendTo方法差不多 不做注释了 prependTo: function (selector) &#123; var Jselector = $(selector); var res = []; this.each(function (obj, key) &#123; $.each(Jselector, function (target, index) &#123; if (index == 0) &#123; //插入到指定元素最前面 target.insertBefore(obj, target.firstChild); res.push(obj); &#125; else &#123; var cloneObj = obj.cloneNode(true); target.insertBefore(cloneObj, target.firstChild); res.push(cloneObj); &#125; &#125;) &#125;); return $(res); &#125;, //给所有的元素，在最后面添加新的内容 append: function (context) &#123; //判断是否是对象 if (!$.isObject(context)) &#123; //遍历对象把指定内容添加到最后 this.each(function (obj, key) &#123; obj.innerHTML += context; &#125;) &#125; else &#123; $(context).appendTo(this); &#125; &#125;, // 给所有的元素的最前面 添加新的元素 prepend: function (context) &#123; //判断是否是对象 if (!$.isObject(context)) &#123; this.each(function (obj, key) &#123; obj.innerHTML = context + obj.innerHTML; &#125;) &#125; else &#123; $(context).prependTo(this); &#125; &#125; &#125;); //属性以及css操作 Jquery.fn.extend(&#123; //获取或设置属性节点 attr: function (name, target) &#123; //没有传入参数 if (arguments.length == 0) &#123; throw '请传入参数'; &#125; else if (arguments.length == 1) &#123; //一个参数 返回第一个节点的属性 return this[0].getAttribute(name); //两个参数 &#125; else if (arguments.length == 2) &#123; //遍历取出每一个value设置属性为目标值 this.each(function (value, key) &#123; value.setAttribute(name, target); &#125;) &#125; &#125;, //删除属性节点 removeAttr: function (name) &#123; //没有参数 返回一个Jquery对象 if (arguments.length == 0) &#123; return this; &#125; // 遍历取出所有元素 this.each(function (ele, index) &#123; //删除对应的属性名称 ele.attributes.removeNamedItem(name); &#125;); return this; &#125;, //设置或获取属性 prop: function (name, target) &#123; //没有传入参数 返回一个Jquery对象 if (arguments.length == 0) &#123; return this; //传入一个参数 返回第一个节点的属性 &#125; else if (arguments.length == 1) &#123; return this[0][name]; //两个参数 &#125; else if (arguments.length == 2) &#123; this.each(function (value, key) &#123; value[name] = target; &#125;) &#125; return this; &#125;, //删除属性 removeProp: function (name) &#123; //没有传入参数 返回一个Jquery对象 if (arguments.length == 0) &#123; return this; &#125; //遍历删除输入的属性 this.each(function (ele, index) &#123; delete ele[name]; &#125;); return this; &#125;, //设置样式方法 css: function (key, value) &#123; //没有传入参数 返回一个Jquery对象 if (arguments.length == 0) &#123; throw '请传入参数'; //一个参数 &#125; else if (arguments.length == 1) &#123; //判断是否是字符串 返回第一个的样式 if (Jquery.isString(key)) &#123; return Jquery.getStyle(this[0], key); //判断是否是对象 &#125; else if (Jquery.isObject(key)) &#123; this.each(function (ele, index) &#123; Jquery.each(key, function (styleValue, styleName) &#123; ele.style[styleName] = styleValue; &#125;) &#125;) &#125; //2个参数 &#125; else if (arguments.length == 2) &#123; this.each(function (ele, index) &#123; ele.style[key] = value; &#125;) &#125; return this; &#125;, //获得value属性 val: function (value) &#123; //不传入参数 if (arguments.length == 0) &#123; //返回第一个value属性 return this[0].value; //传入一个参数 &#125; else if (arguments.length == 1) &#123; //遍历设置value值为传入的值 this.each(function (ele, index) &#123; ele.value = value; &#125;) &#125; return this; &#125;, //判断是否有这个类 hasClass: function (name) &#123; //没有传入参数 if (arguments.length == 0) &#123; //返回false; return false; //传入参数 &#125; else if (arguments.length == 1) &#123; //定义标记 var flag = false; //遍历拿出对应的className属性 this.each(function (ele, index) &#123; var className = ' ' + ele.className + ' '; //判断结果不等于-1存在这个类名 if (className.indexOf(' ' + name + ' ') != -1) &#123; //改变标记为true; flag = true; //中断循环 return false; &#125; &#125;); //返回标记 return flag; &#125; &#125;, //添加类名 addClass: function (name) &#123; //没有传入参数 if (arguments.length == 0) &#123; //返回this return this; &#125; else if (arguments.length == 1) &#123; //把传入的类名进行切割 var newName = name.split(' '); //遍历对象 this.each(function (ele, index) &#123; //遍历类名 Jquery.each(newName, function (value, key) &#123; //判断是否有这个类名,没有才添加 if (!$(ele).hasClass(value)) &#123; ele.className += ' ' + value; &#125; &#125;) &#125;) &#125; return this; &#125;, //删除类名 removeClass: function (name) &#123; //没有传入参数 删除所有类名 if (arguments.length == 0) &#123; //遍历 this.each(function (ele, index) &#123; ele.className = ''; &#125;) &#125; else if (arguments.length == 1) &#123; //把传入的类名进行切割 var newName = name.split(' '); //遍历对象 this.each(function (ele, index) &#123; //遍历类名 Jquery.each(newName, function (value, key) &#123; //判断是否有这个类名,有才去删除 if ($(ele).hasClass(value)) &#123; var className = ' ' + ele.className + ' '; //替换 ele.className = className.replace(' ' + value + ' ', ' '); &#125; &#125;) &#125;) &#125; return this; &#125;, //切换类名 有就删除,没有就添加 toggleClass: function (name) &#123; //没有传入参数 if (arguments.length == 0) &#123; //参数所有类名 return this.removeClass(); &#125; else &#123; //把传入的类名进行切割 var newName = name.split(' '); // 2.遍历 this.each(function (ele, index) &#123; ele = $(ele); $.each(newName, function (value, key) &#123; //判断是否有这个类名,有就删除,没有就添加 if (ele.hasClass(value)) &#123; ele.removeClass(value); &#125; else &#123; ele.addClass(value); &#125; &#125;); &#125;); &#125; return this; &#125; &#125;); //事件的操作 Jquery.fn.extend(&#123; //添加事件方法 on: function (type, fn) &#123; //遍历对象 this.each(function (ele, index) &#123; //判断是ele否具有cache_Event这个属性 ele.cache_Event = ele.cache_Event || &#123;&#125;; //判断是否存在这个属性 没有就创建对应的数组 if (!ele.cache_Event[type]) &#123; ele.cache_Event[type] = []; //给每一个对象注册事件 Jquery.addEvent(ele, type, function () &#123; //遍历数组调用数组里面的方法 //如果数组长度为0则结束循环 var len = ele.cache_Event[type] ? ele.cache_Event[type].length : 0; for (var i = 0; i &lt; len; i++) &#123; ele.cache_Event[type][i].call(ele); &#125; &#125;) &#125; //把传入的fn放到数组里面 ele.cache_Event[type].push(fn); &#125;) &#125;, //删除事件方法 off: function (type, fn) &#123; //没有传入参数,删除所有事件 if (arguments.length == 0) &#123; this.each(function (ele, index) &#123; //把动态自定义的属性赋值为空对象 ele.cache_Event = &#123;&#125;; &#125;); //一个参数,删除指定的事件所有方法 &#125; else if (arguments.length == 1) &#123; this.each(function (ele, index) &#123; //让保存该事件的数组赋值为空数组 ele.cache_Event[type] = []; &#125;); //2个参数 删除指定事件的指定函数 &#125; else if (arguments.length == 2) &#123; //遍历对象 this.each(function (ele, index) &#123; //找到传入参数所对应的位置 var index = ele.cache_Event[type].indexOf(fn); //删除该函数 ele.cache_Event[type].splice(index, 1); &#125;) &#125; return this; &#125; &#125;); //把jQuery函数通过window暴露出去 window.jquery = window.$ = Jquery;&#125;)(window);","tags":[{"name":"jquery","slug":"jquery","permalink":"//carrot.me/tags/jquery/"}]},{"title":"jquery学习总结","date":"2016-01-24T04:36:00.000Z","path":"2016/01/24/jquery-总结/","text":"jquery基础的学习总结 1.添加结点 内部追加 .prepend(); 在ul之后添加标签 .prependTo(); 在第一个li之前添加标签 .append();把newtag添加到第一个li之前 .appendTo();在指定元素之后追加 $(&apos;ul&apos;).prepend(newtag); $(newtag).prependTo(&apos;li&apos;); $(&apos;ul&apos;).append(newtag); $(newtag).appendTo(&apos;li&apos;); 外部追加 .after(); .before(); .insertBefore();insertBefore() 方法在被选元素之前插入 HTML 标记或已有的元素。 .insertAfter(); $(&apos;ul&apos;).after(newtag); $(&apos;ul&apos;).before(newtag); $(newtag).insertBefore(&apos;ul&apos;); $(newtag).insertAfter(&apos;ul&apos;); 2.删除结点 .remove(); 把当前结点删除 .empty(); 清空结点当中的所有内部. 把当前结点删除 $(&apos;ul&apos;).remove(); 清空结点当中的所有内部. $(&apos;ul&apos;).empty(); 3.替换结点 .replaceWith() 把p结点替换成newTag $(&apos;p&apos;).replaceWith(newTag); 4.复制结点 .clone() $(&apos;button&apos;).click(function () { 复制第一个li var newTag = $(&apos;li:first&apos;).clone(); $(&apos;ul&apos;).append(newTag); }); 1.事件驱动,事件委托事件冒泡 js当中的,冒泡需要兼容w3c和IE的,我们要做一个兼容的封装函数,再进行调用.jq已经将兼容的功能放到了后台.我们只需要调用就可以了. 冒泡行为, 在页面当中重叠了多个元素之后, 都绑定了同一个事件.就会出现冒泡问题. 阻止事件冒泡 事件的默认行为: on 可以绑定多个事件. 事件委托作用,因为动态添加的节点绑定事件时候会失效,所以需要采用事件委托帮助动态创建的节点绑定事件 1.样式操作传入一个参数为查询,传入2个为修改,传入一个对象为批量修改 $(&apos;div&apos;).css(&apos;width&apos;) 2.属性和属性节点操作传入参数和css方法一样道理 $(&apos;div&apos;).attr(&apos;width&apos;) $(&apos;div&apos;).prop(&apos;width&apos;) 3.动画的操作动画效果很强大 $(&apos;div&apos;).faIn() $(&apos;div&apos;).faOut() $(&apos;div&apos;).slideIn() $(&apos;div&apos;).slideOut() ...... .... .. $(&apos;div&apos;).animate() 4.类名的操作$(&apos;div&apos;).addClass() $(&apos;div&apos;).removeClass() $(&apos;div&apos;).hasClass() 5.各种强大的选择器$(&apos;div&apos;).eq() $(&apos;div&apos;).find() $(&apos;div&apos;).children() $(&apos;div&apos;).end() ...","tags":[{"name":"jquery","slug":"jquery","permalink":"//carrot.me/tags/jquery/"}]},{"title":"jquery入门之备忘录提醒功能","date":"2016-01-23T04:36:00.000Z","path":"2016/01/23/jquery-备忘提醒功能/","text":"一个小项目哦,用来备忘自己的信息,并且加以提醒功能这个也算一个小项目了吧,也是写了好几遍才把逻辑理清楚,做这些小项目最重要就是思路,把实现步骤一个个写出来,后面就可以很顺利的写出来了,这里也用到其他框架一个是store.min.js,另外一个是时间界面框架jquery.datetimepicker.full.js,具体原理如下 ①判断滚动距离让小火箭出现,然后改变顶部样式,点击小火箭可以回到顶部②当用户点击发布按钮,记录一些必要的变量用来进行以后操作,定义一个数组,把所有数据都保存到数组中③动态创建节点,根据数组中保存数据以及数量进行布局④删除按钮,删除数组中对应的数据即可⑤详情按钮可以让用户设置一些内容以及提醒时间,然后之前定义过的变量保存用户输入的内容⑥更新按钮,用户的点击更细按钮,就开始更新数组中的数据⑦开个定时器用来判断用户输入的时间,假如到时间就提醒代码如下","tags":[{"name":"jquery","slug":"jquery","permalink":"//carrot.me/tags/jquery/"}]},{"title":"jquery入门之瀑布流布局","date":"2016-01-22T06:36:00.000Z","path":"2016/01/22/jquery-瀑布流/","text":"用jquery再做一次瀑布流效果我们强大jquery能帮助我们更快的去找到我们想要的元素,更快的实现各种方法,更加不用自己封装运动框架,这些jquery都帮我们弄了,感谢大神给我们带来如此方便的框架同时,也值得我们深入研究这一个框架.锋利的jquery这本书写得挺好,看完视频看完书之后,对一些基本的用法已经很熟悉了.然后我用jquery框架再次实现一次瀑布流,代码缩减了很多,原理和之前是一样的","tags":[{"name":"jquery","slug":"jquery","permalink":"//carrot.me/tags/jquery/"}]},{"title":"js特效之滑动绚丽小球","date":"2016-01-21T09:36:00.000Z","path":"2016/01/21/js-绚丽小球/","text":"让你玩一整天这一个特效是非常非常炫酷啊,真的可以玩一天(几分钟),实现原理有几步,是不是很想学呢?这一次用面向对象的思想去实现这个效果 ,而且用了一个框架Underscore-min.js 也是个不错的框架①定义构造函数,初始化一些小球必备数据,比如位置x,y,颜色,大小 一些控制小球大小,位置的变量,定义一个数组用来保存小球,用于优化内存②定义一个创建函数,里面创建小球,把小球对应的样式设置好③小球移动动画,就是让x,y抽移动,当然,需要做优化,要不卡死了,当小球的大小小于0了就在数组中移除掉④鼠标滑动时候创建实例化对象,并且给上对应的数据⑤开个定时执行创建和移动方法,当然每一次出现小球之前都要消灭节点啦,要不卡死你","tags":[{"name":"js炫酷特效","slug":"js炫酷特效","permalink":"//carrot.me/tags/js炫酷特效/"}]},{"title":"js特效之有3D感图片切换","date":"2016-01-20T06:36:00.000Z","path":"2016/01/20/js-3D图片切换/","text":"比较炫酷的图片切换这一个特效我感觉是比较帅的,而且实现原理也非常简单,主要运用了数组的一些方法①定义一个数组,把每一张图片所需要的属性都放上②点击左右按钮进行切换,就是对数组进去操作,把当前点击移动到数组的末尾或者第一个位置,再运用自己封装的动画框架进行动画即可","tags":[{"name":"js炫酷特效","slug":"js炫酷特效","permalink":"//carrot.me/tags/js炫酷特效/"}]},{"title":"js特效之瀑布流布局","date":"2016-01-19T09:02:00.000Z","path":"2016/01/19/js-瀑布流布局/","text":"经典布局方式瀑布流这个特效主要是设计到布局,采用经典瀑布流方式,比如像蘑菇街就是这种效果,实现这个效果主要原理有①每一张图片的宽度是固定的,但是高度是不同的②根据图片(数据)动态创建节点,然后把拿到的图片(数据)放到页面上③需要求出一个屏幕每一行能够容纳多少张照片④每张创建节点添加到页面的时候,都是根据每一行中高度最短的那个,然后布局到其后面⑤我们需要找出每一行中高度最小的那一张图片,然后下一个节点就放在高度最小的图片下面,并且每一次我们安放好一个节点之后,都需要更新该列的高度.⑥当我们把数据都创建完,如果想继续滑动再创建数据,需要找出最后一个数据,然后根据这个数据距离顶部的高度与滚动条滚动距离+一个屏幕的高度进行比较,重而判断是否需要再次加载数据具体代码如下","tags":[{"name":"js炫酷特效","slug":"js炫酷特效","permalink":"//carrot.me/tags/js炫酷特效/"}]},{"title":"js特效之放大镜效果","date":"2016-01-18T03:02:00.000Z","path":"2016/01/18/js-放大镜效果/","text":"找呀找呀,变大!!!!这个特效是一个放大镜效果,当鼠标移上去的时候出现放大的图片,效果还是很不错的,主要原理有几步①在鼠标移动的时候需要求出对应放大镜的位置,进行判断防止越界问题②在显示放大图片时候,需要求出原始图片,放大图片,放大镜位置,以及放大图片放大镜位置,四者之间的关系,根据求出放大图片放大镜的位置让放大图片进行移动,从而达到类似放大镜的效果③最后利用排他思想进行图片的切换,从而达到多张照片都实现放大镜效果代码如下","tags":[{"name":"js炫酷特效","slug":"js炫酷特效","permalink":"//carrot.me/tags/js炫酷特效/"}]},{"title":"js特效之满天星星","date":"2016-01-17T04:02:00.000Z","path":"2016/01/17/js-满天星星/","text":"满天星空亮闪闪呀这个特效代码很简单,但是效果却出奇的漂亮,用到了css3的属性,虽然有兼容性问题,不过确实又简单效果也很好主要原理有几步①动态创建节点②设置几个随机值,比如星星的大小,星星的位置,星星做动画的延迟时长③在对应的style样式进行设置代码如下","tags":[{"name":"js炫酷特效","slug":"js炫酷特效","permalink":"//carrot.me/tags/js炫酷特效/"}]},{"title":"js特效之轮播图切换","date":"2016-01-16T04:02:00.000Z","path":"2016/01/16/js-轮播切换/","text":"轮播图切换一个比较简单的轮播图切换,实现原理也很简单啦!!不过还没有用自己封装的运动框架①定义一些变量记录速度,目标值,索引②左右按钮控制索引的增加或减少③根据索引进行向左或向右移动④判断索引是否越界让其回到对应位置具体代码如下","tags":[{"name":"js炫酷特效","slug":"js炫酷特效","permalink":"//carrot.me/tags/js炫酷特效/"}]},{"title":"js特效之九宫格思想","date":"2016-01-15T03:02:00.000Z","path":"2016/01/15/js-九宫格思想/","text":"九宫格思想终于开始写我js炫酷特效咯,不知道为什么写到这里就非常兴奋啊!!因为我对炫酷特效真的非常感兴趣,当然啦,其他像面向对象,后台等也是有兴趣的,只不过这里兴趣最大啦!!九宫格思想大概原理就是求出每一行和每一列 根据列和行来实现一些特效,布局之类的,甚至是炫酷的图片截取,比如用精灵图截取一个爆炸效果之类,来看看简单的应用吧!","tags":[{"name":"js炫酷特效","slug":"js炫酷特效","permalink":"//carrot.me/tags/js炫酷特效/"}]},{"title":"js学习之总结js基础部分","date":"2016-01-14T04:02:00.000Z","path":"2016/01/14/js-基础总结/","text":"js基础总结自己花了一点时间做总结!当然如果有不对敬请见谅啦,以后回过头想复习或者找某一个难题时候或许能帮到我呢!! 当然有一部分是复制其他人的代码!! 学习整一个js基础花了10几天时间,所以感觉还是挺深的,后面还有我的一些炫酷特效,因为我是基本自学全部课程,然后回过头想想自己是不是要把自己学习历程发出来,以后自己看到时候也会感激现在自己如此努力.后面就期待我的炫酷特效吧(其实就给我自己看啦,哈哈) 二.注释的认识• 注释的作用:用来说明代码,提升代码的可读性• 注释的种类:1.单行注释 使用 // 快捷键是crl +/ 2.多行注释 使用/*/快捷键是 ctr +shift +/三.变量• 变量的定义:变量是用来存储数字,字符以及可以表示这些东西的东西,• 变量的使用1 .声明变量 var 2.赋值变量 = 3.使用变量.例如 var a; a = 5;console.log(a);• 变量的命名:从语法意义上命名,变量是由字母数字,下划线以及$符号组成,但是不能一数字开头,而且不能使用保留字;从形式上变量是由他的实际表示的意思的英文组成,然后采用驼峰命名法,就是如果当一个变量是由多个单词组成,那么当第二个单词开始的每一个单词的第二个字母都是大写,例如 lastName• 变量的类型1,数值 2.字符 3.布尔 4.对象 5.未定义类型• 变量的赋值:用来赋值的值不会改变,被赋值的值会发生改变,• 变量如果不赋值会输出未定义类型:var a ; console.log(a);• 其他类型和布尔类型的转化1.对于数值类型,只要不是0就是真;2.对于字符类型,只有不是空就是真;3.对于对象类型,如果是null,才是假,其余是真的;4.对于未定义类型,都是真的四.运算符• 运算符:运算符是用来连接变量组成语句的符号• 运算符的种类:算术运算符 关系运算符 逻辑运算符• 算术运算符:1. + - / % 2.* / %的优先级高于 + - 3.使用小括号可以提升优先级别 4. += 以及-=的认识,+= -=表示变量赋值分时候 ,如果用自己赋值给自己就可以使用+=或者-= ,例如 var a=5; a= a+5;可以替换为 a+=5; 5.++以及—的认识:一般++和—放在变量中使用,如果对于++,放在变量的后面,表示先使用变量,然后让变量的值加一,赋值给原来的变量;如果放在变量的前面表示先让变量的值加一,然后在赋值• 关系运算符:1. &gt; &lt; &gt;= &lt;= == === != !== 2.特点:&gt;=以及&lt;=只有一个满足条件就可以; ==只需要比较内容就可以;===既要先比较类型,在比较内容,如果两个都符合才可以 != 和!==是== ===的相反;关系运算符的结果都是布尔类型;关系运算符不可以连续• 逻辑运算符:1.&amp;&amp; || !2.特点:关系运算符进行运算符的都是布尔值 ;&amp;&amp;只有两边都是真的时候结果才是真;||只有有一个是真的返回结果就是真 ;!表示取反五.逻辑运算的一些特点• 对于&amp;&amp;运算符如果第一个表达式是真的那么第二个表达式需要计算• 对于||如果第一个是真的,那么第二个不用计算,如果第一个为假,那么第二个需要计算.• 数值或者字符参与逻辑运算:如果返回真,对于&amp;&amp;运算符,那就返回的结果是第二个表示真的值,如果返回假的,那么返回第一个为假的值;对于||,如果结果为真,返回第一个为真的值,如果为假,返回最后一个为假的值• 运算符的优先级:1.算术运算符高于关系运算符,关系运算符高于逻辑运算符 2.一般单目运算符高于双目运算符3.赋值运算符的等级最低 六.常见数学公式的使用• 取出最大值以及最小值的公式:max(); min();• 取出一个数值的正的平方根:sqart();• 设置一个数的几次方:pow()• 输入框的认识和使用• 转化整数的公式的认识:1.parseInt() 2.可以直接把数值字符转化成整数,可以截断字符,截取出数值,但是必须第一个字母是数字七.if语句的认识• 基本if语句的形式:if(判断条件){如果条件成立执行代码}else{如果条件不成立执行这里的代码};• 多重if语句的形式:if(判断条件1){如果条件1成立就执行代码}else if(判断条件二){如果条件二成立就执行括号中的代码}else{如果都不成立,就执行这里的代码}• 多重if语句的跳楼现象,也叫阻断现象:就是对于多重if语句如果,第一个条件成立了,后面的所有的条件都不再判断,• 阻止跳楼现象:就是写的时候,把else去掉就可以了• 嵌套if语句:就是if语句中有if语句,形式:if(if(){}else{} )else{if(){}else{}}; 一.js具体的作用 js可以操作样式(css):直接修改某一个盒子的高度,获取标签的方法是getelementById(); js可以操作结构(html):设置一个双标签的内容的是.innerHTML,包含了标签的中间的所有的东西二.事件的基本认识 事件的三要素:事件源:就是谁被触发了,事件属性:就是你做了什么导致了结果,事件指令:就是事件出发的结果或者影响或者事件触发后要去做的事情,形式是function(){} 事件三要素的组合:事件源.事件属性= 事件指令 点击事件的认识以及应用:onClick,通过点击按钮切换盒子的宽度颜色,以及换肤来使用加深理解，在实现换肤的效果中我们需要注意：不能通过设置line-height来设置对应中间图片让图片居中 鼠标移动事件的认识以及应用:通过鼠标移动上去修改图片的显示，以及选取食物切来加深鼠标移上去以及出来的事件；在选取食物的事例中，我们需要注意可以通过display和visiblity来隐藏标签，但是display不会占用位置，但是visibility会占用位置，我们使用display来隐藏 if语句的应用:通过使用竞价的来理解，注意理解isNaN，如果结果是true,表示不是一个数字，而且可以判断数值和字符；NaN表示一个特殊的数值类型，自己和自己也是不相等的。 switch语句的应用:使用selet标签显示不同的语句1.当select发生改变的时候,我们直接使用onchange来监听发生了改变;2.当需要获取选中的值得时候,使用select标签的value属性来获取，每个option中不要设置value值 代码的抽取:使用电脑选取切换来实现,代码抽取的原则:1.相同的东西放在一起 2.不同的东西作为参数然后形成一个函数就可以 transform属性的使用以及应用:1. Transform使用的时候是相对于第一次的位置为基准值 2. Transform旋转后会改变坐标系3.不同的浏览器的属性值是不一样的.4.transform如果想要设置同时改变，不要写在一起，不能独立写，否则会覆盖 搜索框的实现：注意我们设置背景图片是从padding开始设置的，还需要注意获取焦点以及失去光标焦点的事件的认识  Js放置的位置：可以放置在三个位置，可以放置行内样式，可以放置页内样式，可以放置外联样式，一般我们使用页内样式和外联样式  window.onlaod的认识:,window.onload表示当窗口加载完毕了,这个时候我们在js代码中获取标签才可以获取到,所以如果我们把js写在js标签的上面我们就需要先当窗口加载完毕后来获取对应的标签.三.数组的基本认识 数组的定义：数组可以用来存储大量的数据，而且可以存储 数组的特点：数组是有序的，数组中的元素可以通过序号来访问，形式：数组名称[序号];数组可以存储不同类型的数据 数组的长度：数组名称.length 数组的遍历：可以通过for循环来遍历 数组的应用：实现不同的行数设置不同的颜色 三目运算符：形式：判断条件？代码一：代码二，如果判断条件成立就执行代码一，如果不成立就执行代码二，主要应用到全选以及反选中 数组应用之排他思想：所谓排他就是让其他的所有的设置一种样式，但是自己设置自己独立的属性，一般我们实现需要两步：1.设置所有的为其他样式 2.设置自己为自己的样式 This的认识：this一般放在事件指令中，表示谁被触发了，一般是事件源。 一.数组的认识  js可以操作样式(css):直接修改某一个盒子的高度,获取标签的方法是getelementById(); 数组的基本应用:实现九宫格算法 拍他思想的认识:1.先设置所有的为一种属性2.然后设置自己的独立属性,覆盖原来的 this的认识:this一般在事件指令中,表示谁被触发了,就表示谁 拍他思想的应用,给不同的行设置不同的颜色通过拍图思想或者monse方法的对立性（mouse有两个对立的方法） 变量和属性以及方法和函数的区别:属性需要隶属于某一个对象,变量不需要,函数属于某一个对象就是方法 属性的扩展：可以给某个一个对象扩展属性，用来记录可能销毁的值 tab栏切换 tab栏切换抽取 数组的基本方法:1-push(),在数组的后面添加一个元素返回数组的长度;2-pop():从数组的后面删除一个元素返回删除的元素;3-shift(),从数组的前面删除一个元素 ,4-unshift(),从数组的前面添加一个元素,5-contact连接两个元素,原来的数组不会发生改变,6.sort();数组转化成字符后排序,但是如果要按照数值排序,需要使用匿名函数参数,函数参数会自动执行7.数组转化字符：join（）8.字符转化数组 ：split（）9.slice：用来删除某个位置的某几个元素 二.字符串的常用方法的认识 转化成字符方法的认识 1.使用连接符号+ 2.使用String方法 获取某一位置的字符以及unicode编码的认识: charCodeAt()；获取某一个位置的字符：charat(); 获取某一个字符的位置的方法的认识,indexof(),如果从后往前后去：lastindexof(),注意排序还是从左到右 获取一个字符的真正的占字节的方法的获取:一般如果是汉字unicode编码就是大于127,在0和127内是普通的字母数字。 转化大小写：转化大写：toUpperCase;转化小写：toLowerCase 截取字符的方法的认识:slice(),如果传入一个参数表示从这个参数开始截取后面的所有的字符,如果传入两个参数,表示截取从第一个参数的位置第二个参数的位置的所有字符,但是不包括第二个参数所在位置的字符 subStr:如果传入一个参数和上面一样,但是如果传入两个参数,第二个参数表示从第一个参数开始截取字符的长度 实现判断选取文件是否正确的实例 三.定时器 定时器:可以用来做到每隔一段时间自动执行某个操作的东西就叫做定时器 定时器的种类:一次定时器(setTimeout)和多次定时器(setInerval() 定时器的清除:clearTimeout():清除一次定时器; clearInerval():清除多次定时器 定时器的动画：1.匀速动画 2.缓动动画 一.节点的认识 节点的创建:一般是通过document来创建 节点的添加,一般是通过被添加节点的父节点来添加 节点的删除:一般也是通过删除节点的父节点来删除 节点的插入:节点的插入一般是通过插入节点的父节点 来操作的 获取孩子节点:通过children来获取 获取兄弟节点: nextElementSibling||nextSibling 获取父节点:parentNode 使用节点的操作动态实现九宫格的实例. 使用节点的操作实现动态发布微博的实例二. 时间对象的认识 时间对象的创建 获取当前时间的年月日星期以及时分秒:注意获取的月份是从0-11,0表示一月,其余依次类推;获取星期注意如果结果是0表示周日,如果结果是1表示周一,依次类推 实现日历效果 自定义时间,就是直接在对应的创建时间对象的括号中写入自己设置的时间就可以 实现时钟效果,时钟效果注意设置背景图片的时候,我们设置的每一个div的宽度为父标签的宽度. 一.字典 字典的创建通过{} 字典的特点:不可以重复,没有顺序 字典的访问,通过key值来访问,一般使用.如果不行就是用[] 字典的遍历:使用for(var key in json)来遍历 字典给标签设置属性 通过json动态创建节点,外层是数组,里面是字典 通过字典封装js工具类二.事件 事件对象的认识:就是事件触发的时候,会把和事件相关的东西打包成一个事件对象,通过参数event传递给事件指令 最大事件源的认识:最大事件源就是documtent 最大事件源的作用1.获取界面中的某些基本的东西 2.触发整个屏幕的相关的事件 事件对象的兼容性写法:var event = evetn ||window.event 事件对象的应用:自定义弹出菜单:事件是oncontextmenu,鼠标跟随:使用缓动动画, 事件对象的应用:拖拽鼠标 Offset属性的认识:包含了宽高以及位置 offsetWidth:包含标签本身的width＋padding + border,offsetHeight是同样的道理 offsetLeft:表示当前的标签距离他的offsetParent标签的左边的距离, offsetParent:如果获取一个标签的offsetleft,那么如果他相对于他的父标签有定位,那么他的父标签就是他的offsetparent,如果没有就找爷爷,依次往上寻找,如果一直没有,就是body为offsetparent Offset属性的特点:1不需要写style 2获取出来的值是数值3.只可以取得值,不可以设置值 滚动事件的认识:事件源是window 事件属性onscroll. 好长啊,反正没人看.自己看就好咯!!!!","tags":[{"name":"js基础","slug":"js基础","permalink":"//carrot.me/tags/js基础/"}]},{"title":"js学习之运动框架封装","date":"2016-01-13T03:02:00.000Z","path":"2016/01/13/js-运动框架封装/","text":"运动框架封装以及其他封装这一个运动框架的封装,在学习的时候真的练习了好多次啊,而且看视频也看了很多次,开始看的时候觉得挺难的,现在理解了原理后并且多次练习后,我也可以大胆说我已经熟悉这个运动框架了.这个框架的原理大概分为几步吧!!!①获取元素样式的方法 这个方法需要兼容一下②速度,目标值,初始值之间的处理③根据不同属性进行不同的赋值操作④这也是关键,需要通过for in 循环来遍历你传入的目标值,而且里面需要定义一个变量用来检测目标值,只要有一个不达到目标值都不能关闭定时器,只有当所有你传入的值达到目标值的时候才会关闭定时器⑤关闭定时器之后需要传入回调,方便调用者使用 然后自己还封装了一些获取标签的方法,因为经常用嘛,所以也封装了一下! 至于其他是一些兼容性处理的方法,这些方法也是copy别人哈哈.忘记了方便自己查看!!","tags":[{"name":"js基础","slug":"js基础","permalink":"//carrot.me/tags/js基础/"}]},{"title":"js学习之简单的应用二","date":"2016-01-12T09:02:00.000Z","path":"2016/01/12/js-选择分享功能/","text":"选择分享功能这个demo主要功能是用来选取所选的内容然后提示是否分享到某一个网站,这里用到新功能,就是如何获取选中的内容.还有如何判断当鼠标点击时候是否在当前元素上,因为可能会有几个元素重叠一起,这样就需要具体判断了,看看代码吧!","tags":[{"name":"js基础","slug":"js基础","permalink":"//carrot.me/tags/js基础/"}]},{"title":"js学习之简单的应用一","date":"2016-01-12T01:02:00.000Z","path":"2016/01/12/js-节点操作/","text":"节点操作终于学习到js啦,之间自学过java,php,终于接触到使用率很到的js了,偷懒了一下隔了几天才发学习历程,这一次通过自学js的基础简单的坐了几个小demo,第一个demo是类似于发表评论的功能. 功能的原理非常简单,在一个textarea里面让用户输入内容,然后根据用户输入的内容动态的创建节点,然后添加到页面中.主要运用了dom节点的操作方法","tags":[{"name":"js基础","slug":"js基础","permalink":"//carrot.me/tags/js基础/"}]},{"title":"css3学习之云层效果","date":"2016-01-09T09:02:00.000Z","path":"2016/01/09/css3-云层动画/","text":"漂浮的云层这一次是做一个云层漂浮效果,真的太炫酷了,虽然还没真正学习动画特效,但用css3也可以实现如此炫酷效果,的确很让人激动啊!!","tags":[{"name":"css3","slug":"css3","permalink":"//carrot.me/tags/css3/"}]},{"title":"css3学习之3d音乐界面","date":"2016-01-08T07:02:00.000Z","path":"2016/01/08/css3-3D音乐播放器/","text":"张学友演唱会哦!貌似css3还是比较新的东西,而且好像兼容性不怎么好呀,不过好像还是要学习啊.因为以后可能会普及嘛.当初看到这个效果感觉很喜欢,简单的几句代码就实现如此酷炫效果.不多说,赶快看看效果吧.","tags":[{"name":"css3","slug":"css3","permalink":"//carrot.me/tags/css3/"}]},{"title":"网页布局学习之绿色食品网","date":"2016-01-07T06:36:00.000Z","path":"2016/01/07/webLayout-绿色食品网布局/","text":"绿色食品网自学时候看到这网站比较像公司网站,就把资料下载下来自己弄了一次.难度感觉比京东淘宝还要简单,因为没那么繁琐.","tags":[{"name":"网页布局","slug":"网页布局","permalink":"//carrot.me/tags/网页布局/"}]},{"title":"网页布局学习之京东官网","date":"2016-01-06T04:50:00.000Z","path":"2016/01/06/webLayout-京东布局/","text":"京东布局再接再历,把京东官网也自己模仿了一遍,怎么感觉一模一样呢!!!.","tags":[{"name":"网页布局","slug":"网页布局","permalink":"//carrot.me/tags/网页布局/"}]},{"title":"网页布局学习之淘宝官网","date":"2016-01-04T02:36:00.000Z","path":"2016/01/04/webLayout-淘宝布局/","text":"淘宝布局学完了基础的HTML+css之后就自己动手弄了一个淘宝官网,虽然很只有一个界面,但还是有点小开心.","tags":[{"name":"网页布局","slug":"网页布局","permalink":"//carrot.me/tags/网页布局/"}]}]